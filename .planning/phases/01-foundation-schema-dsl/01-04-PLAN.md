---
phase: 01-foundation-schema-dsl
plan: 04
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - main.go
  - internal/cli/root.go
  - internal/cli/init.go
  - internal/cli/version.go
  - internal/scaffold/scaffold.go
  - internal/scaffold/templates.go
  - internal/config/config.go
  - internal/scaffold/templates/forge.toml.tmpl
  - internal/scaffold/templates/main.go.tmpl
  - internal/scaffold/templates/go.mod.tmpl
  - internal/scaffold/templates/gitignore.tmpl
  - internal/scaffold/templates/README.md.tmpl
  - internal/scaffold/templates/schema.go.tmpl
autonomous: true

must_haves:
  truths:
    - "forge init my-project creates a new directory with full starter project ready to forge generate"
    - "forge init (no arg) initializes current directory using its name"
    - "Scaffolded project includes forge.toml, resources/ directory, example schema, main.go, go.mod, .gitignore, README"
    - "forge.toml uses commented template style with all available options present but commented out"
    - "CLI output is polished with colors and icons similar to cargo build"
  artifacts:
    - path: "main.go"
      provides: "CLI entry point"
      contains: "func main()"
    - path: "internal/cli/root.go"
      provides: "Cobra root command"
      contains: "rootCmd"
    - path: "internal/cli/init.go"
      provides: "forge init command"
      contains: "func newInitCmd()"
    - path: "internal/scaffold/scaffold.go"
      provides: "Project scaffolding logic"
      contains: "func CreateProject"
    - path: "internal/scaffold/templates.go"
      provides: "Embedded template filesystem"
      contains: "embed.FS"
    - path: "internal/config/config.go"
      provides: "forge.toml configuration types"
      contains: "type Config struct"
  key_links:
    - from: "internal/cli/init.go"
      to: "internal/scaffold/scaffold.go"
      via: "Init command calls CreateProject"
      pattern: "scaffold\\.CreateProject"
    - from: "internal/scaffold/scaffold.go"
      to: "internal/scaffold/templates.go"
      via: "Scaffold reads embedded templates"
      pattern: "templatesFS"
    - from: "internal/cli/init.go"
      to: "internal/ui/styles.go"
      via: "Init command uses styled output"
      pattern: "ui\\."
---

<objective>
Build the Cobra-based CLI skeleton and the `forge init` command that scaffolds a complete starter project. This establishes the CLI infrastructure all future commands will use.

Purpose: `forge init` is the developer's first interaction with Forge. It must create a fully functional project structure that's immediately ready for `forge generate` — establishing the "it just works" developer experience.

Output: Working CLI binary with `forge init` command, embedded scaffolding templates, forge.toml configuration types.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-schema-dsl/01-CONTEXT.md
@.planning/phases/01-foundation-schema-dsl/01-RESEARCH.md
@.planning/phases/01-foundation-schema-dsl/01-01-SUMMARY.md
@.planning/phases/01-foundation-schema-dsl/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Cobra CLI skeleton with root command and config types</name>
  <files>
    main.go
    internal/cli/root.go
    internal/cli/version.go
    internal/config/config.go
  </files>
  <action>
Add Cobra dependency: `go get github.com/spf13/cobra@latest`
Add TOML dependency: `go get github.com/pelletier/go-toml/v2@latest`

Create `main.go` as the CLI entry point:
- Import internal/cli package.
- Call `cli.Execute()` which calls `rootCmd.Execute()`.
- Handle os.Exit(1) on error.

Create `internal/cli/root.go`:
- Define `rootCmd` as `&cobra.Command{}` with:
  - `Use: "forge"`
  - `Short: "Full-stack Go framework with integrated tooling"`
  - `Long:` brief description mentioning schema-driven code generation
  - `SilenceUsage: true` (don't show usage on errors)
  - `SilenceErrors: true` (we format our own errors)
- `Execute() error` function that calls `rootCmd.Execute()`.
- Persistent flag: `--config` or `-c` for config file path (default: "forge.toml").
- Register subcommands in init(): `rootCmd.AddCommand(newInitCmd())`, `rootCmd.AddCommand(newVersionCmd())`.
- DO NOT access flag values in init() (see RESEARCH.md pitfall 3).

Create `internal/cli/version.go`:
- Define version variables: `var Version = "dev"`, `var Commit = "none"`, `var Date = "unknown"` (set via ldflags at build time).
- `newVersionCmd()` returns command that prints `forge version {Version} ({Commit}) built {Date}` using ui.BoldStyle for "forge" and ui.DimStyle for build info.

Create `internal/config/config.go`:
- Define `Config` struct with TOML tags matching forge.toml sections:
  ```go
  type Config struct {
      Project  ProjectConfig  `toml:"project"`
      Database DatabaseConfig `toml:"database"`
      Tools    ToolsConfig    `toml:"tools"`
      Server   ServerConfig   `toml:"server"`
  }
  type ProjectConfig struct {
      Name    string `toml:"name"`
      Module  string `toml:"module"`
      Version string `toml:"version"`
  }
  type DatabaseConfig struct {
      URL string `toml:"url"`
  }
  type ToolsConfig struct {
      TemplVersion    string `toml:"templ_version"`
      SQLCVersion     string `toml:"sqlc_version"`
      TailwindVersion string `toml:"tailwind_version"`
      AtlasVersion    string `toml:"atlas_version"`
  }
  type ServerConfig struct {
      Port int    `toml:"port"`
      Host string `toml:"host"`
  }
  ```
- `Load(path string) (*Config, error)` function that reads and parses forge.toml using pelletier/go-toml/v2.
- `Default() Config` function returning sensible defaults.
  </action>
  <verify>Run `cd /Users/nathananderson-tennant/Development/forge-go && go build -o /dev/null .` — main.go compiles. Run `go run . version` — prints version info. Run `go run . --help` — shows forge help with init and version commands listed.</verify>
  <done>CLI entry point compiles and runs. Root command registered with init and version subcommands. Config types match forge.toml structure. Version command displays build info with styled output.</done>
</task>

<task type="auto">
  <name>Task 2: Build forge init command with embedded project templates</name>
  <files>
    internal/cli/init.go
    internal/scaffold/scaffold.go
    internal/scaffold/templates.go
    internal/scaffold/templates/forge.toml.tmpl
    internal/scaffold/templates/main.go.tmpl
    internal/scaffold/templates/go.mod.tmpl
    internal/scaffold/templates/gitignore.tmpl
    internal/scaffold/templates/README.md.tmpl
    internal/scaffold/templates/schema.go.tmpl
  </files>
  <action>
Create embedded templates in `internal/scaffold/templates/`:

`forge.toml.tmpl` — Per user decision: commented template style with all options present but commented out:
```toml
[project]
name = "{{.Name}}"
module = "{{.Module}}"
# version = "0.1.0"

[database]
# url = "postgres://localhost:5432/{{.Name}}?sslmode=disable"

[tools]
# templ_version = "0.2.793"
# sqlc_version = "1.27.0"
# tailwind_version = "3.4.17"
# atlas_version = "0.29.0"

[server]
# port = 3000
# host = "localhost"
```

`main.go.tmpl` — Starter main.go that imports the project module:
```go
package main

import (
	"fmt"
	"os"
)

func main() {
	fmt.Println("{{.Name}} — powered by Forge")
	os.Exit(0)
}
```

`go.mod.tmpl`:
```
module {{.Module}}

go {{.GoVersion}}
```

`gitignore.tmpl`:
```
# Binaries
/{{.Name}}
*.exe

# Generated code
/gen/

# Tool binaries
/.forge/tools/

# Environment
.env
.env.local

# IDE
.idea/
.vscode/
*.swp
```

`README.md.tmpl`:
```markdown
# {{.Name}}

Built with [Forge](https://github.com/forge-framework/forge).

## Getting Started

1. Define your resources in `resources/*/schema.go`
2. Run `forge generate` to generate code
3. Run `forge dev` to start the development server

## Project Structure

- `resources/` — Resource definitions (schema, handlers, views)
- `gen/` — Generated code (do not edit)
- `forge.toml` — Project configuration
```

`schema.go.tmpl` — Example product schema using the fluent API:
```go
package {{.ExampleResource}}

import "{{.Module}}/gen/schema"

// {{.ExampleResourceTitle}} resource definition
var {{.ExampleResourceTitle}} = schema.Define("{{.ExampleResourceTitle}}",
	schema.UUID("ID").PrimaryKey(),
	schema.String("Name").Required().MaxLen(200).Label("Name").Placeholder("Enter name"),
	schema.Text("Description").Help("Detailed description"),
	schema.Bool("Active").Default(true),
	schema.Timestamps(),
)
```

NOTE: The example schema imports from `gen/schema` which won't exist yet — this is intentional. The go/ast parser can parse this file without gen/ existing. The import will resolve after `forge generate` runs in Phase 2 which creates a thin re-export at gen/schema that points to internal/schema.

Create `internal/scaffold/templates.go`:
- `//go:embed templates/*` directive to embed all template files.
- Export `TemplatesFS embed.FS`.

Create `internal/scaffold/scaffold.go`:
- `ProjectData` struct: `Name string`, `Module string`, `GoVersion string`, `ExampleResource string` (lowercase), `ExampleResourceTitle string` (titlecase).
- `CreateProject(projectPath string, data ProjectData) error`:
  - Create directory structure: `resources/{exampleResource}/`, and root project dir.
  - Render each template using text/template and write to appropriate path.
  - After creating dirs, chmod 0755 (see RESEARCH.md pitfall 5).
  - Return nil on success, wrapped error on failure.
- `InferModule(projectName string) string` — returns `github.com/{user}/{projectName}` or just `projectName` as module path.

Create `internal/cli/init.go`:
- `newInitCmd() *cobra.Command`:
  - `Use: "init [name]"`, `Short: "Initialize a new Forge project"`, `Args: cobra.MaximumNArgs(1)`.
  - RunE logic:
    1. If arg provided: project name = arg, create new directory, projectPath = arg.
    2. If no arg: project name = basename of current directory, projectPath = ".".
    3. Check if forge.toml already exists in projectPath — error if so ("project already initialized").
    4. Call `scaffold.CreateProject(projectPath, data)`.
    5. If new directory was created, also run `git init` in it (exec.Command).
    6. Print styled output using ui package:
       ```
       ✓ Created project my-project

         Files:
           forge.toml
           main.go
           go.mod
           .gitignore
           README.md
           resources/product/schema.go

         Next steps:
           cd my-project
           forge generate
       ```
    7. Use `ui.Success()`, `ui.Grouped()`, and `ui.DimStyle` for the output.

Per user decision:
- `forge init my-project` creates new directory; `forge init` (no arg) initializes current directory using its name.
- Creates full starter project: forge.toml, resources/ directory, example schema, main.go, go.mod, .gitignore, README — ready to `forge generate` immediately.
- Resource-colocated layout: example resource lives in `resources/product/schema.go`.
  </action>
  <verify>
Run `cd /tmp && rm -rf test-forge-init && mkdir test-forge-init && cd test-forge-init && go run /Users/nathananderson-tennant/Development/forge-go/. init my-project` — creates my-project/ directory with all expected files. Verify: forge.toml exists with commented options, main.go exists, go.mod exists, resources/product/schema.go exists with example schema, .gitignore exists, README.md exists. Also test: `cd /tmp && rm -rf test-forge-cwd && mkdir test-forge-cwd && cd test-forge-cwd && go run /Users/nathananderson-tennant/Development/forge-go/. init` — initializes current directory.
  </verify>
  <done>
`forge init my-project` creates a complete starter project in new directory. `forge init` initializes current directory. All scaffolded files present: forge.toml (with commented template), main.go, go.mod, .gitignore, README.md, resources/product/schema.go (with example fluent schema). Output is polished with checkmarks and grouped file list.
  </done>
</task>

</tasks>

<verification>
- `go build .` — CLI binary compiles
- `forge init my-project` creates complete project structure
- `forge init` in empty directory initializes using directory name
- forge.toml has commented template style with all options
- Example schema uses fluent API: `schema.String("Name").Required().MaxLen(200)`
- resources/product/schema.go follows colocated layout
- CLI output uses colors and icons (Cargo-like feel)
- `forge version` prints build info
- `forge --help` shows available commands
</verification>

<success_criteria>
A developer can run `forge init my-app`, `cd my-app`, and find a complete project structure. The forge.toml shows all available configuration options (commented out). The example schema in resources/product/schema.go demonstrates the fluent API. The CLI output is professional and polished.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-schema-dsl/01-04-SUMMARY.md`
</output>
