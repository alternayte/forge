---
phase: 08-background-jobs-production-readiness
plan: 04
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - internal/jobs/client.go
  - internal/generator/templates/actions.go.tmpl
  - internal/generator/templates/scaffold_jobs.go.tmpl
  - internal/generator/scaffold.go
  - internal/generator/funcmap.go
autonomous: true
requirements:
  - JOBS-01
  - JOBS-02
  - JOBS-03
  - JOBS-04

must_haves:
  truths:
    - "NewRiverClient creates a *river.Client[pgx.Tx] with queues from forge.toml config and otelriver middleware"
    - "actions.go.tmpl wraps Create in pgx.BeginFunc transaction and calls river.InsertTx for each AfterCreate hook when Hooks present"
    - "actions.go.tmpl wraps Update in pgx.BeginFunc transaction and calls river.InsertTx for each AfterUpdate hook when Hooks present"
    - "InsertTx args include TenantID from forgeauth.TenantFromContext(ctx) for tenant-scoped job processing"
    - "scaffold_jobs.go.tmpl generates per-hook Worker struct with Work() stub referencing inline Args from generated actions package"
    - "actions.go.tmpl generates inline Args structs with Kind() method directly in the generated file (no import cycle)"
    - "ScaffoldResource includes jobs.go in scaffold-once file list when resource has Hooks"
  artifacts:
    - path: "internal/jobs/client.go"
      provides: "River client setup, RunRiverMigrations, and riverErrorHandler"
      contains: "func NewRiverClient"
    - path: "internal/generator/templates/actions.go.tmpl"
      provides: "Transactional InsertTx calls for AfterCreate and AfterUpdate hooks"
      contains: "InsertTx"
    - path: "internal/generator/templates/scaffold_jobs.go.tmpl"
      provides: "Scaffold-once job worker template with Worker types per hook (Args are inline in actions.go)"
      contains: "WorkerDefaults"
    - path: "internal/generator/scaffold.go"
      provides: "Updated scaffoldFiles including jobs.go for Hooks resources"
      contains: "scaffold_jobs"
  key_links:
    - from: "internal/generator/templates/actions.go.tmpl"
      to: "internal/jobs/client.go"
      via: "Generated actions import river and call a.River.InsertTx"
      pattern: "InsertTx"
    - from: "internal/generator/templates/scaffold_jobs.go.tmpl"
      to: "internal/generator/templates/actions.go.tmpl"
      via: "Scaffolded Workers reference inline Args types from generated actions via actions.{{pascal .Kind}}Args import"
      pattern: "actions\\..*Args"
---

<objective>
Integrate River background job client, generate transactional job enqueueing in the actions template, and scaffold job worker files for resources with Hooks.

Purpose: Delivers the core River integration — schema-defined hooks automatically enqueue jobs in the same DB transaction as the record mutation, with tenant-scoped args and configurable queues.
Output: internal/jobs/ package with River client, updated actions.go.tmpl with InsertTx, scaffold_jobs.go.tmpl for worker stubs.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-background-jobs-production-readiness/08-RESEARCH.md
@.planning/phases/08-background-jobs-production-readiness/08-01-SUMMARY.md

# Key files
@internal/generator/templates/actions.go.tmpl
@internal/generator/scaffold.go
@internal/generator/funcmap.go
@internal/config/config.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create River client package and job worker scaffold template</name>
  <files>
    internal/jobs/client.go
    internal/generator/templates/scaffold_jobs.go.tmpl
  </files>
  <action>
1. Create `internal/jobs/client.go` with package `jobs`:

   - `func NewRiverClient(pool *pgxpool.Pool, cfg config.JobsConfig, workers *river.Workers) (*river.Client[pgx.Tx], error)`:
     a. Build queue config map from `cfg.Queues` (map[string]int -> map[string]river.QueueConfig)
     b. Ensure `river.QueueDefault` exists with MaxWorkers=100 if not specified in config
     c. Create client: `river.NewClient(riverpgxv5.New(pool), &river.Config{Queues: queues, Workers: workers, ErrorHandler: &riverErrorHandler{}, Middleware: []rivertype.Middleware{otelriver.NewMiddleware(nil)}})`
     d. Return client

   - `type riverErrorHandler struct{}` implementing `river.ErrorHandler` interface:
     a. `HandleError(ctx, job, err)` — log with slog.WarnContext
     b. `HandlePanic(ctx, job, panicVal, trace)` — log with slog.ErrorContext

   - `func RunRiverMigrations(ctx context.Context, pool *pgxpool.Pool) error`:
     a. Create migrator: `rivermigrate.New(riverpgxv5.New(pool), nil)`
     b. Run: `migrator.Migrate(ctx, rivermigrate.DirectionUp, nil)`
     c. Return error

   Run `go get`:
   ```
   go get github.com/riverqueue/river
   go get github.com/riverqueue/river/riverpgxv5
   go get github.com/riverqueue/river/rivermigrate
   go get github.com/riverqueue/rivercontrib/otelriver
   ```

2. Create `internal/generator/templates/scaffold_jobs.go.tmpl`:
   - Package: `{{snake .Resource.Name}}`
   - This is a scaffold-once template (like scaffold_handlers.go.tmpl)
   - **Important:** The Args structs (with Kind() method) are generated inline in the actions.go output (see Plan 08-04 Task 2). The scaffold file generates only the Worker types that reference those Args types via import.
   - For each hook in `.Resource.Options.Hooks.AfterCreate` and `.Resource.Options.Hooks.AfterUpdate`, generate:
     a. Worker struct: `type {{pascal .Kind}}Worker struct { river.WorkerDefaults[actions.{{pascal .Kind}}Args] }` with TODO comment for adding dependencies (e.g., DB pool, mailer)
     b. Work method: `func (w *{{pascal .Kind}}Worker) Work(ctx context.Context, job *river.Job[actions.{{pascal .Kind}}Args]) error` with:
        - `ctx = forgeauth.WithTenant(ctx, job.Args.TenantID)` for tenant context restoration (JOBS-03)
        - TODO placeholder for job logic
        - `return nil`
   - Imports: context, github.com/riverqueue/river, generated actions package (e.g., `gen/actions`), project auth package
   - Use `pascal` funcmap helper (added in Plan 01 Task 2) for converting Kind strings like "notify_new_product" to "NotifyNewProduct". The `pascal` helper splits on underscores and title-cases each segment.
  </action>
  <verify>
Run `go build ./internal/jobs/...` — compiles.

Run `go build ./internal/generator/...` — compiles (template is embedded, not compiled).
  </verify>
  <done>
River client wires queues from config with otelriver middleware. RunRiverMigrations handles River's own schema setup. riverErrorHandler logs exhausted/panicked jobs via slog. scaffold_jobs.go.tmpl generates per-hook Worker with Work() stub referencing Args types from the generated actions package.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update actions template for transactional InsertTx and scaffold integration</name>
  <files>
    internal/generator/templates/actions.go.tmpl
    internal/generator/scaffold.go
    internal/generator/funcmap.go
  </files>
  <action>
1. In `internal/generator/funcmap.go`:
   - Verify `hasHooks` and `pascal` helpers exist (added in Plan 01 Task 2). If either is missing, add them now:
     - `hasHooks`: `func(opts parser.ResourceOptionsIR) bool { return len(opts.Hooks.AfterCreate) > 0 || len(opts.Hooks.AfterUpdate) > 0 }`
     - `pascal`: splits on `_`, title-cases each segment, joins (e.g., `"notify_new_product"` -> `"NotifyNewProduct"`)

2. In `internal/generator/templates/actions.go.tmpl` — use the **inline Args approach** to avoid import cycles (the generated actions package MUST NOT import user-scaffolded resource packages):

   a. Add conditional import for river and pgx when hasHooks:
     ```
     {{- if hasHooks .Options}}
     "github.com/jackc/pgx/v5"
     "github.com/riverqueue/river"
     {{- end}}
     ```

   b. Generate inline Args structs directly in the actions.go output, right after the DB interface definition, guarded by `{{if hasHooks .Options}}`. For each hook in AfterCreate and AfterUpdate, generate a minimal Args type:
     ```
     {{- if hasHooks .Options}}
     // Job args types (generated inline to avoid import cycles with resources/)
     {{- range .Options.Hooks.AfterCreate}}
     type {{pascal .Kind}}Args struct {
         ResourceID uuid.UUID `json:"resource_id"`
         TenantID   uuid.UUID `json:"tenant_id"`
     }
     func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }
     {{- end}}
     {{- range .Options.Hooks.AfterUpdate}}
     type {{pascal .Kind}}Args struct {
         ResourceID uuid.UUID `json:"resource_id"`
         TenantID   uuid.UUID `json:"tenant_id"`
     }
     func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }
     {{- end}}
     {{- end}}
     ```
     These inline Args types are the **canonical** types for InsertTx calls. The scaffold_jobs.go.tmpl in resources/ generates the Worker types that reference these same Kind strings — the Worker's `river.WorkerDefaults[T]` generic parameter will use the inline Args from the generated actions package (imported by the worker file).

   c. Add `River *river.Client[pgx.Tx]` field to `Default{{.Name}}Actions` struct when hasHooks:
     ```
     {{- if hasHooks .Options}}
     River *river.Client[pgx.Tx]
     {{- end}}
     ```

   d. Modify the `Create` method body when AfterCreate hooks exist:
     ```
     {{- if .Options.Hooks.AfterCreate}}
     // Transactional create with AfterCreate job hooks (JOBS-02)
     var result *models.{{.Name}}
     err := pgx.BeginFunc(ctx, a.DB, func(tx pgx.Tx) error {
         // TODO: Execute Bob insert via tx (replace when Bob is wired)
         _ = tx
         return errors.InternalError("Create not yet implemented")

         {{range .Options.Hooks.AfterCreate}}
         // Enqueue {{.Kind}} job in same transaction
         _, enqErr := a.River.InsertTx(ctx, tx, {{pascal .Kind}}Args{
             ResourceID: result.ID,
             TenantID:   forgeauth.TenantFromContext(ctx),
         }, &river.InsertOpts{ {{- if .Queue}}Queue: "{{.Queue}}",{{end}} })
         if enqErr != nil {
             return enqErr
         }
         {{end}}
         return nil
     })
     return result, err
     {{- else}}
     // (existing non-hook Create code)
     {{- end}}
     ```
     **Note:** The InsertTx calls are structurally present but unreachable until Bob queries replace the TODO. This matches the existing pattern where Create returns an error placeholder.

   e. Apply the same transactional pattern to `Update` for `.Options.Hooks.AfterUpdate`.

3. In `internal/generator/scaffold.go`:
   - Update `scaffoldFiles()` to conditionally include `scaffold_jobs.go.tmpl` when the resource has hooks. Since `scaffoldFiles()` currently returns a static list, you have two options:
     a. Make `scaffoldFiles` accept a `parser.ResourceIR` parameter and conditionally append the jobs entry
     b. Add a separate function `scaffoldJobsFile()` that returns the jobs scaffold entry
   - Option (a) is cleaner. Update the function signature to `scaffoldFiles(resource parser.ResourceIR) []scaffoldFile` and conditionally append `{Template: "templates/scaffold_jobs.go.tmpl", OutputPath: "jobs.go", IsTempl: false}` when `len(resource.Options.Hooks.AfterCreate) > 0 || len(resource.Options.Hooks.AfterUpdate) > 0`.
   - Update all callers of `scaffoldFiles()` in ScaffoldResource, renderScaffoldToMap, and DiffResource to pass the resource parameter.
  </action>
  <verify>
Run `go build ./internal/generator/...` — compiles.

Run `go test ./internal/generator/... -count=1` — all existing tests pass (no regressions from template changes).

Run `go vet ./internal/generator/...` — no issues.
  </verify>
  <done>
actions.go.tmpl generates River InsertTx calls inside pgx.BeginFunc transactions for resources with Hooks. AfterCreate hooks enqueue in Create method transaction; AfterUpdate hooks enqueue in Update method transaction. InsertTx args include TenantID from context (JOBS-03). scaffold_jobs.go.tmpl scaffolds worker stubs with Kind() and Work(). scaffoldFiles() conditionally includes jobs.go for Hooks resources.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/jobs/...` — compiles
2. `go build ./internal/generator/...` — compiles
3. `go test ./internal/generator/... -count=1` — all tests pass
4. `go vet ./...` — no issues
5. Template content: actions.go.tmpl contains InsertTx, pgx.BeginFunc, river.InsertOpts references
6. scaffold_jobs.go.tmpl contains worker Kind() method and Work() stub
</verification>

<success_criteria>
- River client created with configurable queues and otelriver middleware (JOBS-01, JOBS-04)
- Generated actions use transactional InsertTx inside pgx.BeginFunc for hook jobs (JOBS-02)
- Job args include TenantID from context (JOBS-03)
- Worker scaffold generates per-hook Args/Worker types (scaffold-once pattern)
- scaffoldFiles conditionally includes jobs.go for Hooks resources
- No regressions in existing generator tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-background-jobs-production-readiness/08-04-SUMMARY.md`
</output>
