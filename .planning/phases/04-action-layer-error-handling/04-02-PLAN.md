---
phase: 04-action-layer-error-handling
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - internal/generator/actions.go
  - internal/generator/actions_test.go
  - internal/generator/templates/actions.go.tmpl
  - internal/generator/templates/actions_types.go.tmpl
autonomous: true

must_haves:
  truths:
    - "Each resource gets a generated Actions interface with List, Get, Create, Update, Delete methods"
    - "Each resource gets a DefaultActions implementation that validates input, executes DB operations, and maps errors"
    - "Developer can override actions by embedding DefaultActions and replacing specific methods"
    - "Developer can add custom validation by implementing CreateValidator/UpdateValidator interfaces"
    - "Both HTML and API handlers can call the same Actions interface (no business logic duplication)"
    - "Resource registration happens explicitly at app startup (no init() magic)"
  artifacts:
    - path: "internal/generator/actions.go"
      provides: "Action generation function"
      exports: ["GenerateActions"]
    - path: "internal/generator/templates/actions.go.tmpl"
      provides: "Per-resource Actions interface and DefaultActions implementation"
      contains: "type {{.Name}}Actions interface"
    - path: "internal/generator/templates/actions_types.go.tmpl"
      provides: "Shared action types (CreateValidator, UpdateValidator, Registry)"
      contains: "type CreateValidator"
  key_links:
    - from: "gen/actions/{resource}.go (generated)"
      to: "gen/validation/"
      via: "DefaultActions.Create calls validation.Validate{Resource}Create"
      pattern: "validation\\.Validate"
    - from: "gen/actions/{resource}.go (generated)"
      to: "gen/errors/"
      via: "DefaultActions returns errors.NewValidationError and errors.MapDBError"
      pattern: "errors\\.(NewValidationError|MapDBError|NotFound)"
    - from: "gen/actions/{resource}.go (generated)"
      to: "gen/queries/"
      via: "DefaultActions.List accepts query mods for filtering/sorting"
      pattern: "queries\\."
    - from: "gen/actions/types.go (generated)"
      to: "gen/actions/{resource}.go"
      via: "Registry stores actions by name, type assertions check for validator interfaces"
      pattern: "type Registry struct"
---

<objective>
Generate action interfaces and default implementations for each resource, providing the shared business logic layer that both HTML and API handlers will call.

Purpose: The action layer is the central requirement of Phase 4 -- it prevents business logic duplication between the dual interfaces (Datastar HTML and Huma API). Each resource gets a generated interface defining CRUD operations and a DefaultActions struct implementing validation, DB queries, and error mapping. Developers override by embedding DefaultActions and replacing specific methods.

Output: Generator functions and templates that produce `gen/actions/types.go` (shared types) and `gen/actions/{resource}.go` (per-resource interface + default implementation) when `forge generate` runs.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-action-layer-error-handling/04-RESEARCH.md
@.planning/phases/04-action-layer-error-handling/04-01-SUMMARY.md
@internal/generator/generator.go
@internal/generator/validation.go
@internal/generator/templates/validation.go.tmpl
@internal/generator/funcmap.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create action type templates (shared types and per-resource)</name>
  <files>
    internal/generator/templates/actions_types.go.tmpl
    internal/generator/templates/actions.go.tmpl
  </files>
  <action>
Create two Go templates in internal/generator/templates/:

1. `actions_types.go.tmpl` - Generates `gen/actions/types.go` with shared types:
   - Package `actions` with DO NOT EDIT header
   - `type DB interface` with methods matching pgx pool interface:
     - `QueryRow(ctx context.Context, sql string, args ...any) pgx.Row`
     - `Query(ctx context.Context, sql string, args ...any) (pgx.Rows, error)`
     - `Exec(ctx context.Context, sql string, args ...any) (pgconn.CommandTag, error)`
   - Note: Use interface{} or any instead of pgx types in the interface to avoid tight coupling. Actually, since this is generated code that will always run with pgx, use the pgx types directly. Import "github.com/jackc/pgx/v5" and "github.com/jackc/pgx/v5/pgconn".
   - `type CreateValidator interface` with `ValidateCreate(ctx context.Context, input any) error`
   - `type UpdateValidator interface` with `ValidateUpdate(ctx context.Context, id any, input any) error`
   - `type Registry struct` with `actions map[string]any` field
   - `func NewRegistry() *Registry` returning initialized Registry
   - `func (r *Registry) Register(name string, actions any)` storing actions by resource name
   - `func (r *Registry) Get(name string) (any, bool)` retrieving actions by name
   - `func GetTyped[T any](r *Registry, name string) (T, bool)` generic helper for type-safe retrieval
   - Template takes `{{.ProjectModule}}` data for imports
   - Imports: "context", "github.com/jackc/pgx/v5", "github.com/jackc/pgx/v5/pgconn"

2. `actions.go.tmpl` - Generates `gen/actions/{snake_name}.go` per resource:
   - Package `actions` with DO NOT EDIT header
   - Template receives ResourceIR + ProjectModule

   Interface definition:
   ```
   type {{.Name}}Actions interface {
       List(ctx context.Context, filter models.{{.Name}}Filter, sort models.{{.Name}}Sort, page int, pageSize int) ([]models.{{.Name}}, int64, error)
       Get(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error)
       Create(ctx context.Context, input models.{{.Name}}Create) (*models.{{.Name}}, error)
       Update(ctx context.Context, id uuid.UUID, input models.{{.Name}}Update) (*models.{{.Name}}, error)
       Delete(ctx context.Context, id uuid.UUID) error
   }
   ```
   Note: Use uuid.UUID for ID type since all resources use UUID IDs (per schema DSL design). Import "github.com/google/uuid".

   Default implementation:
   ```
   type Default{{.Name}}Actions struct {
       DB DB
   }
   ```

   Method implementations (following research patterns):

   - `List`: Build query using Bob query mods from filter/sort, execute with pagination, return results + total count. Since Bob query execution layer isn't fully built yet, generate the method signature and structure with TODO comments for the actual Bob query execution. The key contract is: accepts filter/sort structs, returns typed results. For now, use placeholder query logic that will be completed when Bob integration is ready. Actually -- look at what gen/queries/ already provides: FilterMods() and SortMod(). The List method should call those. But actual query execution (scanning rows) isn't generated yet. Generate the method body with: (a) call queries.FilterMods to get mods, (b) call queries.SortMod, (c) leave a TODO comment for actual Bob query execution, (d) return empty slice and 0 count for now. This way the interface contract is correct and wiring is in place.

   - `Get`: Accept id, query DB for single record. Similar pattern -- generate structure with placeholder for actual query. Return errors.NotFound if not found.

   - `Create`:
     1. Check if self implements CreateValidator interface via type assertion: `if v, ok := any(a).(CreateValidator); ok { if err := v.ValidateCreate(ctx, input); err != nil { return nil, err } } else { ... }`
     2. In else branch: call `validation.Validate{{.Name}}Create(input)` and if HasErrors, return `errors.NewValidationError(valErrs)`
     3. Execute insert (placeholder with TODO for actual Bob/SQLC insert)
     4. On DB error, return `errors.MapDBError(err)`
     5. Return created record

   - `Update`:
     1. Check if self implements UpdateValidator
     2. In else branch: call `validation.Validate{{.Name}}Update(input)` and check HasErrors
     3. Execute update (placeholder)
     4. On DB error, return MapDBError
     5. Return updated record

   - `Delete`: Execute delete by ID (placeholder), on DB error return MapDBError

   Imports: "context", "github.com/google/uuid", "{{.ProjectModule}}/gen/models", "{{.ProjectModule}}/gen/validation", "{{.ProjectModule}}/gen/errors", "{{.ProjectModule}}/gen/queries"

   IMPORTANT: The generated code must compile. Since actual query execution is placeholder, use patterns like returning nil/empty values after the TODO comments. The validator interface check pattern must work: `any(a)` converts `*Default{{.Name}}Actions` to `any`, then type-assert to `CreateValidator`. This works because when a developer embeds DefaultActions and implements ValidateCreate, the outer struct satisfies the interface.

   IMPORTANT: The `any(a)` pattern does NOT work for checking validator interfaces on the DefaultActions itself -- it would need to check the actual concrete type that may embed this. The research pattern (Pattern 4) uses `any(a).(CreateValidator)` which works when called on the embedding struct. However, since DefaultActions methods receive `a *Default{{.Name}}Actions`, not the embedding type, the type assertion would fail. Solution: Do NOT use the validator interface check inside DefaultActions. Instead, always call the generated validation in DefaultActions. The developer overrides the entire Create method when they want custom validation (calling a.DefaultActions.Create after their own checks, or writing custom validation inline). This is simpler and follows the embedding override pattern more naturally. Remove CreateValidator/UpdateValidator from the design -- they add complexity without benefit since embedding already handles overrides.

   REVISED approach for Create/Update:
   1. Call generated validation: `valErrs := validation.Validate{{.Name}}Create(input); if valErrs.HasErrors() { return nil, errors.NewValidationError(valErrs) }`
   2. Execute DB operation (placeholder)
   3. Map DB errors via errors.MapDBError

   Keep CreateValidator/UpdateValidator interfaces in types.go as optional advanced pattern but do NOT use them in DefaultActions. Document in comments that developers can implement these on their custom struct and check for them in their overridden methods.
  </action>
  <verify>
Read both template files and confirm:
- actions_types.go.tmpl contains DB interface, CreateValidator, UpdateValidator, Registry struct
- actions.go.tmpl contains {{.Name}}Actions interface with List/Get/Create/Update/Delete
- actions.go.tmpl contains Default{{.Name}}Actions struct with DB field
- actions.go.tmpl Create method calls validation.Validate{{.Name}}Create and errors.NewValidationError
- actions.go.tmpl methods reference errors.MapDBError and errors.NotFound
  </verify>
  <done>Both template files exist with correct interface definitions, DefaultActions calls generated validation and uses forge.Error for all error returns</done>
</task>

<task type="auto">
  <name>Task 2: Create action generator function and tests</name>
  <files>
    internal/generator/actions.go
    internal/generator/actions_test.go
  </files>
  <action>
Create the generator function and tests following the exact pattern of internal/generator/validation.go:

1. `actions.go` - Generator function:
   - `func GenerateActions(resources []parser.ResourceIR, outputDir string, projectModule string) error`
   - Creates `gen/actions/` directory via ensureDir
   - First renders `templates/actions_types.go.tmpl` with `struct{ ProjectModule string }{ ProjectModule: projectModule }` data
   - Writes to `gen/actions/types.go` via writeGoFile
   - Then iterates resources, for each:
     - Prepares template data struct embedding ResourceIR + ProjectModule (same pattern as validation.go)
     - Renders `templates/actions.go.tmpl`
     - Writes to `gen/actions/{snake_name}.go` via writeGoFile
   - Returns nil on success

2. `actions_test.go` - Tests:
   - `TestGenerateActions` - end-to-end test:
     - Creates temp directory
     - Defines a test ResourceIR (e.g., "Product" with Name, Price, Description fields matching patterns from other tests)
     - Calls GenerateActions with the resource and temp dir
     - Reads generated `actions/types.go` file
     - Asserts it contains: "type DB interface", "type CreateValidator interface", "type Registry struct", "func NewRegistry"
     - Reads generated `actions/product.go` file
     - Asserts it contains: "type ProductActions interface", "type DefaultProductActions struct", "func (a *DefaultProductActions) Create", "func (a *DefaultProductActions) List", "func (a *DefaultProductActions) Get", "func (a *DefaultProductActions) Update", "func (a *DefaultProductActions) Delete"
     - Asserts it contains validation wiring: "validation.ValidateProductCreate"
     - Asserts it contains error wiring: "errors.MapDBError", "errors.NotFound"
   - `TestGenerateActions_MultipleResources` - verifies separate file per resource:
     - Creates two resources (Product, Category)
     - Calls GenerateActions
     - Verifies both product.go and category.go exist in actions/

Do NOT modify generator.go yet - that wiring happens in Plan 03.
  </action>
  <verify>
Run `go test ./internal/generator/ -run TestGenerateActions -v` and confirm all tests pass.
Run `go build ./internal/generator/` and confirm clean compile.
Run `go vet ./internal/generator/` and confirm no issues.
  </verify>
  <done>GenerateActions function produces gen/actions/types.go with shared types and gen/actions/{resource}.go per resource with Actions interface + DefaultActions implementation, all tests pass</done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/ -run TestGenerateActions -v` passes
2. `go build ./internal/generator/` compiles cleanly
3. `go vet ./internal/generator/` reports no issues
4. Generated types.go contains DB interface, CreateValidator, UpdateValidator, Registry
5. Generated per-resource file contains {Resource}Actions interface with all 5 CRUD methods
6. Generated Default{Resource}Actions.Create calls validation and wraps errors with forge.Error
7. Generated actions import gen/validation, gen/errors, gen/queries, gen/models packages
</verification>

<success_criteria>
- Each resource gets a {Resource}Actions interface with List, Get, Create, Update, Delete
- Each resource gets Default{Resource}Actions struct with DB field implementing the interface
- Create/Update methods call generated validation functions and wrap results in forge.Error
- DB errors routed through errors.MapDBError
- Not-found returns errors.NotFound
- Registry provides explicit registration (no init() magic) - Register/Get by resource name
- CreateValidator/UpdateValidator interfaces available for advanced custom validation
- All generated code compiles (verified by go build in tests)
</success_criteria>

<output>
After completion, create `.planning/phases/04-action-layer-error-handling/04-02-SUMMARY.md`
</output>
