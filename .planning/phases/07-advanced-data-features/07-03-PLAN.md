---
phase: 07-advanced-data-features
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - internal/auth/tenant.go
  - internal/generator/templates/queries.go.tmpl
  - internal/generator/templates/atlas_schema.hcl.tmpl
  - internal/generator/templates/model.go.tmpl
  - internal/generator/templates/factory.go.tmpl
autonomous: true
requirements:
  - TENANT-01
  - DATA-05
  - TENANT-02
  - TENANT-03
  - TENANT-04

must_haves:
  truths:
    - "TenantResolver interface with header, subdomain, and path implementations exists in internal/auth"
    - "TenantFromContext and WithTenant helpers propagate tenant ID via context.Context"
    - "When TenantScoped is true, generated queries include tenant_id WHERE clause automatically"
    - "Atlas generates RLS policies for tenant-scoped resources"
    - "Model struct includes TenantID field and factory sets a default test tenant"
  artifacts:
    - path: "internal/auth/tenant.go"
      provides: "TenantResolver interface, HeaderTenantResolver, SubdomainTenantResolver, PathTenantResolver, WithTenant, TenantFromContext"
      contains: "TenantResolver"
    - path: "internal/generator/templates/queries.go.tmpl"
      provides: "TenantMod query method for automatic tenant scoping"
      contains: "TenantMod"
    - path: "internal/generator/templates/atlas_schema.hcl.tmpl"
      provides: "tenant_id column and RLS policy for tenant-scoped tables"
      contains: "tenant_isolation"
    - path: "internal/generator/templates/model.go.tmpl"
      provides: "TenantID uuid.UUID field on model struct when TenantScoped"
      contains: "TenantID"
    - path: "internal/generator/templates/factory.go.tmpl"
      provides: "Default test TenantID in factory when TenantScoped"
      contains: "TenantID"
  key_links:
    - from: "internal/auth/tenant.go"
      to: "internal/generator/templates/queries.go.tmpl"
      via: "TenantFromContext used by generated TenantMod to read tenant from context"
      pattern: "TenantFromContext"
    - from: "internal/generator/templates/atlas_schema.hcl.tmpl"
      to: "ResourceOptionsIR.TenantScoped"
      via: "Conditional RLS policy and tenant_id column when TenantScoped is true"
      pattern: "TenantScoped"
---

<objective>
Implement tenant isolation: runtime tenant context propagation, query-level tenant scoping, Atlas RLS policies, and tenant-aware model/factory generation.

Purpose: TENANT-01 through TENANT-04 and DATA-05 require that tenant-scoped resources automatically filter by tenant_id and have PostgreSQL RLS as a safety net. This enables multi-tenant applications where data is strictly isolated per tenant.

Output: New internal/auth/tenant.go runtime file. Updated queries, atlas, model, and factory templates with tenant-conditional logic.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-RESEARCH.md
@.planning/phases/07-advanced-data-features/07-01-SUMMARY.md
@.planning/phases/07-advanced-data-features/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tenant runtime (context helpers + resolvers) and update model/factory templates</name>
  <files>
    internal/auth/tenant.go
    internal/generator/templates/model.go.tmpl
    internal/generator/templates/factory.go.tmpl
  </files>
  <action>
    1. Create `internal/auth/tenant.go` (NEW file) with the following:

       Package `auth` (matches existing files in internal/auth/).

       a. Private context key types using the standard Go pattern (struct{} keys):
          ```go
          type tenantContextKey struct{}
          ```

       b. Context helpers:
          - `WithTenant(ctx context.Context, id uuid.UUID) context.Context` — stores tenant ID in context
          - `TenantFromContext(ctx context.Context) (uuid.UUID, bool)` — retrieves tenant ID from context
          Uses `context.WithValue` with the private key type to prevent collisions.

       c. `TenantResolver` interface:
          ```go
          type TenantResolver interface {
              Resolve(r *http.Request) (uuid.UUID, error)
          }
          ```

       d. Three implementations per user decision (developer configures strategy):
          - `HeaderTenantResolver` — reads tenant ID from configurable header (default: X-Tenant-ID)
            ```go
            type HeaderTenantResolver struct{ Header string }
            func (h HeaderTenantResolver) Resolve(r *http.Request) (uuid.UUID, error) {
                raw := r.Header.Get(h.Header)
                if raw == "" { return uuid.Nil, fmt.Errorf("missing tenant header %s", h.Header) }
                return uuid.Parse(raw)
            }
            ```
          - `SubdomainTenantResolver` — extracts first subdomain segment from Host header, parses as UUID
          - `PathTenantResolver` — extracts tenant ID from URL path prefix (e.g., /tenants/{id}/...)

       e. `TenantMiddleware` function that wraps an http.Handler:
          ```go
          func TenantMiddleware(resolver TenantResolver) func(http.Handler) http.Handler {
              return func(next http.Handler) http.Handler {
                  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                      tenantID, err := resolver.Resolve(r)
                      if err != nil {
                          http.Error(w, "tenant not found", http.StatusUnauthorized)
                          return
                      }
                      ctx := WithTenant(r.Context(), tenantID)
                      next.ServeHTTP(w, r.WithContext(ctx))
                  })
              }
          }
          ```

       Imports: `context`, `fmt`, `net/http`, `strings`, `github.com/google/uuid`

    2. In `model.go.tmpl`, add TenantID field to the main model struct when TenantScoped:
       After the ID field line and before the `{{- range .Fields}}` loop, add:
       ```
       {{- if .Options.TenantScoped}}
       TenantID uuid.UUID `json:"tenant_id" db:"tenant_id"`
       {{- end}}
       ```

    3. In `factory.go.tmpl`, add TenantID default value when TenantScoped:
       Inside the `New{{.Name}}()` function return block, after the range loop over Fields, add:
       ```
       {{- if .Options.TenantScoped}}
       TenantID: uuid.MustParse("00000000-0000-0000-0000-000000000001"), // default test tenant
       {{- end}}
       ```
       Also add a `WithTenantID` builder method inside a TenantScoped guard:
       ```
       {{- if .Options.TenantScoped}}
       // WithTenantID sets the TenantID field.
       func (b *{{.Name}}Builder) WithTenantID(v uuid.UUID) *{{.Name}}Builder {
           b.instance.TenantID = v
           return b
       }
       {{- end}}
       ```
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/auth/... && go build ./internal/generator/...` — both compile.
  </verify>
  <done>
    internal/auth/tenant.go exists with TenantResolver interface, 3 resolver implementations (header/subdomain/path), TenantMiddleware, WithTenant, and TenantFromContext. model.go.tmpl includes TenantID field when TenantScoped. factory.go.tmpl provides default test tenant UUID and WithTenantID builder method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tenant query scoping and Atlas RLS policies</name>
  <files>
    internal/generator/templates/queries.go.tmpl
    internal/generator/templates/atlas_schema.hcl.tmpl
  </files>
  <action>
    1. In `queries.go.tmpl`, add tenant scoping query mod AFTER the soft delete mods (from Plan 02), guarded by `{{- if .Options.TenantScoped}}`:

       ```
       {{- if .Options.TenantScoped}}

       // TenantMod scopes the query to the current tenant from context.
       // Panics if tenant ID is not in context — ensure TenantMiddleware is applied.
       func (f {{$resource}}Filters) TenantMod(ctx context.Context) sm.QueryMod[*psql.SelectQuery] {
           tenantID, ok := forgeauth.TenantFromContext(ctx)
           if !ok {
               panic("{{$resource}}: tenant ID required in context — is TenantMiddleware applied?")
           }
           return sm.Where(psql.Quote("tenant_id").EQ(psql.Arg(tenantID)))
       }
       {{- end}}
       ```

       Add the import for the auth package. The import section at the top of queries.go.tmpl currently imports models, psql, and sm. Add a conditional import:
       ```
       {{- if .Options.TenantScoped}}
       "context"
       forgeauth "github.com/forge-framework/forge/internal/auth"
       {{- end}}
       ```
       Note: Use `forgeauth` alias to avoid collision with any other `auth` package. The import management (golang.org/x/tools/imports) used by writeGoFile should handle removing unused imports, but being explicit is cleaner.

    2. In `atlas_schema.hcl.tmpl`, add tenant_id column and RLS policy for TenantScoped resources:

       a. Inside the table block, AFTER the SoftDelete column block and BEFORE the primary_key block, add:
       ```
       {{if .Options.TenantScoped}}
       column "tenant_id" {
         type = uuid
         null = false
       }
       {{end}}
       ```

       b. Inside the table block, AFTER the existing index blocks (after the `{{end}}` of the field range), add the RLS policy:
       ```
       {{if .Options.TenantScoped}}
       # Row Level Security policy for tenant isolation (defense-in-depth).
       # Application-level WHERE clause via TenantMod handles performance (index usage).
       # RLS is the safety net — SET LOCAL app.current_tenant per-transaction.
       # Note: The application must run SET LOCAL app.current_tenant = $1 inside a transaction
       # for this policy to take effect. Without it, RLS blocks all access (secure by default).

       index "{{plural (snake $resourceName)}}_tenant_id_idx" {
         columns = [column.tenant_id]
       }
       {{end}}
       ```

       c. OUTSIDE the `{{range .Resources}}` loop, AFTER the sessions table block, add the RLS enable statement for all tenant-scoped tables. Since Atlas HCL does not have a native `ALTER TABLE ... ENABLE ROW LEVEL SECURITY` block, generate this as an `hcl_schema` block that Atlas will apply. Actually, Atlas HCL supports this via the `row_level_security` block inside the table:

       Inside the table block, after the tenant_id index, add:
       ```
       {{if .Options.TenantScoped}}
       row_level_security {
         enabled  = true
         enforced = true
       }
       {{end}}
       ```

       Note: Atlas HCL v0.14+ supports `row_level_security` block. If this causes issues at runtime, the executor can adjust syntax. The research confirms Atlas supports RLS policy generation.

       For the actual policy definition, Atlas uses a `policy` block outside the table (at schema level). Add AFTER each table block's closing `}` but still inside the `{{range .Resources}}` loop:
       ```
       {{if .Options.TenantScoped}}
       # RLS policy: only rows matching current tenant are visible
       # Requires: SET LOCAL app.current_tenant = '<uuid>' at transaction start
       {{end}}
       ```

       Actually, the safest approach per research is to keep RLS policy generation simple. Add a comment documenting the required manual SQL for RLS policy setup, since Atlas HCL policy syntax varies by version. The application-level WHERE clause (TenantMod) is the primary isolation layer per user decision ("defense in depth: application-level WHERE clause for performance + PostgreSQL RLS policies as safety net").

       Final approach for Atlas: Add tenant_id column, tenant_id index, and a code comment about RLS. Generate a separate SQL file or migration hook for the actual RLS ENABLE + CREATE POLICY statements. But per user decision, keep it simple: just document the RLS SQL in a comment in the generated HCL for now. The application-level WHERE clause is the primary enforcer.

       REVISED: Add tenant_id column + index inside the table. For RLS, add a comment block documenting the required SQL. This avoids Atlas version-specific issues while still generating the infrastructure columns.
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Review queries.go.tmpl for TenantMod method. Review atlas_schema.hcl.tmpl for tenant_id column and index.
  </verify>
  <done>
    queries.go.tmpl has TenantMod method that reads tenant from context and applies WHERE tenant_id = $1. atlas_schema.hcl.tmpl generates tenant_id column (uuid, not null), tenant_id index, and RLS documentation comment for TenantScoped resources. Application-level WHERE is the primary tenant isolation (per user decision), with RLS as documented safety net.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/auth/...` compiles (tenant.go)
2. `go build ./internal/generator/...` compiles (template changes)
3. internal/auth/tenant.go has TenantResolver interface + 3 implementations
4. queries.go.tmpl has TenantMod inside `{{if .Options.TenantScoped}}`
5. atlas_schema.hcl.tmpl has tenant_id column and index inside TenantScoped guard
6. model.go.tmpl has TenantID field inside TenantScoped guard
7. factory.go.tmpl has default test TenantID inside TenantScoped guard
</verification>

<success_criteria>
Tenant isolation is fully wired: runtime context helpers exist, queries automatically scope by tenant_id, Atlas generates the tenant_id column with index, models include TenantID, and test factories scope to a test tenant. The application-level WHERE clause provides the primary isolation with RLS documented as a safety net.
</success_criteria>

<output>
After completion, create `.planning/phases/07-advanced-data-features/07-03-SUMMARY.md`
</output>
