// Code generated by Forge. DO NOT EDIT.

package middleware

import (
	"encoding/json"
	stderrors "errors"
	"fmt"
	"html"
	"net/http"
	"strings"

	"{{.ProjectModule}}/gen/errors"
)

// ErrorResponder renders errors appropriately based on request context.
// It checks Accept headers and path patterns to determine the best response format.
func ErrorResponder(w http.ResponseWriter, r *http.Request, err error) {
	// Extract forge.Error from error (or wrap if not a forge.Error)
	var forgeErr *errors.Error
	if !stderrors.As(err, &forgeErr) {
		forgeErr = errors.InternalError(err)
	}

	// Determine response format based on request context
	accept := r.Header.Get("Accept")

	// SSE context (Datastar interactions)
	if accept == "text/event-stream" {
		writeSSEError(w, forgeErr)
		return
	}

	// JSON context (API requests)
	if accept == "application/json" || strings.HasPrefix(r.URL.Path, "/api/") {
		writeJSONError(w, forgeErr)
		return
	}

	// HTML context (default)
	writeHTMLError(w, forgeErr)
}

// writeSSEError renders an error as an SSE fragment (toast notification).
// SSE always uses 200 status with the error in the event data.
func writeSSEError(w http.ResponseWriter, err *errors.Error) {
	w.Header().Set("Content-Type", "text/event-stream")
	w.Header().Set("Cache-Control", "no-cache")
	w.Header().Set("Connection", "keep-alive")
	w.WriteHeader(http.StatusOK)

	// Write Datastar merge fragments event with toast (HTML-escaped to prevent XSS)
	fmt.Fprintf(w, "event: datastar-merge-fragments\n")
	fmt.Fprintf(w, "data: fragments <div id=\"toast-container\"><div class=\"toast toast-error\">%s</div></div>\n\n", html.EscapeString(err.Message))
}

// writeJSONError renders an error as JSON following RFC 9457 problem details shape.
func writeJSONError(w http.ResponseWriter, err *errors.Error) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(err.Status)

	// RFC 9457-compatible shape â€” use json.NewEncoder to safely encode values
	json.NewEncoder(w).Encode(map[string]interface{}{
		"status": err.Status,
		"title":  http.StatusText(err.Status),
		"detail": err.Message,
		"code":   err.Code,
	})
}

// writeHTMLError renders an error as a minimal HTML error page.
func writeHTMLError(w http.ResponseWriter, err *errors.Error) {
	w.Header().Set("Content-Type", "text/html")
	w.WriteHeader(err.Status)

	htmlTmpl := `<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Error %d</title>
	<style>
		body { font-family: sans-serif; max-width: 600px; margin: 100px auto; text-align: center; }
		h1 { color: #333; }
		p { color: #666; }
	</style>
</head>
<body>
	<h1>Error %d</h1>
	<p>%s</p>
</body>
</html>`

	fmt.Fprintf(w, htmlTmpl, err.Status, err.Status, html.EscapeString(err.Message))
}
