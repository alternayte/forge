---
phase: 02-code-generation-engine
plan: 05
type: execute
wave: 3
depends_on: ["02-03"]
files_modified:
  - internal/watcher/watcher.go
  - internal/watcher/dev.go
  - internal/watcher/watcher_test.go
  - internal/cli/dev.go
  - internal/cli/root.go
autonomous: true

must_haves:
  truths:
    - "forge dev starts a development server that watches for file changes and auto-regenerates code"
    - "File changes to .go, .templ, .sql, .css files trigger regeneration after 300ms debounce"
    - "Chmod events are ignored to prevent infinite rebuild loops"
    - "Watcher monitors parent directories (not individual files) to handle atomic writes correctly"
    - "forge dev can be stopped with Ctrl+C (graceful shutdown)"
  artifacts:
    - path: "internal/watcher/watcher.go"
      provides: "fsnotify wrapper with debouncing, extension filtering, and Chmod skipping"
      exports: ["Watcher", "New", "Add", "Close"]
    - path: "internal/watcher/dev.go"
      provides: "Development server orchestration (watch + generate + rebuild)"
      exports: ["DevServer", "Start"]
    - path: "internal/cli/dev.go"
      provides: "forge dev CLI command"
      exports: ["newDevCmd"]
  key_links:
    - from: "internal/watcher/watcher.go"
      to: "github.com/fsnotify/fsnotify"
      via: "Wraps fsnotify.Watcher with debouncing and filtering"
      pattern: "fsnotify\\.NewWatcher"
    - from: "internal/watcher/dev.go"
      to: "internal/generator/generator.go"
      via: "Calls generator.Generate on file changes"
      pattern: "generator\\.Generate"
    - from: "internal/watcher/dev.go"
      to: "internal/parser/parser.go"
      via: "Calls parser.ParseDir to re-parse schemas on change"
      pattern: "parser\\.ParseDir"
    - from: "internal/cli/dev.go"
      to: "internal/watcher/dev.go"
      via: "CLI command starts DevServer"
      pattern: "watcher\\.DevServer|watcher\\.Start"
---

<objective>
Create the forge dev command with file watching, debounced change detection, and automatic code regeneration.

Purpose: forge dev is the developer's main workflow command. It watches for schema and source file changes, automatically re-runs forge generate, and rebuilds the application. This enables the tight feedback loop that makes Forge productive.
Output: internal/watcher/ package with fsnotify-based file watching, and forge dev CLI command that watches resources/ and triggers regeneration.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation-engine/02-RESEARCH.md
@.planning/phases/02-code-generation-engine/02-03-SUMMARY.md
@internal/cli/root.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create watcher package with fsnotify, debouncing, and dev server orchestration</name>
  <files>
    internal/watcher/watcher.go
    internal/watcher/dev.go
    internal/watcher/watcher_test.go
    go.mod
  </files>
  <action>
Create the watcher package following the patterns from the research document.

1. **Add fsnotify dependency**: Run `go get github.com/fsnotify/fsnotify`.

2. **internal/watcher/watcher.go**: Create the fsnotify wrapper with debouncing:

```go
package watcher

type Watcher struct {
    fsw      *fsnotify.Watcher
    onChange func()
    timer    *time.Timer
    debounce time.Duration
    done     chan struct{}
}

func New(onChange func(), debounce time.Duration) (*Watcher, error)
func (w *Watcher) Add(path string) error
func (w *Watcher) Close() error
```

The watch loop (run in goroutine from New):
- Read from fsw.Events channel
- SKIP fsnotify.Chmod events unconditionally (macOS Spotlight, antivirus, editors trigger these constantly -- research pitfall #6)
- Filter events by file extension using isRelevantFile(): only .go, .templ, .sql, .css
- On relevant event: reset debounce timer. If timer already running, stop it first.
- After debounce (default 300ms), call onChange callback
- Handle fsw.Errors by logging (not crashing)
- Close via done channel for graceful shutdown

isRelevantFile(path string) bool:
- Check filepath.Ext(path)
- Return true for .go, .templ, .sql, .css
- Return false for everything else (including temp files like .swp, ~, .tmp)
- Also return false for paths containing "gen/" (don't react to generated file changes, which would cause infinite loops)

3. **internal/watcher/dev.go**: Create DevServer that orchestrates the dev workflow:

```go
type DevServer struct {
    ProjectRoot string
    Config      *config.Config
    watcher     *Watcher
}

func NewDevServer(projectRoot string, cfg *config.Config) *DevServer
func (d *DevServer) Start(ctx context.Context) error
```

Start() should:
a. Run initial `forge generate` (parse + generate) to ensure gen/ is up to date
b. Create watcher with onChange callback that:
   - Prints timestamp + "Change detected, regenerating..." with ui.Info
   - Runs parser.ParseDir on resources/
   - If parse errors, prints them and continues watching (don't crash)
   - If parse succeeds, runs generator.Generate
   - Prints success or error message
c. Add directories to watch:
   - `{projectRoot}/resources/` (schema files)
   - `{projectRoot}/internal/` (application code, if exists)
   - Walk subdirectories recursively since fsnotify doesn't recurse automatically
d. Print startup message:
   ```
     forge dev

     Watching for changes...
       resources/ — schema files (.go)
       internal/  — application code (.go, .templ)

     Press Ctrl+C to stop
   ```
e. Block on ctx.Done() (context cancelled by signal handler)
f. On shutdown: close watcher, print "Shutting down..." with ui.Info

The addRecursive helper should walk a directory tree and add each subdirectory to the watcher. Skip hidden directories (starting with "."), gen/, and node_modules/.

NOTE: For Phase 2, forge dev focuses on schema watching + code regeneration. Hot reload of the running Go server (recompile and restart the binary) will be enhanced in later phases when there's an actual server to restart. For now, after regeneration, print "Run 'go run .' to start your application" as a hint.

4. **internal/watcher/watcher_test.go**: Create tests:
   - TestIsRelevantFile_GoFiles: .go files are relevant
   - TestIsRelevantFile_TemplFiles: .templ files are relevant
   - TestIsRelevantFile_SQLFiles: .sql files are relevant
   - TestIsRelevantFile_CSSFiles: .css files are relevant
   - TestIsRelevantFile_IgnoredExtensions: .txt, .md, .json, .swp, .tmp are ignored
   - TestIsRelevantFile_IgnoreGenDir: paths containing "gen/" are ignored
   - TestNewWatcher_CreatesSuccessfully: Can create watcher without error
   - TestWatcher_Close: Watcher closes cleanly without error

Note: Debounce behavior is timing-dependent and hard to test reliably in unit tests. Test the filter logic and construction, not the timing.
  </action>
  <verify>
Run `go test ./internal/watcher/ -v` -- all tests pass. Run `go build ./internal/watcher/` -- compiles. Run `go vet ./internal/watcher/`.
  </verify>
  <done>
Watcher package exists with fsnotify-based file watching, 300ms debounce, Chmod event filtering, extension filtering (.go/.templ/.sql/.css), gen/ path exclusion, and graceful shutdown. DevServer orchestrates watch + regenerate cycle. All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire forge dev CLI command</name>
  <files>
    internal/cli/dev.go
    internal/cli/root.go
  </files>
  <action>
Create the forge dev command that starts the development server.

1. **internal/cli/dev.go**: Create newDevCmd():

```go
func newDevCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "dev",
        Short: "Start development server with file watching",
        Long: `Starts a development server that watches for file changes in resources/
and internal/ directories. When schema files change, code is automatically
regenerated. Watches .go, .templ, .sql, and .css files.

Ctrl+C to stop.`,
        RunE: runDev,
    }
    return cmd
}
```

The runDev function should:
a. Find project root (forge.toml)
b. Load config
c. Set up signal handling: create context with signal.NotifyContext for SIGINT and SIGTERM
d. Create DevServer with project root and config
e. Call devServer.Start(ctx)
f. On context cancellation (Ctrl+C), print shutdown message and exit cleanly

Signal handling pattern:
```go
ctx, cancel := signal.NotifyContext(context.Background(), os.Interrupt, syscall.SIGTERM)
defer cancel()

server := watcher.NewDevServer(projectRoot, cfg)
if err := server.Start(ctx); err != nil {
    // Only error if not context cancellation
    if ctx.Err() == nil {
        return err
    }
}
```

2. **Update internal/cli/root.go**: Add `rootCmd.AddCommand(newDevCmd())` in init().
  </action>
  <verify>
Run `go build .` -- forge binary compiles with dev command. Run `forge dev --help` -- shows correct description mentioning file watching and Ctrl+C. Run `go vet ./internal/cli/`.

For quick integration check: In an initialized project directory, run `forge dev` and verify:
1. Initial generation runs
2. "Watching for changes..." message appears
3. Ctrl+C cleanly stops the process
  </verify>
  <done>
forge dev command exists, starts DevServer with signal handling for graceful Ctrl+C shutdown. Watches resources/ and internal/ for .go/.templ/.sql/.css changes. Triggers regeneration on change with 300ms debounce. Registered in root CLI. Build compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `go build .` compiles forge binary with dev command
2. `go test ./internal/watcher/ -v` all tests pass
3. `forge dev --help` shows file watching description
4. forge dev watches resources/ and regenerates on schema changes
5. Chmod events are ignored (no infinite rebuild loops)
6. Ctrl+C gracefully stops the watcher
7. gen/ directory paths excluded from triggering regeneration
</verification>

<success_criteria>
- forge dev starts and watches for file changes
- .go, .templ, .sql, .css changes trigger regeneration after 300ms debounce
- Chmod events ignored
- gen/ changes don't trigger regeneration (no infinite loops)
- Ctrl+C cleanly shuts down
- Styled output shows what's being watched
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation-engine/02-05-SUMMARY.md`
</output>
