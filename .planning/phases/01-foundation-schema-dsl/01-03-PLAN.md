---
phase: 01-foundation-schema-dsl
plan: 03
type: tdd
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - internal/parser/parser.go
  - internal/parser/extractor.go
  - internal/parser/validator.go
  - internal/parser/parser_test.go
autonomous: true

must_haves:
  truths:
    - "CLI can parse schema.go files using go/ast without requiring gen/ to exist"
    - "Parser extracts schema.Define() calls, field definitions, modifiers, relationships, and options into IR"
    - "Parser errors with clear message pointing to offending line when schema uses dynamic values"
    - "Parser collects all errors in single pass — developer sees everything at once"
  artifacts:
    - path: "internal/parser/parser.go"
      provides: "Entry point for parsing schema directories and files"
      contains: "func ParseFile(path string) (*ParseResult, error)"
    - path: "internal/parser/extractor.go"
      provides: "AST extraction of schema.Define() calls into IR"
      contains: "func extractSchemaDefinition"
    - path: "internal/parser/validator.go"
      provides: "Validates literal-only values and collects diagnostics"
      contains: "func validateLiteralValues"
    - path: "internal/parser/parser_test.go"
      provides: "TDD tests covering parsing, extraction, and validation"
      contains: "func TestParse"
  key_links:
    - from: "internal/parser/parser.go"
      to: "internal/parser/ir.go"
      via: "Parser produces ResourceIR instances"
      pattern: "ResourceIR\\{"
    - from: "internal/parser/validator.go"
      to: "internal/errors/diagnostic.go"
      via: "Validator creates Diagnostics for invalid schemas"
      pattern: "errors\\.NewDiagnostic"
    - from: "internal/parser/extractor.go"
      to: "go/ast"
      via: "Uses ast.Inspect to walk AST nodes"
      pattern: "ast\\.Inspect"
---

<objective>
Build the go/ast parser that reads schema.go files and extracts resource definitions into the intermediate representation. This is the core technical challenge of Phase 1: solving the bootstrapping constraint by parsing Go source statically.

Purpose: The parser is what makes "schema as source of truth" work — it reads developer-authored schema files using static analysis (not compilation), so schemas can reference gen/ types that don't exist yet.

Output: Working parser that converts schema.go files into ResourceIR structs, with rich error diagnostics for invalid schemas.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-schema-dsl/01-CONTEXT.md
@.planning/phases/01-foundation-schema-dsl/01-RESEARCH.md
@.planning/phases/01-foundation-schema-dsl/01-01-SUMMARY.md
@.planning/phases/01-foundation-schema-dsl/01-02-SUMMARY.md
</context>

<feature>
  <name>Schema AST Parser</name>
  <files>internal/parser/parser.go, internal/parser/extractor.go, internal/parser/validator.go, internal/parser/parser_test.go</files>
  <behavior>
    The parser reads .go files containing schema.Define() calls and produces ResourceIR structs.

    Test cases (RED phase — write these first):

    1. Parse simple resource with string fields:
       Input: `var Post = schema.Define("Post", schema.String("Title").Required(), schema.Text("Body"))`
       Expected: ResourceIR with Name="Post", 2 fields, field[0].Name="Title" with Required modifier

    2. Parse resource with all field types:
       Input: Schema using all 14 field types (UUID, String, Text, Int, BigInt, Decimal, Bool, DateTime, Date, Enum, JSON, Slug, Email, URL)
       Expected: ResourceIR with 14 fields, each with correct Type string

    3. Parse field modifiers with values:
       Input: `schema.String("Title").Required().MaxLen(200).MinLen(3).Default("Untitled").Label("Title").Placeholder("Enter title")`
       Expected: FieldIR with modifiers: Required (no value), MaxLen (value=200), MinLen (value=3), Default (value="Untitled"), Label (value="Title"), Placeholder (value="Enter title")

    4. Parse relationships:
       Input: `schema.BelongsTo("Category", "categories").Optional().OnDelete(schema.SetNull)`
       Expected: RelationshipIR with Name="Category", Type="BelongsTo", Table="categories", Optional=true, OnDelete="SetNull"

    5. Parse resource options and timestamps:
       Input: `schema.Define("Post", schema.SoftDelete(), schema.Auditable(), schema.Timestamps(), schema.String("Title"))`
       Expected: ResourceIR with Options.SoftDelete=true, Options.Auditable=true, HasTimestamps=true, 1 field

    6. Parse Enum with values and default:
       Input: `schema.Enum("Status", "draft", "published", "archived").Default("draft")`
       Expected: FieldIR with Type="Enum", EnumValues=["draft","published","archived"], Default modifier with value="draft"

    7. Reject dynamic values with rich error:
       Input: `var maxLen = 200; schema.String("Title").MaxLen(maxLen)`
       Expected: ParseResult with error containing: code=E001, line number pointing to maxLen usage, hint about using literals

    8. Collect multiple errors in single pass:
       Input: Schema with 2+ errors (e.g., dynamic value AND unsupported call)
       Expected: ParseResult.Errors has 2+ diagnostics, not just first one

    9. Parse multiple resources from directory:
       Input: Directory with 2 schema.go files
       Expected: ParseResult with 2 ResourceIR entries

    10. Handle file with no schema.Define (gracefully skip):
        Input: A .go file that doesn't contain schema.Define()
        Expected: ParseResult with 0 resources, 0 errors
  </behavior>
  <implementation>
    After tests are written and fail (RED), implement:

    `internal/parser/parser.go`:
    - `ParseFile(path string) (*ParseResult, error)` — parse single file using go/parser.ParseFile with ParseComments mode. Use token.NewFileSet for position tracking.
    - `ParseDir(dir string) (*ParseResult, error)` — find all schema.go files in subdirectories under the given path (resources/*/schema.go pattern), parse each, merge results.
    - Read source file content for error diagnostics (to show source lines in errors).

    `internal/parser/extractor.go`:
    - `extractResources(fset *token.FileSet, file *ast.File, source []byte) ([]ResourceIR, []Diagnostic)` — walk AST with ast.Inspect, find package-level var declarations assigned to schema.Define() calls.
    - `extractSchemaDefinition(fset *token.FileSet, call *ast.CallExpr, source []byte) (*ResourceIR, []Diagnostic)` — extract name (first arg, must be string literal), then iterate remaining args extracting fields/relationships/options.
    - `extractField(fset *token.FileSet, call *ast.CallExpr, source []byte) (*FieldIR, []Diagnostic)` — extract field type from function name (String, UUID, etc.), name from first arg, then walk chained method calls to extract modifiers.
    - `extractRelationship(fset *token.FileSet, call *ast.CallExpr, source []byte) (*RelationshipIR, []Diagnostic)` — extract relationship type, name, table, then walk chained methods for Optional/OnDelete.
    - `extractModifiers(fset *token.FileSet, chain []*ast.CallExpr, source []byte) ([]ModifierIR, []Diagnostic)` — walk method chain extracting modifier name and value from each call.

    Key implementation details:
    - Method chains in AST are nested CallExprs: `a.B().C()` is `CallExpr{Fun: SelectorExpr{X: CallExpr{Fun: SelectorExpr{X: a, Sel: B}}, Sel: C}}`. Walk from outer to inner to extract chain.
    - Use strconv.Unquote() for string literals (BasicLit values include quotes — see RESEARCH.md pitfall 2).
    - For integer literals, use strconv.Atoi on BasicLit.Value.
    - Detect field type from function name: if SelectorExpr.Sel.Name is in ["String", "UUID", "Text", "Int", "BigInt", "Decimal", "Bool", "DateTime", "Date", "Enum", "JSON", "Slug", "Email", "URL"], it's a field constructor.
    - Detect relationship from function name: "BelongsTo", "HasMany", "HasOne", "ManyToMany".
    - Detect options: "SoftDelete", "Auditable", "TenantScoped", "Searchable", "Timestamps".

    `internal/parser/validator.go`:
    - `validateLiteralValues(fset *token.FileSet, call *ast.CallExpr, source []byte) []Diagnostic` — check that all arguments to schema function calls are BasicLit (string/int/bool literals) or schema.X selector expressions (like schema.SetNull, schema.Cascade). If an argument is an ast.Ident (variable reference) or other non-literal expression, create a Diagnostic with code E001.
    - For each validation error, extract the source line from the file content, calculate underline position, and create a Diagnostic with hint explaining the static analysis constraint.
    - Collect ALL validation errors (don't return on first error).

    Per user decision: collect all errors in a single parse pass — developer fixes everything at once, no cascading noise.
  </implementation>
</feature>

<verification>
- `go test ./internal/parser/ -v` — all 10+ test cases pass
- Parser handles the full Product schema example from CONTEXT.md
- Dynamic value rejection produces Diagnostic with correct line number, error code, and helpful hint
- Multiple errors are collected in single pass
- Files without schema.Define() are gracefully skipped
</verification>

<success_criteria>
`ParseDir("resources/")` reads schema.go files from resource subdirectories, extracts all schema.Define() calls into ResourceIR structs with fields, modifiers, relationships, and options correctly populated. Invalid schemas produce rich Diagnostic errors with file:line positions and fix suggestions. All errors collected in single pass.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-schema-dsl/01-03-SUMMARY.md`
</output>
