// Code generated by forge generate. DO NOT EDIT.

package queries

import (
	"fmt"

	"{{.ProjectModule}}/gen/models"
	{{- if .Options.TenantScoped}}
	"context"
	forgeauth "github.com/alternayte/forge/forge/auth"
	{{- end}}
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
)

{{- $resource := .Name}}

// {{$resource}}Filters provides type-safe filter methods for {{$resource}} queries.
type {{$resource}}Filters struct{}

{{- range .Fields}}
{{- if isFilterable .Modifiers}}

// {{.Name}}EQ returns a query mod for filtering by {{.Name}} equals.
func (f {{$resource}}Filters) {{.Name}}EQ(val {{goType .Type}}) bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("{{snake .Name}}").EQ(psql.Arg(val)))
}

// {{.Name}}NEQ returns a query mod for filtering by {{.Name}} not equals.
func (f {{$resource}}Filters) {{.Name}}NEQ(val {{goType .Type}}) bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("{{snake .Name}}").NE(psql.Arg(val)))
}

{{- if or (eq .Type "Int") (eq .Type "BigInt") (eq .Type "Decimal") (eq .Type "DateTime") (eq .Type "Date")}}

// {{.Name}}GTE returns a query mod for filtering by {{.Name}} greater than or equal.
func (f {{$resource}}Filters) {{.Name}}GTE(val {{goType .Type}}) bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("{{snake .Name}}").GTE(psql.Arg(val)))
}

// {{.Name}}LTE returns a query mod for filtering by {{.Name}} less than or equal.
func (f {{$resource}}Filters) {{.Name}}LTE(val {{goType .Type}}) bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("{{snake .Name}}").LTE(psql.Arg(val)))
}
{{- end}}

{{- if or (eq .Type "String") (eq .Type "Text") (eq .Type "Email") (eq .Type "URL") (eq .Type "Slug")}}

// {{.Name}}Contains returns a query mod for filtering by {{.Name}} contains (case-insensitive).
func (f {{$resource}}Filters) {{.Name}}Contains(val string) bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("{{snake .Name}}").ILike(psql.Arg("%" + val + "%")))
}
{{- end}}
{{- end}}
{{- end}}

// {{$resource}}FilterMods converts a {{$resource}}Filter to a slice of Bob query mods.
func {{$resource}}FilterMods(filter models.{{$resource}}Filter) []bob.Mod[*dialect.SelectQuery] {
	var mods []bob.Mod[*dialect.SelectQuery]

	{{- range .Fields}}
	{{- if isFilterable .Modifiers}}
	if filter.{{.Name}} != nil {
		mods = append(mods, ({{$resource}}Filters{}).{{.Name}}EQ(*filter.{{.Name}}))
	}
	if filter.{{.Name}}Neq != nil {
		mods = append(mods, ({{$resource}}Filters{}).{{.Name}}NEQ(*filter.{{.Name}}Neq))
	}
	{{- end}}
	{{- end}}

	return mods
}

// {{$resource}}SortMod converts a {{$resource}}Sort to a Bob query mod.
// Returns an error if the sort field is not a recognized sortable column.
func {{$resource}}SortMod(sort models.{{$resource}}Sort) (bob.Mod[*dialect.SelectQuery], error) {
	var columnName string

	// Map field name to column name
	switch sort.Field {
	{{- range .Fields}}
	{{- if isSortable .Modifiers}}
	case "{{.Name}}", "{{snake .Name}}":
		columnName = "{{snake .Name}}"
	{{- end}}
	{{- end}}
	case "":
		// No sort field specified â€” return no-op mod
		return bob.ModFunc[*dialect.SelectQuery](func(q *dialect.SelectQuery) {}), nil
	default:
		return nil, fmt.Errorf("invalid sort field: %q", sort.Field)
	}

	// Build order by mod
	orderBy := sm.OrderBy(psql.Quote(columnName))
	if sort.Direction == "desc" {
		return orderBy.Desc(), nil
	}
	return orderBy.Asc(), nil
}
{{- if .Options.SoftDelete}}

// ActiveMod returns a query mod that excludes soft-deleted records.
// Applied by default to List and Get queries.
func (f {{$resource}}Filters) ActiveMod() bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("deleted_at").IsNull())
}

// OnlyTrashedMod returns a query mod that shows only soft-deleted records.
func (f {{$resource}}Filters) OnlyTrashedMod() bob.Mod[*dialect.SelectQuery] {
	return sm.Where(psql.Quote("deleted_at").IsNotNull())
}
{{- end}}
{{- if .Options.TenantScoped}}

// TenantMod scopes the query to the current tenant from context.
// Returns an error if tenant ID is not in context.
func (f {{$resource}}Filters) TenantMod(ctx context.Context) (bob.Mod[*dialect.SelectQuery], error) {
	tenantID, ok := forgeauth.TenantFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("{{$resource}}: tenant ID required in context")
	}
	return sm.Where(psql.Quote("tenant_id").EQ(psql.Arg(tenantID))), nil
}
{{- end}}
