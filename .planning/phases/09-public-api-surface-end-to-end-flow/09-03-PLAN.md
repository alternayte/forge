---
phase: 09-public-api-surface-end-to-end-flow
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - forge/forge.go
  - forge/errors.go
  - forge/transaction.go
  - forge/config.go
  - internal/config/config.go
autonomous: true
requirements: []

must_haves:
  truths:
    - "forge.New(cfg) creates an App instance"
    - "forge.App has RegisterAPIRoutes(func(huma.API)) and RegisterHTMLRoutes(func(chi.Router)) methods"
    - "forge.App.Listen(addr) starts the HTTP server and blocks until shutdown"
    - "forge.LoadConfig(path) loads forge.toml and returns a Config"
    - "forge.Error struct is defined with Status, Code, Message, Detail, Err fields (matching generated errors.go.tmpl)"
    - "forge.Transaction wraps pgx transactions"
    - "config.Config struct has API APIConfig field (added to internal/config/config.go)"
    - "go build ./... compiles with the new forge package"
  artifacts:
    - path: "forge/forge.go"
      provides: "App builder type"
      contains: "func New"
    - path: "forge/errors.go"
      provides: "forge.Error type"
      contains: "type Error struct"
    - path: "forge/transaction.go"
      provides: "Transaction wrapper"
      contains: "type Transaction struct"
    - path: "forge/config.go"
      provides: "Config and LoadConfig"
      contains: "func LoadConfig"
  key_links:
    - from: "forge/forge.go"
      to: "internal/api/server.go"
      via: "import internal/api for SetupAPI and SetupHTML"
      pattern: "api\\.SetupAPI"
    - from: "forge/config.go"
      to: "internal/config/config.go"
      via: "wraps internal config loading"
      pattern: "config\\.Load"
    - from: "forge/forge.go"
      to: "forge/auth/"
      via: "session manager setup"
      pattern: "auth\\.NewSessionManager"
---

<objective>
Create the public forge package at the repo root with runtime types: App builder, Error, Transaction, and Config loader.

Purpose: This is the "what you call" half of the two-package mental model (schema is what you write, forge is what you call). forge.App manages the application lifecycle — DB pool, session manager, HTTP server, graceful shutdown. Generated main.go calls forge.New(cfg).RegisterAPIRoutes(...).Listen(":8080").

Output: Four new files in forge/ providing the complete runtime API for generated applications.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-RESEARCH.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-01-SUMMARY.md
@internal/api/server.go
@internal/api/html_server.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forge.App builder and Config loader</name>
  <files>
    forge/forge.go
    forge/config.go
  </files>
  <action>
Create the core App builder and Config types in the public forge package.

**forge/config.go** — Config loader that wraps internal/config:

```go
package forge

import (
    "github.com/alternayte/forge/internal/config"
)

// Config is the runtime configuration for a forge application.
// Load from forge.toml with LoadConfig, or construct programmatically for testing.
type Config struct {
    cfg *config.Config
}

// LoadConfig reads forge.toml from the given path and returns a Config.
// Environment variable overrides (FORGE_*) are applied automatically.
func LoadConfig(path string) (Config, error) {
    cfg, err := config.Load(path)
    if err != nil {
        return Config{}, err
    }
    return Config{cfg: cfg}, nil
}

// DatabaseURL returns the configured database connection string.
func (c Config) DatabaseURL() string {
    return c.cfg.Database.URL
}

// ServerAddr returns the configured host:port for the HTTP server.
func (c Config) ServerAddr() string {
    return fmt.Sprintf("%s:%d", c.cfg.Server.Host, c.cfg.Server.Port)
}
```

**forge/forge.go** — App builder pattern:

```go
package forge

import (
    "context"
    "fmt"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "syscall"

    "github.com/alexedwards/scs/pgxstore"
    "github.com/danielgtaylor/huma/v2"
    "github.com/go-chi/chi/v5"
    "github.com/jackc/pgx/v5/pgxpool"

    "github.com/alternayte/forge/forge/auth"
    internalapi "github.com/alternayte/forge/internal/api"
    "github.com/alternayte/forge/internal/config"
)

// App is the forge application lifecycle manager.
// Create with New(), configure with builder methods, start with Listen().
type App struct {
    cfg            *config.Config
    router         chi.Router
    pool           *pgxpool.Pool
    apiRoutesFn    func(huma.API)
    htmlRoutesFn   func(chi.Router)
    recoveryMw     func(http.Handler) http.Handler
    tokenStore     auth.TokenStore
    apiKeyStore    auth.APIKeyStore
}

// New creates a new App from configuration loaded via LoadConfig.
func New(cfg Config) *App {
    return &App{
        cfg:    cfg.cfg,
        router: chi.NewRouter(),
    }
}

// RegisterAPIRoutes sets the function that registers all API routes on the Huma API.
// The function receives a huma.API and should call genapi.RegisterAllRoutes(api, registry).
func (a *App) RegisterAPIRoutes(fn func(huma.API)) *App {
    a.apiRoutesFn = fn
    return a
}

// RegisterHTMLRoutes sets the function that registers all HTML routes on a chi.Router.
// The function receives a session-protected chi.Router group.
func (a *App) RegisterHTMLRoutes(fn func(chi.Router)) *App {
    a.htmlRoutesFn = fn
    return a
}

// UseRecovery sets a custom panic recovery middleware. If not called,
// a default recovery middleware is used.
func (a *App) UseRecovery(mw func(http.Handler) http.Handler) *App {
    a.recoveryMw = mw
    return a
}

// UseTokenStore sets the bearer token store for API authentication.
func (a *App) UseTokenStore(ts auth.TokenStore) *App {
    a.tokenStore = ts
    return a
}

// UseAPIKeyStore sets the API key store for API authentication.
func (a *App) UseAPIKeyStore(ks auth.APIKeyStore) *App {
    a.apiKeyStore = ks
    return a
}

// Listen starts the HTTP server and blocks until SIGTERM/SIGINT.
// On shutdown: stops accepting connections, drains in-flight requests,
// closes the DB pool.
func (a *App) Listen(addr string) error {
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    // Connect to database
    pool, err := pgxpool.New(ctx, a.cfg.Database.URL)
    if err != nil {
        return fmt.Errorf("forge: connect to database: %w", err)
    }
    defer pool.Close()
    a.pool = pool

    // Set up session manager
    sm := auth.NewSessionManager(pool, a.cfg.Server.Host == "localhost")
    store := pgxstore.New(pool)
    sm.Store = store

    // Recovery middleware fallback
    recoveryMw := a.recoveryMw
    if recoveryMw == nil {
        recoveryMw = func(next http.Handler) http.Handler { return next }
    }

    // Wire API routes
    if a.apiRoutesFn != nil {
        _, err := internalapi.SetupAPI(
            a.router,
            a.cfg.API,
            a.tokenStore,
            a.apiKeyStore,
            recoveryMw,
            a.apiRoutesFn,
        )
        if err != nil {
            return fmt.Errorf("forge: setup API: %w", err)
        }
    }

    // Wire HTML routes
    if a.htmlRoutesFn != nil {
        err := internalapi.SetupHTML(a.router, internalapi.HTMLServerConfig{
            SessionManager: sm,
            RegisterRoutes: a.htmlRoutesFn,
        })
        if err != nil {
            return fmt.Errorf("forge: setup HTML: %w", err)
        }
    }

    // Start HTTP server
    srv := &http.Server{
        Addr:    addr,
        Handler: a.router,
    }

    // Graceful shutdown goroutine
    go func() {
        <-ctx.Done()
        slog.Info("forge: shutting down...")
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        srv.Shutdown(shutdownCtx)
    }()

    slog.Info("forge: listening", "addr", addr)
    if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return fmt.Errorf("forge: server error: %w", err)
    }

    return nil
}

// Pool returns the database connection pool.
// Only valid after Listen() has been called (for test infrastructure, use forge/forgetest).
func (a *App) Pool() *pgxpool.Pool {
    return a.pool
}
```

IMPORTANT IMPLEMENTATION NOTES (from real codebase audit):

1. **config.Config has NO `API` field.** The `APIConfig` type is defined in `internal/config/api.go` but is NOT embedded in `config.Config`. The `Config` struct has: Project, Database, Tools, Server, Session, Jobs, SSE, Observe, Admin. To get an `APIConfig` for `SetupAPI`, use `config.DefaultAPIConfig()` — or add an `API APIConfig` field to the `Config` struct in `internal/config/config.go` and wire it in `config.Load()`. **Chosen approach: Add `API APIConfig` field to `config.Config`** with toml tag `toml:"api"` so forge.toml can configure it, and update `config.Default()` to include `DefaultAPIConfig()`. This is a one-line addition to the struct and one-line to Default(). Then `a.cfg.API` works correctly in Listen().

2. **`internal/api.SetupAPI` signature** takes `(chi.Router, config.APIConfig, auth.TokenStore, auth.APIKeyStore, func(http.Handler) http.Handler, func(huma.API))`. The last parameter `registerRoutes` is `func(api huma.API)` — it accepts ONLY `huma.API`, not `(huma.API, *actions.Registry)`. This is because the generated `RegisterAllRoutes(api, registry)` is NOT called directly — the main.go creates a closure that captures the registry: `func(api huma.API) { genapi.RegisterAllRoutes(api, registry) }`. The forge.App's `apiRoutesFn func(huma.API)` matches SetupAPI's last parameter. This is correct as-is.

3. The `forge` package CAN import `internal/api` and `internal/config` (same module).
4. The `forge` package MUST NOT expose internal types in its public API.
5. Use callback functions (func(huma.API), func(chi.Router)) for route registration.

**File changes required by this task beyond forge/ files:**
- `internal/config/config.go`: Add `API APIConfig \`toml:"api"\`` field to Config struct, and add `API: DefaultAPIConfig(),` to Default() function.
  </action>
  <verify>
    - `go build ./forge/...` compiles
    - `grep "func New" forge/forge.go` finds the constructor
    - `grep "func LoadConfig" forge/config.go` finds the loader
    - `grep "func.*Listen" forge/forge.go` finds the listener
  </verify>
  <done>forge.App builder exists with New(), RegisterAPIRoutes(), RegisterHTMLRoutes(), and Listen(). forge.LoadConfig() loads forge.toml.</done>
</task>

<task type="auto">
  <name>Task 2: Create forge.Error and forge.Transaction types</name>
  <files>
    forge/errors.go
    forge/transaction.go
  </files>
  <action>
Create the public error and transaction types. These are currently generated into gen/ directories per-project. The public `forge` package provides the canonical type definitions that generated code can reference.

**forge/errors.go** — Error type matching the generated errors pattern:

```go
package forge

import "fmt"

// Error represents a structured application error with HTTP status code mapping.
// Both API (JSON) and HTML (SSE) handlers use this type for consistent error responses.
type Error struct {
    // Status is the HTTP status code (e.g. 400, 404, 500).
    Status int

    // Code is a machine-readable error code (e.g. "not_found", "validation_error").
    Code string

    // Message is a human-readable error summary.
    Message string

    // Detail provides additional context for debugging (may be empty).
    Detail string

    // Err is the underlying error, if any.
    Err error
}

// Error implements the error interface.
func (e *Error) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

// Unwrap returns the wrapped error for errors.Is/errors.As compatibility.
func (e *Error) Unwrap() error {
    return e.Err
}

// GetStatus returns the HTTP status code.
func (e *Error) GetStatus() int {
    return e.Status
}

// NotFound returns a 404 error for a missing resource.
func NotFound(resource string, id any) *Error {
    return &Error{
        Status:  404,
        Code:    "resource_not_found",
        Message: fmt.Sprintf("%s not found", resource),
        Detail:  fmt.Sprintf("ID: %v", id),
    }
}

// Unauthorized returns a 401 error for authentication failures.
func Unauthorized(message string) *Error {
    return &Error{
        Status:  401,
        Code:    "unauthorized",
        Message: message,
    }
}

// Forbidden returns a 403 error for authorization failures.
func Forbidden(message string) *Error {
    return &Error{
        Status:  403,
        Code:    "forbidden",
        Message: message,
    }
}

// BadRequest returns a 400 error for invalid requests.
func BadRequest(message string) *Error {
    return &Error{
        Status:  400,
        Code:    "bad_request",
        Message: message,
    }
}

// InternalError returns a 500 error wrapping an unexpected error.
func InternalError(err error) *Error {
    return &Error{
        Status:  500,
        Code:    "internal_error",
        Message: "An unexpected error occurred",
        Err:     err,
    }
}
```

IMPORTANT: This matches the exact struct and methods from `internal/generator/templates/errors.go.tmpl`. The `Error()` method uses `fmt.Sprintf("%s: %v", e.Message, e.Err)` (not Code: Message) to match the generated template. The convenience constructors (NotFound, Unauthorized, etc.) replicate the generated pattern.

**DO NOT** include `RenderError`, `TenantFromContext`, or any imports of `http`, `context`, `uuid`, or `forge/auth` in this file. Users who need `TenantFromContext` import `forge/auth` directly. This avoids unnecessary dependencies and eliminates any import cycle risk.

**Note on pgxstore session store wiring:** The `forge/forge.go` `Listen()` method creates `auth.NewSessionManager(pool, ...)` and then sets `sm.Store = pgxstore.New(pool)`. Verify that `auth.NewSessionManager` does NOT already set a pgxstore internally. Read `internal/auth/session.go` to check. If `NewSessionManager` already creates a pgxstore, remove the duplicate `sm.Store = pgxstore.New(pool)` line from Listen(). If not, the explicit store assignment is correct.

**forge/transaction.go** — Transaction wrapper:

```go
package forge

import (
    "context"

    "github.com/jackc/pgx/v5"
    "github.com/jackc/pgx/v5/pgxpool"
)

// Transaction wraps a database transaction with convenience methods.
type Transaction struct {
    tx   pgx.Tx
    pool *pgxpool.Pool
}

// RunInTransaction executes fn within a database transaction.
// If fn returns an error, the transaction is rolled back.
// If fn succeeds, the transaction is committed.
func RunInTransaction(ctx context.Context, pool *pgxpool.Pool, fn func(tx pgx.Tx) error) error {
    tx, err := pool.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    if err := fn(tx); err != nil {
        return err
    }

    return tx.Commit(ctx)
}
```

NOTE: Check `internal/generator/templates/transaction.go.tmpl` for the exact API shape. Replicate the same patterns so generated code can reference `forge.Transaction` or `forge.RunInTransaction`.

IMPORTANT: Only include imports that are actually used. If uuid or auth or http are needed, import them; if not, omit. Compile with `go build ./forge/...` to verify.
  </action>
  <verify>
    - `go build ./forge/...` compiles
    - `grep "type Error struct" forge/errors.go` finds the type
    - `grep "RunInTransaction\|type Transaction" forge/transaction.go` finds the transaction API
    - `go vet ./forge/...` passes
  </verify>
  <done>forge.Error and forge.Transaction are defined as public types. The forge package compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `go build ./forge/...` passes
2. `go vet ./forge/...` passes
3. `grep "func New" forge/forge.go` — constructor exists
4. `grep "func.*Listen" forge/forge.go` — server startup exists
5. `grep "type Error struct" forge/errors.go` — error type exists
6. `grep "type Config struct\|func LoadConfig" forge/config.go` — config exists
</verification>

<success_criteria>
- forge.New(cfg) creates an App
- forge.App has RegisterAPIRoutes, RegisterHTMLRoutes, UseRecovery, and Listen methods
- forge.LoadConfig loads forge.toml
- forge.Error struct matches the pattern used by generated code
- forge.RunInTransaction or Transaction type exists
- All code compiles
</success_criteria>

<output>
After completion, create `.planning/phases/09-public-api-surface-end-to-end-flow/09-03-SUMMARY.md`
</output>
