---
phase: 02-code-generation-engine
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/cli/generate.go
  - internal/cli/root.go
autonomous: true

must_haves:
  truths:
    - "Developer runs forge generate and gen/models/, gen/atlas/, gen/factories/ directories are created with generated files"
    - "forge generate parses schema files from resources/ directory, transforms to IR, and runs all generators"
    - "forge generate does NOT overwrite or modify files in resources/ directory"
    - "forge generate output shows success with file counts using styled terminal output"
    - "If schema parsing fails, forge generate shows all errors at once with file:line positions"
  artifacts:
    - path: "internal/cli/generate.go"
      provides: "forge generate CLI command"
      exports: ["newGenerateCmd"]
  key_links:
    - from: "internal/cli/generate.go"
      to: "internal/parser/parser.go"
      via: "Calls parser.ParseDir to parse schema files"
      pattern: "parser\\.ParseDir"
    - from: "internal/cli/generate.go"
      to: "internal/generator/generator.go"
      via: "Calls generator.Generate with parsed ResourceIR"
      pattern: "generator\\.Generate"
    - from: "internal/cli/generate.go"
      to: "internal/config/config.go"
      via: "Reads forge.toml for project module path"
      pattern: "config\\.Load"
    - from: "internal/cli/root.go"
      to: "internal/cli/generate.go"
      via: "Registers generate command on root"
      pattern: "newGenerateCmd"
---

<objective>
Create the forge generate CLI command that wires the parser and generator together into a complete code generation pipeline.

Purpose: This is the user-facing command that developers will run most frequently. It reads schema definitions, runs all generators, and produces the gen/ output directory. The command is the glue between Phase 1's parser and Phase 2's generators.
Output: `forge generate` command that parses resources/, runs model/atlas/factory generators, and writes to gen/.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation-engine/02-01-SUMMARY.md
@internal/cli/root.go
@internal/cli/init.go
@internal/parser/parser.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forge generate command with parser-generator pipeline</name>
  <files>
    internal/cli/generate.go
    internal/cli/root.go
  </files>
  <action>
Create the forge generate command that orchestrates the full code generation pipeline.

1. **internal/cli/generate.go**: Create newGenerateCmd() following the exact pattern from init.go and tool_sync.go:

```go
func newGenerateCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "generate",
        Short: "Generate code from resource schemas",
        Long:  `Parses schema definitions from resources/ and generates Go models, Atlas HCL schemas, and test factories into gen/.`,
        RunE:  runGenerate,
    }
    return cmd
}
```

The `runGenerate` function should:

a. **Find project root** by looking for forge.toml (reuse or extract the findProjectRoot pattern from tool_sync.go). If forge.toml not found, error with "not a forge project (forge.toml not found). Run 'forge init' first."

b. **Load config** from forge.toml using config.Load(). Extract project module path (config.Project.Module). If module is empty, error with helpful message.

c. **Parse schemas** by calling parser.ParseDir(filepath.Join(projectRoot, "resources")).
   - If err != nil (filesystem error), print error and exit
   - If result.Errors is non-empty, format each error using the diagnostic formatter (if it's a Diagnostic) or fmt.Println, then exit with os.Exit(1)
   - If result.Resources is empty, print info message: "No schema definitions found in resources/. Create a schema file first."

d. **Clean gen/ directory** before generating. Remove existing gen/ directory entirely (os.RemoveAll), then recreate. This ensures stale files from removed resources don't persist. NEVER touch resources/ -- only gen/.

e. **Run generators** by calling generator.Generate(result.Resources, generator.GenerateConfig{OutputDir: filepath.Join(projectRoot, "gen"), ProjectModule: config.Project.Module}).
   - If error, print formatted error and exit

f. **Print success output** using ui styles:
   ```
     Generating code...

     ✓ gen/models/ — 3 model files
     ✓ gen/atlas/schema.hcl — database schema
     ✓ gen/factories/ — 3 factory files

     Generated 3 resources in 45ms
   ```
   Use ui.Success(), ui.Info(), ui.Grouped() for consistent formatting.
   Track timing with time.Now()/time.Since() for the duration.
   Count files generated per directory for the summary.

g. **GEN-11 protection**: The command MUST NOT read from, write to, or modify anything in resources/. It only reads schema files via parser.ParseDir (read-only). All writes go to gen/. This is enforced by the generator's outputDir being gen/, not resources/.

2. **Update internal/cli/root.go**: Add `rootCmd.AddCommand(newGenerateCmd())` in the init() function, alongside the existing init, version, and tool commands.
  </action>
  <verify>
Run `go build .` -- forge binary compiles. Run `./forge generate --help` -- shows generate command help text. Run `go vet ./internal/cli/`.

For integration testing: Create a temp directory, run `forge init test-project`, then cd into it and run `forge generate`. Verify:
1. gen/models/ directory exists with model files
2. gen/atlas/schema.hcl exists
3. gen/factories/ directory exists with factory files
4. resources/ directory is untouched (only the original schema.go)
5. Output shows success messages with file counts
  </verify>
  <done>
forge generate command exists, parses resources/ schemas via parser.ParseDir, runs all generators to gen/, shows styled success output with file counts and timing. resources/ directory is never modified. Build compiles cleanly. Command registered in root CLI.
  </done>
</task>

</tasks>

<verification>
1. `go build .` compiles forge binary with generate command
2. `forge generate --help` shows correct usage text
3. `forge generate` in an initialized project produces gen/models/, gen/atlas/, gen/factories/
4. `forge generate` with schema errors shows all errors with file:line positions
5. `forge generate` does not touch resources/ directory
6. Output is styled with icons and timing information
</verification>

<success_criteria>
- forge generate command parses schemas, runs all generators, writes to gen/
- Schema parse errors displayed with rich diagnostics
- resources/ directory never modified
- Styled output shows what was generated
- Command registered in CLI and accessible via forge generate
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation-engine/02-03-SUMMARY.md`
</output>
