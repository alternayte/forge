---
phase: 04-action-layer-error-handling
plan: 03
type: execute
wave: 3
depends_on: ["04-01", "04-02"]
files_modified:
  - internal/generator/middleware.go
  - internal/generator/middleware_test.go
  - internal/generator/templates/middleware_recovery.go.tmpl
  - internal/generator/templates/middleware_errors.go.tmpl
  - internal/generator/generator.go
  - internal/generator/generator_test.go
autonomous: true

must_haves:
  truths:
    - "Panic recovery middleware catches panics, logs stack traces, and returns 500 errors without exposing internals"
    - "HTML errors render as SSE fragment (toast) when Accept header is text/event-stream, or error page otherwise"
    - "API errors carry forge.Error status and code for Huma RFC 9457 rendering in Phase 5"
    - "forge generate produces all Phase 4 artifacts (gen/errors/, gen/actions/, gen/middleware/)"
  artifacts:
    - path: "internal/generator/middleware.go"
      provides: "Middleware code generation function"
      exports: ["GenerateMiddleware"]
    - path: "internal/generator/templates/middleware_recovery.go.tmpl"
      provides: "Panic recovery middleware using defer/recover with slog logging"
      contains: "func Recovery"
    - path: "internal/generator/templates/middleware_errors.go.tmpl"
      provides: "Error rendering helpers (SSE fragment, HTML error page, JSON error response)"
      contains: "func ErrorResponder"
    - path: "internal/generator/generator.go"
      provides: "Updated Generate() orchestrator calling all 11 generators"
      contains: "GenerateErrors"
  key_links:
    - from: "gen/middleware/recovery.go (generated)"
      to: "gen/errors/"
      via: "Recovery creates errors.InternalError on panic"
      pattern: "errors\\.InternalError"
    - from: "gen/middleware/errors.go (generated)"
      to: "gen/errors/"
      via: "ErrorResponder inspects forge.Error for status/message"
      pattern: "errors\\.Error"
    - from: "internal/generator/generator.go"
      to: "GenerateErrors, GenerateActions, GenerateMiddleware"
      via: "Generate() calls all new generators"
      pattern: "GenerateErrors|GenerateActions|GenerateMiddleware"
---

<objective>
Generate panic recovery middleware and error rendering utilities, then wire all Phase 4 generators into the forge generate orchestrator.

Purpose: Completes the Phase 4 error handling story with panic recovery (ERR-04), context-aware error rendering for SSE/HTML/API (ERR-02, ERR-03), and ensures all new generators run during `forge generate`. The middleware prevents panics from crashing the server and renders errors appropriately based on request context.

Output: Generator functions and templates that produce `gen/middleware/recovery.go` and `gen/middleware/errors.go`, plus updated orchestrator calling all Phase 4 generators.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-action-layer-error-handling/04-RESEARCH.md
@.planning/phases/04-action-layer-error-handling/04-01-SUMMARY.md
@.planning/phases/04-action-layer-error-handling/04-02-SUMMARY.md
@internal/generator/generator.go
@internal/generator/funcmap.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create middleware templates for panic recovery and error rendering</name>
  <files>
    internal/generator/templates/middleware_recovery.go.tmpl
    internal/generator/templates/middleware_errors.go.tmpl
  </files>
  <action>
Create two Go templates in internal/generator/templates/:

1. `middleware_recovery.go.tmpl` - Generates `gen/middleware/recovery.go`:
   - Package `middleware` with DO NOT EDIT header
   - `func Recovery(next http.Handler) http.Handler` that:
     - Returns http.HandlerFunc wrapping next.ServeHTTP in defer/recover
     - On panic: logs with `slog.Error("panic recovered", "error", rvr, "stack", string(debug.Stack()), "method", r.Method, "path", r.URL.Path)`
     - Creates `*errors.Error` with Status 500, Code "internal_error", Message "An unexpected error occurred", empty Detail (never expose panic details)
     - Calls `ErrorResponder(w, r, err)` to render the error appropriately for the request context
   - Imports: "log/slog", "net/http", "runtime/debug", "{{.ProjectModule}}/gen/errors"

2. `middleware_errors.go.tmpl` - Generates `gen/middleware/errors.go`:
   - Package `middleware` with DO NOT EDIT header
   - `func ErrorResponder(w http.ResponseWriter, r *http.Request, err error)` that:
     - Extracts forge.Error from err using `errors.As(err, &forgeErr)`. If not a forge.Error, wraps with `errors.InternalError(err)`
     - Checks request context to determine response format:
       a. If `r.Header.Get("Accept") == "text/event-stream"` -> call writeSSEError(w, forgeErr)
       b. If `r.Header.Get("Accept") == "application/json"` OR path starts with "/api/" -> call writeJSONError(w, forgeErr)
       c. Otherwise -> call writeHTMLError(w, forgeErr)

   - `func writeSSEError(w http.ResponseWriter, err *errors.Error)`:
     - Set Content-Type: text/event-stream, Cache-Control: no-cache, Connection: keep-alive
     - Write status 200 (SSE always uses 200)
     - Write SSE event: `event: datastar-merge-fragments\ndata: fragments <div id="toast-container"><div class="toast toast-error">%s</div></div>\n\n` with err.Message
     - Note: Use datastar-merge-fragments event name (from Datastar SDK)

   - `func writeJSONError(w http.ResponseWriter, err *errors.Error)`:
     - Set Content-Type: application/json
     - Write err.Status as HTTP status code
     - Write JSON body: `{"status": N, "title": "StatusText", "detail": "message", "code": "code"}` using fmt.Fprintf (avoid json.Marshal dependency since this is simple enough)
     - This provides RFC 9457-compatible shape that Huma will enhance in Phase 5

   - `func writeHTMLError(w http.ResponseWriter, err *errors.Error)`:
     - Set Content-Type: text/html
     - Write err.Status as HTTP status code
     - Write a minimal HTML error page with status code and message
     - Use fmt.Fprintf with a simple HTML template string (no templ dependency yet -- that comes in Phase 6)

   - Imports: "errors" (stdlib, aliased as stderrors to avoid conflict), "fmt", "net/http", "{{.ProjectModule}}/gen/errors"

   IMPORTANT: The stdlib "errors" import conflicts with the gen/errors import path. Solutions:
   - Import gen/errors as `forgeerrors "{{.ProjectModule}}/gen/errors"` and stdlib as `"errors"`
   - OR import gen/errors as the default and use `stderrors "errors"` for stdlib
   - Use the second approach: `stderrors "errors"` for stdlib, unqualified for gen/errors. This reads more naturally since most references will be to forge errors.

   Template data: `struct{ ProjectModule string }` (same as actions_types.go.tmpl)
  </action>
  <verify>
Read both template files and confirm:
- middleware_recovery.go.tmpl contains Recovery function with defer/recover, slog.Error with stack trace, ErrorResponder call
- middleware_errors.go.tmpl contains ErrorResponder with Accept header checks for SSE/JSON/HTML
- middleware_errors.go.tmpl contains writeSSEError with 200 status and datastar event format
- middleware_errors.go.tmpl contains writeJSONError with RFC 9457 shape
- middleware_errors.go.tmpl contains writeHTMLError with minimal error page
- Import alias strategy handles stdlib errors vs gen/errors conflict
  </verify>
  <done>Both middleware template files exist with correct panic recovery and context-aware error rendering logic</done>
</task>

<task type="auto">
  <name>Task 2: Create middleware generator, tests, and wire all Phase 4 generators into orchestrator</name>
  <files>
    internal/generator/middleware.go
    internal/generator/middleware_test.go
    internal/generator/generator.go
    internal/generator/generator_test.go
  </files>
  <action>
1. `middleware.go` - Generator function:
   - `func GenerateMiddleware(resources []parser.ResourceIR, outputDir string, projectModule string) error`
   - Creates `gen/middleware/` directory via ensureDir
   - Renders `templates/middleware_recovery.go.tmpl` with `struct{ ProjectModule string }{ ProjectModule: projectModule }` data
   - Writes to `gen/middleware/recovery.go` via writeGoFile
   - Renders `templates/middleware_errors.go.tmpl` with same data
   - Writes to `gen/middleware/errors.go` via writeGoFile
   - Returns nil on success

2. `middleware_test.go` - Tests:
   - `TestGenerateMiddleware` - end-to-end test:
     - Creates temp directory
     - Calls GenerateMiddleware with empty resource slice and temp dir
     - Reads generated `middleware/recovery.go` file
     - Asserts it contains: "func Recovery", "recover()", "debug.Stack()", "slog.Error", "ErrorResponder"
     - Reads generated `middleware/errors.go` file
     - Asserts it contains: "func ErrorResponder", "writeSSEError", "writeJSONError", "writeHTMLError", "text/event-stream", "application/json"

3. `generator.go` - Update Generate() orchestrator:
   - Add three new generator calls AFTER the existing 8 generators (Models, Atlas, Factories, Validation, Queries, Pagination, Transaction, SQLCConfig):
     - `GenerateErrors(resources, cfg.OutputDir, cfg.ProjectModule)` - 9th
     - `GenerateActions(resources, cfg.OutputDir, cfg.ProjectModule)` - 10th
     - `GenerateMiddleware(resources, cfg.OutputDir, cfg.ProjectModule)` - 11th
   - Each with standard error check and return pattern
   - Add comments: "// Generate error types and DB error mapping", "// Generate action interfaces and default implementations", "// Generate middleware (panic recovery, error rendering)"

4. `generator_test.go` - Update existing orchestrator test:
   - If there is an existing test that verifies the number of generators called, update it to expect 11
   - Otherwise, just ensure the existing tests still pass (no breaking changes)
  </action>
  <verify>
Run `go test ./internal/generator/ -run TestGenerateMiddleware -v` and confirm middleware tests pass.
Run `go test ./internal/generator/ -v` and confirm ALL tests pass (including existing ones).
Run `go build ./internal/generator/` and confirm clean compile.
Run `go vet ./internal/generator/` and confirm no issues.
  </verify>
  <done>GenerateMiddleware produces gen/middleware/recovery.go and gen/middleware/errors.go, Generate() orchestrator calls all 11 generators including the 3 new Phase 4 generators, all tests pass</done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/ -v` - ALL tests pass (existing + new)
2. `go build ./internal/generator/` compiles cleanly
3. `go vet ./internal/generator/` reports no issues
4. Generated recovery.go has Recovery middleware with defer/recover and slog stack trace logging
5. Generated errors.go has ErrorResponder with SSE/JSON/HTML rendering based on Accept header
6. SSE errors use 200 status with datastar-merge-fragments event format
7. JSON errors follow RFC 9457 shape (status, title, detail, code)
8. Generate() orchestrator calls all 11 generators in order
9. Panic recovery does NOT expose panic details in response (Message is generic, Detail is empty)
</verification>

<success_criteria>
- Panic recovery middleware catches panics, logs full stack trace via slog, returns generic 500
- SSE context (Accept: text/event-stream) gets 200 status with toast fragment via Datastar event
- JSON context (Accept: application/json or /api/ path) gets RFC 9457-shaped error response
- HTML context gets minimal error page with status code and message
- Panic details never exposed to client (security requirement)
- Generate() orchestrator produces all Phase 4 artifacts alongside existing ones
- All 11 generators called in correct order
- All existing tests continue to pass (no regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/04-action-layer-error-handling/04-03-SUMMARY.md`
</output>
