---
phase: 09-public-api-surface-end-to-end-flow
plan: 04
type: execute
wave: 4
depends_on: ["09-02", "09-03"]
files_modified:
  - internal/scaffold/templates/schema.go.tmpl
  - internal/scaffold/templates/go.mod.tmpl
  - internal/scaffold/templates/main.go.tmpl
  - internal/scaffold/scaffold.go
  - internal/cli/init.go
autonomous: true
requirements: []

must_haves:
  truths:
    - "forge init scaffolds a Post example resource (not Product)"
    - "schema.go.tmpl imports github.com/alternayte/forge/schema (not module/gen/schema)"
    - "go.mod.tmpl includes require github.com/alternayte/forge"
    - "main.go.tmpl shows a minimal placeholder directing user to run forge generate"
    - "forge init myapp produces compilable go.mod with forge dependency"
  artifacts:
    - path: "internal/scaffold/templates/schema.go.tmpl"
      provides: "Post schema with Title, Body, Status"
      contains: "alternayte/forge/schema"
    - path: "internal/scaffold/templates/go.mod.tmpl"
      provides: "go.mod with forge require directive"
      contains: "github.com/alternayte/forge"
    - path: "internal/scaffold/templates/main.go.tmpl"
      provides: "Placeholder main.go"
      contains: "forge generate"
    - path: "internal/cli/init.go"
      provides: "Post as example resource"
      contains: "\"post\""
  key_links:
    - from: "internal/cli/init.go"
      to: "internal/scaffold/scaffold.go"
      via: "ProjectData with ExampleResource"
      pattern: "ExampleResource.*post"
    - from: "internal/scaffold/templates/schema.go.tmpl"
      to: "schema/"
      via: "import path in generated schema file"
      pattern: "alternayte/forge/schema"
---

<objective>
Fix scaffold templates so forge init produces correct import paths, includes the forge dependency in go.mod, and uses the Post example resource.

Purpose: After Phase 9, forge init must scaffold projects that can immediately compile after forge generate runs. The schema import path changes from the user's module to the framework's public schema package. The example resource changes from Product to Post per the locked decision.

Output: Updated scaffold templates and init command — forge init myapp creates a project with Post resource, correct schema import, and forge dependency in go.mod.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-RESEARCH.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-01-SUMMARY.md
@internal/scaffold/scaffold.go
@internal/scaffold/templates/schema.go.tmpl
@internal/scaffold/templates/go.mod.tmpl
@internal/scaffold/templates/main.go.tmpl
@internal/cli/init.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update scaffold templates for new imports and Post resource</name>
  <files>
    internal/scaffold/templates/schema.go.tmpl
    internal/scaffold/templates/go.mod.tmpl
    internal/scaffold/templates/main.go.tmpl
  </files>
  <action>
Update all three scaffold templates:

**1. schema.go.tmpl** — Change the import from `{{.Module}}/gen/schema` to `github.com/alternayte/forge/schema` (framework package, not user module). Change the example fields from Product (Name, Description, Active) to Post (Title, Body, Status) per the locked decision:

```
package {{.ExampleResource}}

import "github.com/alternayte/forge/schema"

// {{.ExampleResourceTitle}} resource definition
var {{.ExampleResourceTitle}} = schema.Define("{{.ExampleResourceTitle}}",
	schema.UUID("ID").PrimaryKey(),
	schema.String("Title").Required().MaxLen(200).Label("Title").Placeholder("Enter title"),
	schema.Text("Body").Label("Body").Help("Post content"),
	schema.String("Status").Required().Default("draft"),
	schema.Timestamps(),
)
```

Note: The import path is now hardcoded to `github.com/alternayte/forge/schema` — it does NOT use `{{.Module}}` because the schema package lives in the framework, not the user's project.

**2. go.mod.tmpl** — Add a require directive for the forge framework:

```
module {{.Module}}

go {{.GoVersion}}

require github.com/alternayte/forge v0.0.0
```

The version `v0.0.0` is a placeholder. For local development, the user will need to add a `replace` directive or the template can include a commented example. Since this is a scaffold (user-owned), they can edit it. A practical approach: include the require line, and after init, the next-steps output can mention `go mod tidy`.

**3. main.go.tmpl** — Update to reference the new module path in comments and remove the old forge-framework reference. Keep the minimal placeholder pattern (the real main.go is scaffolded by forge generate):

```
package main

import (
	"fmt"
	"os"
)

func main() {
	if err := run(); err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

func run() error {
	fmt.Println("{{.Name}} — powered by Forge")
	fmt.Println()
	fmt.Println("Next steps:")
	fmt.Println("  1. Define resources in resources/*/schema.go")
	fmt.Println("  2. Run 'forge generate' to generate code")
	fmt.Println("  3. Run 'forge dev' to start developing")

	return nil
}
```

Remove the old commented-out server wiring that references `forge-framework/forge/pkg/forge` — that path no longer exists. The real wiring will be in the main.go scaffolded by forge generate (Plan 05).
  </action>
  <verify>
    - `grep "alternayte/forge/schema" internal/scaffold/templates/schema.go.tmpl` finds the new import
    - `grep "alternayte/forge" internal/scaffold/templates/go.mod.tmpl` finds the require directive
    - `grep -v "forge-framework" internal/scaffold/templates/main.go.tmpl` confirms no old references
    - `grep "Title.*Body.*Status" internal/scaffold/templates/schema.go.tmpl` confirms Post fields (approximately)
  </verify>
  <done>Schema template imports from framework's schema package. go.mod template includes forge dependency. main.go template is clean placeholder.</done>
</task>

<task type="auto">
  <name>Task 2: Update init command to use Post example resource</name>
  <files>
    internal/cli/init.go
    internal/scaffold/scaffold.go
  </files>
  <action>
Update the init command and scaffold logic:

**1. internal/cli/init.go** — Change the example resource from "product"/"Product" to "post"/"Post":

Change:
```go
ExampleResource:      "product",
ExampleResourceTitle: "Product",
```
To:
```go
ExampleResource:      "post",
ExampleResourceTitle: "Post",
```

Also update the file listing in the success output — change `filepath.Join("resources", "product", "schema.go")` to `filepath.Join("resources", "post", "schema.go")`.

**2. internal/scaffold/scaffold.go** — No structural changes needed. The ExampleResource and ExampleResourceTitle fields are already parameterized. Verify that `CreateProject` correctly creates `resources/post/schema.go` when given the new data.

**3. Verify the complete init flow** — mentally trace: `forge init myapp` will:
- Create `myapp/resources/post/` directory
- Render `schema.go.tmpl` into `myapp/resources/post/schema.go` with Post fields
- Render `go.mod.tmpl` into `myapp/go.mod` with `require github.com/alternayte/forge v0.0.0`
- Render `main.go.tmpl` into `myapp/main.go` with placeholder
- Render `forge.toml.tmpl` into `myapp/forge.toml`

**4. Run `go build ./...`** — verify the forge CLI itself still compiles.
  </action>
  <verify>
    - `grep '"post"' internal/cli/init.go` confirms post resource
    - `grep '"Post"' internal/cli/init.go` confirms Post title
    - `grep 'resources.*post' internal/cli/init.go` confirms path updated
    - `go build ./...` compiles
  </verify>
  <done>forge init uses Post as the example resource. File paths in success output are correct. Scaffold templates produce correct import paths.</done>
</task>

</tasks>

<verification>
1. `grep "alternayte/forge/schema" internal/scaffold/templates/schema.go.tmpl` — correct import
2. `grep "alternayte/forge" internal/scaffold/templates/go.mod.tmpl` — forge dependency present
3. `grep '"post"' internal/cli/init.go` — Post resource
4. No references to `forge-framework` in scaffold templates
5. `go build ./...` — compiles
</verification>

<success_criteria>
- forge init scaffolds Post resource (not Product)
- Schema import path is github.com/alternayte/forge/schema
- go.mod includes forge dependency
- main.go is clean placeholder directing to forge generate
- CLI compiles
</success_criteria>

<output>
After completion, create `.planning/phases/09-public-api-surface-end-to-end-flow/09-04-SUMMARY.md`
</output>
