---
phase: 02-code-generation-engine
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/generator/atlas.go
  - internal/generator/factories.go
  - internal/generator/generator.go
  - internal/generator/funcmap.go
  - internal/generator/templates/atlas_schema.hcl.tmpl
  - internal/generator/templates/factory.go.tmpl
  - internal/generator/atlas_test.go
  - internal/generator/factories_test.go
autonomous: true

must_haves:
  truths:
    - "Running Atlas HCL generation on a ResourceIR produces a valid HCL schema file with correct table, column, index, and primary key definitions"
    - "All 14 IR field types map to correct PostgreSQL/Atlas HCL types (UUID->uuid, String->varchar, Decimal->numeric, etc.)"
    - "Running factory generation on a ResourceIR produces a Go file with NewProduct() and ProductBuilder functions for test data creation"
    - "Generated factory files include DO NOT EDIT header and compile as valid Go"
  artifacts:
    - path: "internal/generator/atlas.go"
      provides: "Atlas HCL schema generation from ResourceIR"
      exports: ["GenerateAtlasSchema"]
    - path: "internal/generator/factories.go"
      provides: "Test factory generation from ResourceIR"
      exports: ["GenerateFactories"]
    - path: "internal/generator/templates/atlas_schema.hcl.tmpl"
      provides: "Atlas HCL template with table/column/index definitions"
    - path: "internal/generator/templates/factory.go.tmpl"
      provides: "Test factory template with builder pattern"
  key_links:
    - from: "internal/generator/atlas.go"
      to: "internal/parser/ir.go"
      via: "Consumes ResourceIR to produce HCL table definitions"
      pattern: "parser\\.ResourceIR"
    - from: "internal/generator/atlas.go"
      to: "internal/generator/funcmap.go"
      via: "Uses atlasType helper for field type mapping"
      pattern: "atlasType"
    - from: "internal/generator/factories.go"
      to: "internal/generator/formatting.go"
      via: "Formats factory Go files via FormatGoSource"
      pattern: "FormatGoSource"
---

<objective>
Add Atlas HCL schema generation and test factory generation to the generator package.

Purpose: Atlas HCL files are the desired database state that Atlas CLI diffs against the live database to produce migrations. Test factories enable rapid test data creation. Both are essential artifacts of `forge generate`.
Output: GenerateAtlasSchema producing gen/atlas/schema.hcl, GenerateFactories producing gen/factories/*.go, and the Generate orchestrator updated to call all three generators.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation-engine/02-RESEARCH.md
@.planning/phases/02-code-generation-engine/02-01-SUMMARY.md
@internal/parser/ir.go
@internal/generator/generator.go
@internal/generator/funcmap.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Atlas HCL schema generation with PostgreSQL type mapping</name>
  <files>
    internal/generator/atlas.go
    internal/generator/funcmap.go
    internal/generator/templates/atlas_schema.hcl.tmpl
    internal/generator/atlas_test.go
  </files>
  <action>
Create Atlas HCL schema generation that produces the desired database state from ResourceIR.

1. **Add atlasType to funcmap.go**: Add `atlasType(fieldType string) string` to FuncMap:
   - UUID -> "uuid"
   - String -> "varchar(255)" (default, override via MaxLen modifier)
   - Text -> "text"
   - Int -> "integer"
   - BigInt -> "bigint"
   - Decimal -> "numeric(10,2)" (default precision)
   - Bool -> "boolean"
   - DateTime -> "timestamptz"
   - Date -> "date"
   - Enum -> "text" (with CHECK constraint, not PostgreSQL enum type -- simpler migration story)
   - JSON -> "jsonb"
   - Slug -> "varchar(255)"
   - Email -> "varchar(255)"
   - URL -> "text"

   Also add `atlasTypeWithModifiers(field parser.FieldIR) string` that checks MaxLen modifier to override varchar length: if MaxLen exists use varchar(N), otherwise use default.

   Add `atlasNull(modifiers []parser.ModifierIR) string` that returns "false" if Required modifier present, "true" otherwise.

   Add `atlasDefault(field parser.FieldIR) string` that returns the Atlas default expression if Default modifier is present, empty string otherwise. Handle: string defaults -> `"value"`, bool defaults -> `true`/`false`, int defaults -> number.

2. **internal/generator/templates/atlas_schema.hcl.tmpl**: Create the HCL template:

```hcl
# Code generated by forge generate. DO NOT EDIT.

schema "public" {
  comment = "Generated by Forge"
}

{{range .Resources}}
table "{{plural (snake .Name)}}" {
  schema = schema.public

  column "id" {
    type    = uuid
    default = sql("gen_random_uuid()")
    null    = false
  }

  {{range .Fields}}
  column "{{snake .Name}}" {
    type = {{atlasTypeWithModifiers .}}
    null = {{atlasNull .Modifiers}}
    {{if hasDefault .}}default = {{atlasDefault .}}{{end}}
  }
  {{end}}

  {{if .HasTimestamps}}
  column "created_at" {
    type    = timestamptz
    default = sql("now()")
    null    = false
  }
  column "updated_at" {
    type    = timestamptz
    default = sql("now()")
    null    = false
  }
  {{end}}

  {{if .Options.SoftDelete}}
  column "deleted_at" {
    type = timestamptz
    null = true
  }
  {{end}}

  primary_key {
    columns = [column.id]
  }

  {{range .Fields}}
  {{if hasModifier .Modifiers "Unique"}}
  index "{{plural (snake $.Name)}}_{{snake .Name}}_unique" {
    columns = [column.{{snake .Name}}]
    unique  = true
  }
  {{end}}
  {{if hasModifier .Modifiers "Index"}}
  index "{{plural (snake $.Name)}}_{{snake .Name}}_idx" {
    columns = [column.{{snake .Name}}]
  }
  {{end}}
  {{end}}
}
{{end}}
```

Template should handle: all field types, required/optional columns, default values, unique indexes, regular indexes, timestamps, soft delete column, and primary key on id.

3. **internal/generator/atlas.go**: Create GenerateAtlasSchema:
   - `func GenerateAtlasSchema(resources []parser.ResourceIR, outputDir string) error`
   - Renders atlas_schema.hcl.tmpl with all resources at once (single file, not per-resource)
   - Writes to `{outputDir}/atlas/schema.hcl` using writeRawFile (not Go formatting -- HCL is not Go)
   - Creates output directory if not exists

4. **internal/generator/atlas_test.go**: Create tests:
   - TestGenerateAtlasSchema_ProductTable: Generate from Product ResourceIR, verify:
     - File exists at gen/atlas/schema.hcl
     - Contains `table "products"` (pluralized, snake_case)
     - Contains `column "id"` with uuid type
     - Contains columns for all fields with correct types
     - Contains `null = false` for Required fields
     - Contains `primary_key` block
     - Contains timestamps columns if HasTimestamps
     - Contains `deleted_at` column if SoftDelete
   - TestAtlasTypeMapping: Verify all 14 field types map to correct PostgreSQL types
   - TestAtlasUniqueIndex: Verify Unique modifier generates unique index
  </action>
  <verify>
Run `go test ./internal/generator/ -run "Atlas" -v` -- all Atlas tests pass. Verify generated HCL file is syntactically valid (no template rendering errors). Verify all 14 field types produce correct PostgreSQL types.
  </verify>
  <done>
GenerateAtlasSchema produces a single schema.hcl file with table definitions for all resources. Tables have correct column types, null constraints, default values, primary keys, and indexes. Tests verify type mappings and end-to-end generation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create test factory generation and wire Generate orchestrator</name>
  <files>
    internal/generator/factories.go
    internal/generator/templates/factory.go.tmpl
    internal/generator/generator.go
    internal/generator/factories_test.go
  </files>
  <action>
Create test factory generation and update the Generate orchestrator to call all three generators.

1. **internal/generator/templates/factory.go.tmpl**: Create factory template with builder pattern:

```go
// Code generated by forge generate. DO NOT EDIT.

package factories

// New{{.Name}} creates a {{.Name}} with default test values.
func New{{.Name}}() *models.{{.Name}} {
    return &models.{{.Name}}{
        {{range .Fields}}{{if not (isIDField .)}}
        {{.Name}}: {{defaultTestValue .}},
        {{end}}{{end}}
    }
}

// {{.Name}}Builder provides a fluent API for building test {{.Name}} instances.
type {{.Name}}Builder struct {
    instance *models.{{.Name}}
}

// Build{{.Name}} starts building a {{.Name}} with default values.
func Build{{.Name}}() *{{.Name}}Builder {
    return &{{.Name}}Builder{instance: New{{.Name}}()}
}

{{range .Fields}}{{if not (isIDField .)}}
// With{{.Name}} sets the {{.Name}} field.
func (b *{{$.Name}}Builder) With{{.Name}}(v {{goType .Type}}) *{{$.Name}}Builder {
    b.instance.{{.Name}} = v
    return b
}
{{end}}{{end}}

// Build returns the constructed {{.Name}}.
func (b *{{.Name}}Builder) Build() *models.{{.Name}} {
    return b.instance
}
```

Add `defaultTestValue(field parser.FieldIR) string` to funcmap.go:
- UUID -> `uuid.New()` (but skip for ID which is auto-generated)
- String -> `"test-{{snake .Name}}"` (literal string with field name)
- Text -> `"Test {{.Name}} content"`
- Int -> `42`
- BigInt -> `100000`
- Decimal -> `decimal.NewFromFloat(9.99)`
- Bool -> `true`
- DateTime -> `time.Now()`
- Date -> `time.Now()`
- Enum -> first enum value as string literal, or `"default"` if no values
- JSON -> `json.RawMessage("{}")`
- Slug -> `"test-slug"`
- Email -> `"test@example.com"`
- URL -> `"https://example.com"`

The template should produce importable Go code. The generated factories package will import the generated models package. Use projectModule to construct the import path: `{projectModule}/gen/models`.

2. **internal/generator/factories.go**: Create GenerateFactories:
   - `func GenerateFactories(resources []parser.ResourceIR, outputDir string, projectModule string) error`
   - For each resource: render factory.go.tmpl, format via writeGoFile, write to `{outputDir}/factories/{snake(resource.Name)}.go`
   - The template data should include projectModule for import path construction

3. **Update internal/generator/generator.go**: Update Generate function to call all three:
   - GenerateModels(resources, outputDir, projectModule)
   - GenerateAtlasSchema(resources, outputDir)
   - GenerateFactories(resources, outputDir, projectModule)
   - Log each step using fmt.Fprintf to an optional io.Writer (for CLI output)

4. **internal/generator/factories_test.go**: Create tests:
   - TestGenerateFactories_ProductSchema: Generate from Product ResourceIR, verify:
     - File exists at gen/factories/product.go
     - Contains "DO NOT EDIT" header
     - Contains "func NewProduct()"
     - Contains "type ProductBuilder struct"
     - Contains "func BuildProduct()"
     - Contains "func (b *ProductBuilder) Build()"
     - File passes go/format.Source()
   - TestDefaultTestValues: Verify all field types produce reasonable default values
  </action>
  <verify>
Run `go test ./internal/generator/ -v` -- ALL tests pass (models, atlas, factories). Run `go vet ./internal/generator/`. Verify Generate() function calls all three generators.
  </verify>
  <done>
GenerateFactories produces per-resource factory files with New{Resource}(), {Resource}Builder, and Build{Resource}() functions. Generate orchestrator calls GenerateModels + GenerateAtlasSchema + GenerateFactories. All generator tests pass.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/ -v` all tests pass (models + atlas + factories)
2. `go vet ./internal/generator/` reports no issues
3. Generated model files compile as valid Go
4. Generated HCL file has correct PostgreSQL types and table structure
5. Generated factory files compile as valid Go
6. Generate() orchestrator calls all three generators
</verification>

<success_criteria>
- Atlas HCL generation maps all 14 field types to correct PostgreSQL types
- Atlas HCL includes tables, columns, constraints, indexes, primary keys
- Factory generation produces builder-pattern test helpers
- Generate() orchestrator runs all generators in sequence
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation-engine/02-02-SUMMARY.md`
</output>
