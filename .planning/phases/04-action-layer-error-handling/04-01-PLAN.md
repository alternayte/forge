---
phase: 04-action-layer-error-handling
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/generator/errors.go
  - internal/generator/errors_test.go
  - internal/generator/templates/errors.go.tmpl
  - internal/generator/templates/errors_db_mapping.go.tmpl
autonomous: true

must_haves:
  truths:
    - "forge.Error carries HTTP status, machine-readable code, user-facing message, developer detail, and wrapped error"
    - "Database errors (unique violation, FK violation, not null violation) are automatically mapped to forge.Error with correct HTTP status codes"
    - "forge.Error implements Go error interface and supports errors.Is/errors.As via Unwrap"
  artifacts:
    - path: "internal/generator/errors.go"
      provides: "Error type and DB mapping code generation functions"
      exports: ["GenerateErrors"]
    - path: "internal/generator/templates/errors.go.tmpl"
      provides: "forge.Error struct, constructors (NotFound, UniqueViolation, Unauthorized, etc.), and ValidationError bridge"
      contains: "type Error struct"
    - path: "internal/generator/templates/errors_db_mapping.go.tmpl"
      provides: "MapDBError function mapping pgconn.PgError codes to forge.Error"
      contains: "func MapDBError"
  key_links:
    - from: "gen/errors/errors.go (generated)"
      to: "gen/errors/db_mapping.go (generated)"
      via: "MapDBError returns *Error type"
      pattern: "return &Error"
    - from: "gen/errors/db_mapping.go (generated)"
      to: "pgconn.PgError"
      via: "errors.As type assertion"
      pattern: "errors\\.As.*pgErr"
---

<objective>
Generate forge.Error type and database error mapping as the foundational error handling layer for the action system.

Purpose: All action layer operations return forge.Error with structured HTTP status codes, machine-readable codes, and user-facing messages. Database errors from pgx are automatically mapped to appropriate forge.Error instances. This is the foundation that action generation (Plan 02) and middleware (Plan 03) build upon.

Output: Generator functions and templates that produce `gen/errors/errors.go` and `gen/errors/db_mapping.go` when `forge generate` runs.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-action-layer-error-handling/04-RESEARCH.md
@internal/generator/generator.go
@internal/generator/validation.go
@internal/generator/funcmap.go
@internal/generator/templates.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forge.Error type template and error constructor generation</name>
  <files>
    internal/generator/templates/errors.go.tmpl
    internal/generator/templates/errors_db_mapping.go.tmpl
  </files>
  <action>
Create two Go templates in internal/generator/templates/:

1. `errors.go.tmpl` - Generates `gen/errors/errors.go` with:
   - Package `errors` with "Code generated by forge generate. DO NOT EDIT." header
   - `type Error struct` with fields: Status (int), Code (string), Message (string), Detail (string), Err (error)
   - `Error()` method returning `fmt.Sprintf("%s: %v", e.Message, e.Err)` when Err is non-nil, else e.Message
   - `Unwrap()` method returning e.Err (for errors.Is/As compatibility)
   - `GetStatus()` method returning e.Status
   - Constructor functions:
     - `NotFound(resource string, id any) *Error` - Status 404, Code "resource_not_found"
     - `UniqueViolation(field string) *Error` - Status 409, Code "unique_violation"
     - `ForeignKeyViolation(field string) *Error` - Status 400, Code "foreign_key_violation"
     - `Unauthorized(message string) *Error` - Status 401, Code "unauthorized"
     - `Forbidden(message string) *Error` - Status 403, Code "forbidden"
     - `BadRequest(message string) *Error` - Status 400, Code "bad_request"
     - `InternalError(err error) *Error` - Status 500, Code "internal_error", wraps original error, user message "An unexpected error occurred"
   - `NewValidationError(errs interface{}) *Error` function - Status 422, Code "validation_error", Message "Validation failed", Detail from validation errors. This bridges gen/validation's ValidationErrors type to forge.Error. Accept interface{} and call .Error() on it so it doesn't need to import validation package directly.
   - Imports: "errors", "fmt"

2. `errors_db_mapping.go.tmpl` - Generates `gen/errors/db_mapping.go` with:
   - Package `errors` with DO NOT EDIT header
   - Constants for PostgreSQL error codes: ErrCodeUniqueViolation = "23505", ErrCodeFKViolation = "23503", ErrCodeNotNullViolation = "23502", ErrCodeCheckViolation = "23514"
   - `func MapDBError(err error) error` that:
     - Returns nil if err is nil
     - Uses `errors.As(err, &pgErr)` to check for `*pgconn.PgError`
     - Maps 23505 -> UniqueViolation (409), using pgErr.ConstraintName in Detail
     - Maps 23503 -> ForeignKeyViolation (400), using pgErr.ConstraintName in Detail
     - Maps 23502 -> BadRequest with "Required field is missing", using pgErr.ColumnName in Detail
     - Maps 23514 -> BadRequest with "Value does not meet constraints", using pgErr.ConstraintName in Detail
     - Default: InternalError wrapping the original error
   - `func IsNotFound(err error) bool` helper that checks `sql.ErrNoRows` using errors.Is
   - Imports: "database/sql", "errors" (stdlib), "github.com/jackc/pgx/v5/pgconn"

Note: These templates are static (not resource-specific) so they take no template data. Follow the same pattern as validation_types.go.tmpl which also generates a static file.
  </action>
  <verify>
Read both template files and confirm:
- errors.go.tmpl contains Error struct with all 5 fields
- errors.go.tmpl contains all 7 constructor functions + NewValidationError
- errors_db_mapping.go.tmpl contains MapDBError with pgconn.PgError type assertion
- errors_db_mapping.go.tmpl contains all 4 PostgreSQL error code constants
- errors_db_mapping.go.tmpl contains IsNotFound helper
  </verify>
  <done>Both template files exist with correct content, Error struct has Status/Code/Message/Detail/Err fields, MapDBError handles 23505/23503/23502/23514 codes</done>
</task>

<task type="auto">
  <name>Task 2: Create error generator function and tests</name>
  <files>
    internal/generator/errors.go
    internal/generator/errors_test.go
  </files>
  <action>
Create the generator function and tests following the exact pattern of internal/generator/validation.go:

1. `errors.go` - Generator function:
   - `func GenerateErrors(resources []parser.ResourceIR, outputDir string, projectModule string) error`
   - Signature matches other generators for consistency even though errors are not per-resource
   - Creates `gen/errors/` directory via ensureDir
   - Renders `templates/errors.go.tmpl` with nil data (static file), writes to `gen/errors/errors.go` via writeGoFile
   - Renders `templates/errors_db_mapping.go.tmpl` with nil data, writes to `gen/errors/db_mapping.go` via writeGoFile
   - Returns nil on success

2. `errors_test.go` - Tests following existing test patterns (see generator_test.go):
   - `TestGenerateErrors` - end-to-end test:
     - Creates temp directory
     - Calls GenerateErrors with empty resource slice and temp dir
     - Reads generated `errors/errors.go` file
     - Asserts it contains: "type Error struct", "func NotFound", "func UniqueViolation", "func MapDBError" (wait - MapDBError is in separate file)
     - Asserts errors.go contains: "type Error struct", "func NotFound", "func UniqueViolation", "func NewValidationError", "func (e *Error) Error()", "func (e *Error) Unwrap()"
     - Reads generated `errors/db_mapping.go` file
     - Asserts it contains: "func MapDBError", "ErrCodeUniqueViolation", "pgconn.PgError", "func IsNotFound"
   - `TestGenerateErrors_FileCreation` - verifies both files are created in correct location

Do NOT modify generator.go yet - that wiring happens in Plan 03.
  </action>
  <verify>
Run `go test ./internal/generator/ -run TestGenerateErrors -v` and confirm all tests pass.
Run `go build ./internal/generator/` and confirm clean compile.
Run `go vet ./internal/generator/` and confirm no issues.
  </verify>
  <done>GenerateErrors function produces gen/errors/errors.go with forge.Error type and gen/errors/db_mapping.go with MapDBError, all tests pass, code compiles cleanly</done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/ -run TestGenerateErrors -v` passes
2. `go build ./internal/generator/` compiles cleanly
3. `go vet ./internal/generator/` reports no issues
4. Generated errors.go contains Error struct with Status, Code, Message, Detail, Err fields
5. Generated db_mapping.go maps PostgreSQL error codes 23505, 23503, 23502, 23514 to forge.Error
6. Generated errors use errors.As for pgconn.PgError type checking (not string matching)
</verification>

<success_criteria>
- forge.Error struct generated with all 5 fields (Status, Code, Message, Detail, Err)
- Error implements error interface (Error() string) and Unwrap() for errors.Is/As
- 7 constructor functions generated (NotFound, UniqueViolation, ForeignKeyViolation, Unauthorized, Forbidden, BadRequest, InternalError)
- NewValidationError bridges validation package errors to forge.Error
- MapDBError maps 4 PostgreSQL error codes to appropriate forge.Error instances
- IsNotFound helper checks sql.ErrNoRows
- All tests pass, code compiles
</success_criteria>

<output>
After completion, create `.planning/phases/04-action-layer-error-handling/04-01-SUMMARY.md`
</output>
