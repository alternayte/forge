---
phase: 03-query-data-access
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - internal/generator/pagination.go
  - internal/generator/pagination_test.go
  - internal/generator/templates/pagination.go.tmpl
  - internal/generator/sqlc.go
  - internal/generator/sqlc_test.go
  - internal/generator/templates/sqlc.yaml.tmpl
  - internal/generator/templates/transaction.go.tmpl
  - internal/generator/generator.go
autonomous: true

must_haves:
  truths:
    - "forge generate produces pagination utilities supporting both offset and cursor-based pagination in gen/queries/"
    - "forge generate produces a sqlc.yaml config file pointing to queries/custom/ for developer escape hatches"
    - "forge generate produces a transaction wrapper using pgx.BeginFunc with River InsertTx support in gen/forge/"
    - "Cursor pagination encodes position as base64(json) with ID + sort column for uniqueness"
    - "Offset pagination provides Limit/Offset mods from page number and page size"
  artifacts:
    - path: "internal/generator/pagination.go"
      provides: "GeneratePagination function"
      exports: ["GeneratePagination"]
    - path: "internal/generator/templates/pagination.go.tmpl"
      provides: "Template for cursor + offset pagination utilities"
      contains: "EncodeCursor"
    - path: "internal/generator/sqlc.go"
      provides: "GenerateSQLCConfig and GenerateTransaction functions"
      exports: ["GenerateSQLCConfig", "GenerateTransaction"]
    - path: "internal/generator/templates/sqlc.yaml.tmpl"
      provides: "SQLC configuration template"
      contains: "queries/custom"
    - path: "internal/generator/templates/transaction.go.tmpl"
      provides: "Transaction wrapper template with River support"
      contains: "BeginFunc"
  key_links:
    - from: "internal/generator/generator.go"
      to: "internal/generator/pagination.go"
      via: "GeneratePagination function call in Generate()"
      pattern: "GeneratePagination"
    - from: "internal/generator/generator.go"
      to: "internal/generator/sqlc.go"
      via: "GenerateSQLCConfig and GenerateTransaction calls in Generate()"
      pattern: "GenerateSQLCConfig|GenerateTransaction"
    - from: "internal/generator/templates/pagination.go.tmpl"
      to: "internal/generator/templates/queries.go.tmpl"
      via: "Pagination mods compose with query filter mods"
      pattern: "sm\\.Limit|sm\\.Offset"
---

<objective>
Generate pagination utilities, SQLC escape hatch configuration, and transaction wrapper with River support.

Purpose: DATA-03/DATA-04 (pagination), DATA-10 (SQLC escape hatch), and DATA-11 (transactions with River) complete the data access layer. Pagination enables both offset-based (HTML views) and cursor-based (API) patterns. SQLC provides an escape hatch for complex queries Bob can't express. Transaction wrapper ensures atomic operations with background job enqueueing.

Output: GeneratePagination, GenerateSQLCConfig, and GenerateTransaction functions with templates, tests, and orchestrator wiring.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-query-data-access/03-RESEARCH.md
@.planning/phases/03-query-data-access/03-01-SUMMARY.md
@internal/generator/generator.go
@internal/generator/funcmap.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pagination utility generation and SQLC config generation</name>
  <files>
    internal/generator/pagination.go
    internal/generator/pagination_test.go
    internal/generator/templates/pagination.go.tmpl
    internal/generator/sqlc.go
    internal/generator/sqlc_test.go
    internal/generator/templates/sqlc.yaml.tmpl
  </files>
  <action>
Create generators for pagination utilities and SQLC configuration.

**Pagination Generation:**

1. Create `internal/generator/templates/pagination.go.tmpl`:
   - Package: `queries` (lives alongside query mods in gen/queries/)
   - DO NOT EDIT header
   - Imports: `encoding/base64`, `encoding/json`, `github.com/google/uuid`, `github.com/stephenafamo/bob/dialect/psql/sm`, `time`, `fmt`
   - Define `PageInfo` struct:
     - `HasNextPage bool` (json tag)
     - `HasPrevPage bool` (json tag)
     - `StartCursor *string` (json tag, omitempty)
     - `EndCursor *string` (json tag, omitempty)
     - `TotalCount *int64` (json tag, omitempty -- only populated for offset pagination)
   - Define `Cursor` struct (unexported):
     - `ID uuid.UUID` (json tag)
     - `SortValue interface{}` (json tag -- the value of the sort column at cursor position)
     - `SortField string` (json tag -- which field was sorted)
   - `EncodeCursor(id uuid.UUID, sortField string, sortValue interface{}) (string, error)`:
     - Create Cursor struct, json.Marshal, base64.URLEncoding.EncodeToString
   - `DecodeCursor(encoded string) (*Cursor, error)`:
     - base64.URLEncoding.DecodeString, json.Unmarshal into Cursor
   - `OffsetPaginationMods(page, pageSize int) []bob.Mod[*dialect.SelectQuery]`:
     - Returns slice with `sm.Limit(pageSize)` and `sm.Offset((page - 1) * pageSize)`
     - Validate page >= 1, pageSize >= 1 and <= 100 (cap at 100)
   - `CursorPaginationMods(cursor *Cursor, pageSize int, sortDir string) []bob.Mod[*dialect.SelectQuery]`:
     - Returns slice with `sm.Limit(pageSize + 1)` (fetch one extra to detect hasNext)
     - If cursor is not nil, add WHERE clause using row value comparison:
       - For ASC: `(sort_field, id) > (cursor.SortValue, cursor.ID)`
       - For DESC: `(sort_field, id) < (cursor.SortValue, cursor.ID)`
     - Use `psql.Raw()` for the tuple comparison SQL

2. Create `internal/generator/pagination.go`:
   - `GeneratePagination(resources []parser.ResourceIR, outputDir, projectModule string) error`
   - This generates a SINGLE file `gen/queries/pagination.go` (not per-resource) since pagination logic is generic
   - Render pagination.go.tmpl and write to gen/queries/pagination.go
   - Pass nil or empty data since template is not resource-specific

3. Create `internal/generator/pagination_test.go`:
   - Verify pagination.go is generated at correct path
   - Verify it contains EncodeCursor, DecodeCursor, OffsetPaginationMods, CursorPaginationMods
   - Verify it contains PageInfo struct
   - Verify generated code compiles with `go/format.Source()`

**SQLC Config Generation:**

4. Create `internal/generator/templates/sqlc.yaml.tmpl`:
   - SQLC v2 configuration format:
     ```yaml
     version: "2"
     sql:
       - engine: "postgresql"
         queries: "queries/custom/"
         schema: "gen/atlas/"
         gen:
           go:
             package: "custom"
             out: "queries/custom"
             sql_package: "pgx/v5"
             emit_json_tags: true
             emit_result_struct_pointers: true
     ```
   - This is a static template (no resource-specific interpolation needed)
   - It points to queries/custom/ for developer-written SQL files and gen/atlas/ for schema

5. Create `internal/generator/sqlc.go`:
   - `GenerateSQLCConfig(resources []parser.ResourceIR, outputDir, projectModule string) error`
   - Renders sqlc.yaml.tmpl to `sqlc.yaml` in the PROJECT ROOT (not gen/)
   - Use writeRawFile (not writeGoFile -- it's YAML, not Go)
   - NOTE: The outputDir is gen/, but sqlc.yaml goes in project root. Calculate project root as parent of outputDir, or accept a separate rootDir parameter. Simplest: add a `ProjectRoot string` field to GenerateConfig (or compute it from OutputDir by going up one directory).

6. Create `internal/generator/sqlc_test.go`:
   - Verify sqlc.yaml is generated
   - Verify it contains correct engine, queries path, schema path
   - Verify valid YAML format

IMPORTANT: The pagination template generates code that uses Bob types. This code will compile in the USER's project, not in forge itself. The template produces text containing Bob import paths. The test verifies the text is valid Go, not that Bob queries actually run.

IMPORTANT: For CursorPaginationMods, the tuple comparison `(sort_field, id) > (?, ?)` must use `psql.Raw()` or equivalent Bob API for raw SQL expressions. The exact Bob API for raw WHERE clauses should be `sm.Where(psql.Raw("("+sortColumn+", id) > (?, ?)", cursor.SortValue, cursor.ID))`. Verify this pattern against the research doc.
  </action>
  <verify>
Run `go test ./internal/generator/ -run "TestGeneratePagination|TestGenerateSQLCConfig" -v` and `go build ./internal/generator/`
  </verify>
  <done>
GeneratePagination produces gen/queries/pagination.go with cursor + offset utilities. GenerateSQLCConfig produces sqlc.yaml at project root. Tests pass and generated code is valid.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create transaction wrapper generation and wire all new generators</name>
  <files>
    internal/generator/templates/transaction.go.tmpl
    internal/generator/sqlc.go
    internal/generator/generator.go
  </files>
  <action>
Create the transaction wrapper generator and wire all Phase 3 generators into the orchestrator.

**Transaction Generation:**

1. Create `internal/generator/templates/transaction.go.tmpl`:
   - Package: `forge` (lives in gen/forge/ -- the project's forge runtime package)
   - DO NOT EDIT header
   - Imports: `context`, `github.com/jackc/pgx/v5`, `github.com/jackc/pgx/v5/pgxpool`, `github.com/riverqueue/river`
   - Define `DB` interface:
     - Embeds pgx transaction-compatible interface for flexibility
     - Methods: `Exec`, `Query`, `QueryRow` matching pgx.Tx signatures
   - Define `TransactionFunc` type: `func(ctx context.Context, tx pgx.Tx) error`
   - `Transaction(ctx context.Context, pool *pgxpool.Pool, fn TransactionFunc) error`:
     - Wraps `pgx.BeginFunc(ctx, pool, fn)`
     - Simple wrapper that provides a clean API surface
   - `TransactionWithJobs(ctx context.Context, pool *pgxpool.Pool, client *river.Client[pgx.Tx], fn func(ctx context.Context, tx pgx.Tx, jobs *river.Client[pgx.Tx]) error) error`:
     - Wraps `pgx.BeginFunc(ctx, pool, func(tx pgx.Tx) error { return fn(ctx, tx, client) })`
     - Passes river client into callback so user can call `client.InsertTx(ctx, tx, args, nil)` inside the transaction
     - This ensures jobs are enqueued atomically with DB operations

2. Add `GenerateTransaction` function to `internal/generator/sqlc.go` (same file since it's a small generator):
   - `GenerateTransaction(resources []parser.ResourceIR, outputDir, projectModule string) error`
   - Renders transaction.go.tmpl to `gen/forge/transaction.go`
   - Uses writeGoFile for Go formatting
   - This is NOT per-resource -- single file regardless of resource count

3. Add test case to `internal/generator/sqlc_test.go`:
   - `TestGenerateTransaction`:
     - Verify gen/forge/transaction.go is generated
     - Verify it contains Transaction and TransactionWithJobs functions
     - Verify it imports pgx and river packages
     - Verify generated code compiles with `go/format.Source()`

**Wire Orchestrator:**

4. Update `internal/generator/generator.go` Generate() function to call the new generators:
   - After existing calls (GenerateModels, GenerateAtlasSchema, GenerateFactories, GenerateValidation, GenerateQueries):
   - Add `GeneratePagination(resources, cfg.OutputDir, cfg.ProjectModule)` call
   - Add `GenerateTransaction(resources, cfg.OutputDir, cfg.ProjectModule)` call
   - Add `GenerateSQLCConfig(resources, cfg.OutputDir, cfg.ProjectModule)` call
   - NOTE: If GenerateSQLCConfig needs project root (parent of OutputDir), either:
     (a) Add ProjectRoot to GenerateConfig, or
     (b) Compute it in GenerateSQLCConfig as filepath.Dir(outputDir)
   - Option (b) is simpler since outputDir is typically "gen/" which is one level below root.
   - Actually, GenerateConfig already has ProjectModule. Add a ProjectRoot field to GenerateConfig. The CLI's generate.go already knows the project root -- just pass it through.

5. Update `internal/generator/generator.go` GenerateConfig struct:
   - Add `ProjectRoot string` field
   - Use it in GenerateSQLCConfig to write sqlc.yaml to the right location

6. Verify the entire generator pipeline works end-to-end:
   - All 8 generators called: Models, Atlas, Factories, Validation, Queries, Pagination, Transaction, SQLCConfig
   - No existing tests broken by GenerateConfig change (update test setup if needed)

IMPORTANT: The transaction template generates code referencing pgx and river. These are dependencies of the USER's project, not forge itself. forge's go.mod does NOT need pgx or river. The template produces text that will compile in the user's project.
  </action>
  <verify>
Run `go test ./internal/generator/ -v` (all tests) and `go build ./internal/generator/` and `go vet ./internal/generator/`
  </verify>
  <done>
GenerateTransaction produces gen/forge/transaction.go with Transaction() and TransactionWithJobs() wrappers. Generate() orchestrator calls all 8 generators. All existing and new tests pass. GenerateConfig includes ProjectRoot.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/ -v` -- all tests pass (existing + pagination + sqlc + transaction)
2. `go build ./internal/generator/` -- clean compile
3. `go vet ./internal/generator/` -- no issues
4. Generated pagination.go contains EncodeCursor, DecodeCursor, OffsetPaginationMods, CursorPaginationMods
5. Generated sqlc.yaml points to queries/custom/ with pgx/v5 driver
6. Generated transaction.go contains Transaction and TransactionWithJobs with pgx.BeginFunc
7. Generate() calls all 8 generators in order
</verification>

<success_criteria>
- gen/queries/pagination.go generated with offset + cursor pagination
- sqlc.yaml generated at project root with correct config
- gen/forge/transaction.go generated with pgx + River transaction wrapper
- All 8 generators wired into Generate() orchestrator
- All tests pass, no regressions
</success_criteria>

<output>
After completion, create `.planning/phases/03-query-data-access/03-02-SUMMARY.md`
</output>
