// Code generated by forge generate. DO NOT EDIT.

package api

import (
	"context"
	"fmt"
	"net/http"
{{- if .Options.Auditable}}
	"encoding/json"
	"time"
{{- end}}

	"github.com/danielgtaylor/huma/v2"
	"github.com/google/uuid"
	"{{.ProjectModule}}/gen/actions"
	"{{.ProjectModule}}/gen/models"
)

// Register{{.Name}}Routes registers all CRUD endpoints for {{.Name}} on the given Huma API.
// All business logic is delegated to the provided {{.Name}}Actions implementation.
func Register{{.Name}}Routes(api huma.API, act actions.{{.Name}}Actions) {
	// List {{plural .Name | lower}}
	huma.Register(api, huma.Operation{
		OperationID: "list{{plural .Name}}",
		Method:      http.MethodGet,
		Path:        "/api/v1/{{kebab (plural .Name)}}",
		Summary:     "List {{plural .Name | lower}}",
		Tags:        []string{"{{kebab .Name}}"},
	}, func(ctx context.Context, input *List{{.Name}}Input) (*List{{.Name}}Output, error) {
		filter := models.{{.Name}}Filter{}
{{- range .Fields}}
{{- if and (not (isIDField .)) (isFilterable .Modifiers)}}
		if input.{{.Name}} != nil {
			filter.{{.Name}} = input.{{.Name}}
		}
{{- end}}
{{- end}}

{{- if sortableFieldNames .Fields}}
		sort := models.{{.Name}}Sort{
			Field:     input.Sort,
			Direction: input.SortDir,
		}
{{- else}}
		sort := models.{{.Name}}Sort{}
{{- end}}

		// Decode cursor if provided
		page := 1
		pageSize := input.Limit
		if pageSize == 0 {
			pageSize = 20
		}

		items, total, err := act.List(ctx, filter, sort, page, pageSize)
		if err != nil {
			return nil, toHumaError(err)
		}

		// Build pagination metadata
		hasMore := int64(page*pageSize) < total
		var nextCursor string
		if hasMore {
			nextCursor = fmt.Sprintf("%d", page+1)
		}

		out := &List{{.Name}}Output{}
		out.Body.Data = items
		out.Body.Pagination = PaginationMeta{
			NextCursor: nextCursor,
			HasMore:    hasMore,
		}

		// Set RFC 8288 Link header when there are more results (rel="next")
		if hasMore && nextCursor != "" {
			out.Link = buildAPILinkHeader("/api/v1/{{kebab (plural .Name)}}", nextCursor, pageSize)
		}

		return out, nil
	})

	// Get a single {{.Name}}
	huma.Register(api, huma.Operation{
		OperationID: "get{{.Name}}",
		Method:      http.MethodGet,
		Path:        "/api/v1/{{kebab (plural .Name)}}/{id}",
		Summary:     "Get a {{.Name}}",
		Tags:        []string{"{{kebab .Name}}"},
	}, func(ctx context.Context, input *Get{{.Name}}Input) (*Get{{.Name}}Output, error) {
		id, err := uuid.Parse(input.ID)
		if err != nil {
			return nil, huma.Error400BadRequest("invalid {{.Name}} ID format")
		}

		item, err := act.Get(ctx, id)
		if err != nil {
			return nil, toHumaError(err)
		}

		out := &Get{{.Name}}Output{}
		out.Body.Data = *item
		return out, nil
	})

	// Create a new {{.Name}}
	huma.Register(api, huma.Operation{
		OperationID:   "create{{.Name}}",
		Method:        http.MethodPost,
		Path:          "/api/v1/{{kebab (plural .Name)}}",
		Summary:       "Create a {{.Name}}",
		Tags:          []string{"{{kebab .Name}}"},
		DefaultStatus: http.StatusCreated,
	}, func(ctx context.Context, input *Create{{.Name}}Input) (*Create{{.Name}}Output, error) {
		createInput := models.{{.Name}}Create{
{{- range .Fields}}
{{- if not (isIDField .)}}
			{{.Name}}: input.Body.{{.Name}},
{{- end}}
{{- end}}
		}

		item, err := act.Create(ctx, createInput)
		if err != nil {
			return nil, toHumaError(err)
		}

		out := &Create{{.Name}}Output{}
		out.Body.Data = *item
		return out, nil
	})

	// Update an existing {{.Name}}
	huma.Register(api, huma.Operation{
		OperationID: "update{{.Name}}",
		Method:      http.MethodPut,
		Path:        "/api/v1/{{kebab (plural .Name)}}/{id}",
		Summary:     "Update a {{.Name}}",
		Tags:        []string{"{{kebab .Name}}"},
	}, func(ctx context.Context, input *Update{{.Name}}Input) (*Update{{.Name}}Output, error) {
		id, err := uuid.Parse(input.ID)
		if err != nil {
			return nil, huma.Error400BadRequest("invalid {{.Name}} ID format")
		}

		updateInput := models.{{.Name}}Update{
{{- range .Fields}}
{{- if not (isIDField .)}}
			{{.Name}}: input.Body.{{.Name}},
{{- end}}
{{- end}}
		}

		item, err := act.Update(ctx, id, updateInput)
		if err != nil {
			return nil, toHumaError(err)
		}

		out := &Update{{.Name}}Output{}
		out.Body.Data = *item
		return out, nil
	})

	// Delete a {{.Name}}
	huma.Register(api, huma.Operation{
		OperationID:   "delete{{.Name}}",
		Method:        http.MethodDelete,
		Path:          "/api/v1/{{kebab (plural .Name)}}/{id}",
		Summary:       "Delete a {{.Name}}",
		Tags:          []string{"{{kebab .Name}}"},
		DefaultStatus: http.StatusNoContent,
	}, func(ctx context.Context, input *Delete{{.Name}}Input) (*Delete{{.Name}}Output, error) {
		id, err := uuid.Parse(input.ID)
		if err != nil {
			return nil, huma.Error400BadRequest("invalid {{.Name}} ID format")
		}

		if err := act.Delete(ctx, id); err != nil {
			return nil, toHumaError(err)
		}

		return &Delete{{.Name}}Output{}, nil
	})
{{- if .Options.Auditable}}

	// List audit log entries for a {{.Name}} (AUDIT-02: exposes change history)
	huma.Register(api, huma.Operation{
		OperationID: "list{{.Name}}AuditLog",
		Method:      http.MethodGet,
		Path:        "/api/v1/{{kebab (plural .Name)}}/{id}/audit",
		Summary:     "List audit log for a {{.Name}}",
		Tags:        []string{"{{kebab .Name}}"},
	}, func(ctx context.Context, input *Get{{.Name}}Input) (*struct {
		Body struct {
			Data []map[string]any `json:"data"`
		}
	}, error) {
		id, err := uuid.Parse(input.ID)
		if err != nil {
			return nil, huma.Error400BadRequest("invalid {{.Name}} ID format")
		}

		// Access DB via GetDB() for direct audit_logs query (shared static table)
		db := act.(interface{ GetDB() actions.DB }).GetDB()
		rows, err := db.Query(ctx,
			`SELECT id, operation, changed_fields, created_by, created_at
			 FROM audit_logs
			 WHERE resource_type = $1 AND resource_id = $2
			 ORDER BY created_at DESC`,
			"{{snake .Name}}", id,
		)
		if err != nil {
			return nil, toHumaError(err)
		}
		defer rows.Close()

		var entries []map[string]any
		for rows.Next() {
			var entryID uuid.UUID
			var operation string
			var changedFields json.RawMessage
			var createdBy *uuid.UUID
			var createdAt time.Time
			if err := rows.Scan(&entryID, &operation, &changedFields, &createdBy, &createdAt); err != nil {
				continue
			}
			entries = append(entries, map[string]any{
				"id":             entryID,
				"operation":      operation,
				"changed_fields": changedFields,
				"created_by":     createdBy,
				"created_at":     createdAt,
			})
		}

		out := &struct {
			Body struct {
				Data []map[string]any `json:"data"`
			}
		}{}
		out.Body.Data = entries
		return out, nil
	})
{{- end}}
}
