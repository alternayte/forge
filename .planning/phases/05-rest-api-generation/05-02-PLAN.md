---
phase: 05-rest-api-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/api/middleware/auth.go
  - internal/api/middleware/cors.go
  - internal/api/middleware/ratelimit.go
  - internal/auth/token.go
  - internal/auth/apikey.go
  - internal/config/api.go
autonomous: true

must_haves:
  truths:
    - "Bearer token authentication validates opaque tokens from database with constant-time comparison"
    - "API key authentication validates prefixed keys (forg_live_, forg_test_) from separate database table"
    - "CORS middleware uses rs/cors with configurable origins from forge.toml"
    - "Rate limiting middleware uses go-limiter with per-client token bucket and tiered limits"
    - "All API endpoints require authentication by default"
  artifacts:
    - path: "internal/auth/token.go"
      provides: "Bearer token store interface and validation logic"
      contains: "TokenStore"
    - path: "internal/auth/apikey.go"
      provides: "API key store interface and validation with prefix checking"
      contains: "APIKeyStore"
    - path: "internal/api/middleware/auth.go"
      provides: "Huma authentication middleware checking Authorization header"
      contains: "AuthMiddleware"
    - path: "internal/api/middleware/cors.go"
      provides: "CORS middleware configuration from forge.toml settings"
      contains: "CORSMiddleware"
    - path: "internal/api/middleware/ratelimit.go"
      provides: "Rate limiting middleware with tiered limits"
      contains: "RateLimitMiddleware"
    - path: "internal/config/api.go"
      provides: "API configuration structs for CORS and rate limiting"
      contains: "APIConfig"
  key_links:
    - from: "internal/api/middleware/auth.go"
      to: "internal/auth/token.go"
      via: "TokenStore interface for bearer token lookup"
      pattern: "TokenStore"
    - from: "internal/api/middleware/auth.go"
      to: "internal/auth/apikey.go"
      via: "APIKeyStore interface for API key lookup"
      pattern: "APIKeyStore"
    - from: "internal/api/middleware/auth.go"
      to: "crypto/subtle"
      via: "Constant-time comparison for token validation"
      pattern: "subtle\\.ConstantTimeCompare"
---

<objective>
Create authentication infrastructure (bearer tokens + API keys) and middleware (CORS, rate limiting, auth) for the REST API.

Purpose: This plan builds the runtime middleware and auth layer that protects API endpoints. Bearer tokens and API keys are stored in database tables (not JWTs), validated with constant-time comparison to prevent timing attacks. CORS and rate limiting are configurable via forge.toml. These are framework-level runtime components (not generated code) — they ship with forge and run at request time.

Output: Auth store interfaces, auth middleware, CORS middleware, rate limiting middleware, and API configuration structs.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-rest-api-generation/05-CONTEXT.md
@.planning/phases/05-rest-api-generation/05-RESEARCH.md
@.planning/phases/04-action-layer-error-handling/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth store interfaces and authentication middleware</name>
  <files>
    internal/auth/token.go
    internal/auth/apikey.go
    internal/api/middleware/auth.go
  </files>
  <action>
Create authentication infrastructure with database-backed token/key stores and Huma middleware.

**internal/auth/token.go** — Bearer token store:
1. `Token` struct with fields: ID (uuid.UUID), Token (string), UserID (uuid.UUID), ExpiresAt (time.Time), CreatedAt (time.Time)
2. `TokenStore` interface with methods:
   - `GetByToken(ctx context.Context, token string) (*Token, error)` — lookup token by value
   - `Create(ctx context.Context, userID uuid.UUID, expiresAt time.Time) (*Token, error)` — create new token
   - `Delete(ctx context.Context, tokenID uuid.UUID) error` — revoke token
3. No implementation yet (that's database layer work) — just the interface and types
4. Use `crypto/rand` + `encoding/hex` for token generation helper: `GenerateToken() (string, error)` — generates 32 random bytes hex-encoded (64 chars)

**internal/auth/apikey.go** — API key store:
1. `APIKey` struct with fields: ID (uuid.UUID), Name (string), Key (string), Prefix (string - "forg_live_" or "forg_test_"), UserID (uuid.UUID), Scopes ([]string), ExpiresAt (*time.Time - nullable), RevokedAt (*time.Time - nullable), CreatedAt (time.Time)
2. `APIKeyStore` interface with methods:
   - `GetByKey(ctx context.Context, key string) (*APIKey, error)` — lookup key by value
   - `Create(ctx context.Context, userID uuid.UUID, name string, prefix string, scopes []string, expiresAt *time.Time) (*APIKey, error)` — create new API key
   - `Revoke(ctx context.Context, keyID uuid.UUID) error` — revoke key
3. Key generation helper: `GenerateAPIKey(prefix string) (string, error)` — generates `{prefix}{24 random hex chars}` (e.g., "forg_live_a1b2c3d4e5f6a1b2c3d4e5f6")
4. Key prefix validation: `ValidateKeyPrefix(key string) (prefix string, ok bool)` — checks for "forg_live_" or "forg_test_" prefix

**internal/api/middleware/auth.go** — Huma authentication middleware:
1. `AuthMiddleware` struct with TokenStore and APIKeyStore fields
2. `NewAuthMiddleware(tokenStore TokenStore, apiKeyStore APIKeyStore) *AuthMiddleware`
3. `Handle(ctx huma.Context, next func(huma.Context))` method implementing Huma middleware interface:
   - Extract Authorization header
   - If header starts with "Bearer ": validate as bearer token
   - If header starts with "forg_live_" or "forg_test_": validate as API key (sent directly in Authorization header per Stripe convention — also check X-API-Key header as alternate)
   - Missing header: return 401 via `huma.WriteErr`
   - Invalid format: return 401

4. `validateBearerToken` method:
   - Look up token via TokenStore.GetByToken
   - CRITICAL: Use `crypto/subtle.ConstantTimeCompare([]byte(provided), []byte(stored.Token))` for comparison
   - Check expiration (ExpiresAt.Before(time.Now()))
   - On success: set user_id in context via `huma.WithValue`
   - On failure: return 401

5. `validateAPIKey` method:
   - Validate prefix format via auth.ValidateKeyPrefix
   - Look up key via APIKeyStore.GetByKey
   - CRITICAL: Use `crypto/subtle.ConstantTimeCompare` for comparison
   - Check revocation (RevokedAt != nil) and expiration
   - On success: set api_key_id and api_key_scopes in context

6. Context key constants: `ContextKeyUserID`, `ContextKeyAPIKeyID`, `ContextKeyAPIKeyScopes` as typed context keys (not raw strings)

**Note:** Per user decision, "All API endpoints require authentication by default — public access is opt-in via schema annotation." The middleware runs on all routes; public opt-out is a Phase 7 concern (schema annotations).
  </action>
  <verify>
Run `go build ./internal/auth/` and `go build ./internal/api/middleware/` to confirm compilation. Run `go vet` on both packages. Verify `subtle.ConstantTimeCompare` is used (not `==`) by grepping the auth middleware file.
  </verify>
  <done>
TokenStore and APIKeyStore interfaces defined with proper types. Auth middleware validates bearer tokens and API keys with constant-time comparison. API key prefixes follow forg_live_/forg_test_ format per user decision. Context keys set for downstream handler use. All packages compile.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CORS and rate limiting middleware with forge.toml configuration</name>
  <files>
    internal/api/middleware/cors.go
    internal/api/middleware/ratelimit.go
    internal/config/api.go
  </files>
  <action>
Create CORS and rate limiting middleware with configuration from forge.toml.

**internal/config/api.go** — API configuration structs:
1. `APIConfig` struct with fields:
   - `RateLimit RateLimitConfig`
   - `CORS CORSConfig`

2. `RateLimitConfig` struct:
   - `Enabled bool` (default: true)
   - `Default TierConfig` — unauthenticated limits (default: 100 tokens/1 minute)
   - `Authenticated TierConfig` — authenticated user limits (default: 1000 tokens/1 minute)
   - `APIKey TierConfig` — API key limits (default: 5000 tokens/1 minute)

3. `TierConfig` struct:
   - `Tokens uint64` — requests per interval
   - `Interval string` — duration string (e.g., "1m", "1h")

4. `CORSConfig` struct:
   - `Enabled bool` (default: true)
   - `AllowedOrigins []string` — origin allowlist (empty = deny all in production)
   - `AllowedMethods []string` — default: ["GET", "POST", "PUT", "DELETE", "OPTIONS"]
   - `AllowedHeaders []string` — default: ["Accept", "Authorization", "Content-Type"]
   - `ExposedHeaders []string` — default: ["X-RateLimit-Limit", "X-RateLimit-Remaining", "X-RateLimit-Reset"]
   - `AllowCredentials bool` — default: true
   - `MaxAge int` — preflight cache seconds (default: 600)

5. `DefaultAPIConfig() APIConfig` — returns config with sane defaults

**internal/api/middleware/cors.go** — CORS middleware:
1. `CORSMiddleware(config config.CORSConfig) func(http.Handler) http.Handler`
2. Uses `github.com/rs/cors` library (per research recommendation)
3. Maps CORSConfig fields to cors.Options
4. If `config.Enabled == false`, return noop middleware (pass-through)
5. CRITICAL: Do NOT combine wildcard origins with credentials (per research pitfall). If AllowedOrigins contains "*" and AllowCredentials is true, log warning and disable credentials.

**internal/api/middleware/ratelimit.go** — Rate limiting middleware:
1. `RateLimitMiddleware(config config.RateLimitConfig) (func(http.Handler) http.Handler, error)`
2. Uses `github.com/sethvargo/go-limiter` with `memorystore` (per research recommendation)
3. Creates memory store with default tier limits
4. Uses IP-based key function via `httplimit.IPKeyFunc()`
5. If `config.Enabled == false`, return noop middleware
6. Parse interval strings using `time.ParseDuration`
7. Sets X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset headers (go-limiter does this automatically)
8. Returns 429 Too Many Requests when limit exceeded

**Note:** The tiered rate limiting (different limits for unauthenticated vs authenticated vs API key) requires knowing auth status. For Phase 5, use the default tier for all requests. Tiered enforcement (checking context for auth status) can be wired once the full server is assembled in Plan 03. Store the config for later use.

Install required dependencies:
```bash
go get -u github.com/rs/cors
go get -u github.com/sethvargo/go-limiter/httplimit
go get -u github.com/sethvargo/go-limiter/memorystore
```
  </action>
  <verify>
Run `go build ./internal/api/middleware/` and `go build ./internal/config/` to confirm compilation. Run `go vet` on both packages. Verify rs/cors and go-limiter appear in go.mod after `go get`.
  </verify>
  <done>
CORS middleware wraps rs/cors library with forge.toml configuration. Rate limiting middleware wraps go-limiter with token bucket per IP. APIConfig struct provides defaults for all settings. All packages compile. Dependencies added to go.mod.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/auth/` — clean compile
2. `go build ./internal/api/middleware/` — clean compile
3. `go build ./internal/config/` — clean compile
4. `go vet ./internal/...` — no issues
5. `grep -r "ConstantTimeCompare" internal/api/middleware/auth.go` — confirms timing-safe comparison
6. `grep -r "forg_live_\|forg_test_" internal/auth/apikey.go` — confirms prefix format
7. go.mod contains rs/cors and go-limiter dependencies
</verification>

<success_criteria>
- TokenStore interface defined with GetByToken, Create, Delete methods
- APIKeyStore interface defined with GetByKey, Create, Revoke methods
- API key format: forg_live_{random} / forg_test_{random} per user decision
- Auth middleware uses crypto/subtle.ConstantTimeCompare (NEVER ==) for all token/key comparisons
- Auth middleware checks Bearer tokens and API keys (forg_ prefix) from Authorization header
- All API endpoints require auth by default (middleware runs on all routes)
- CORS middleware uses rs/cors with configurable origins (no wildcard+credentials combination)
- Rate limit middleware uses go-limiter with token bucket per IP
- Configuration structs match forge.toml shape from research recommendations
</success_criteria>

<output>
After completion, create `.planning/phases/05-rest-api-generation/05-02-SUMMARY.md`
</output>
