---
phase: 07-advanced-data-features
plan: 04
type: execute
wave: 3
depends_on: ["07-01"]
files_modified:
  - internal/generator/templates/actions.go.tmpl
  - internal/auth/context.go
autonomous: true
requirements:
  - AUTH-05
  - AUTH-06

must_haves:
  truths:
    - "Generated actions check CRUD-level permissions before executing operations — returns 403 for denied roles"
    - "Generated actions strip invisible fields from API responses based on current user's role"
    - "Permission checks use role from context, compared against schema-defined allowed roles"
    - "Invisible fields are completely omitted from response (key not present in JSON)"
  artifacts:
    - path: "internal/generator/templates/actions.go.tmpl"
      provides: "Permission checks at top of CRUD methods; roleFilter function for field visibility"
      contains: "checkPermission"
    - path: "internal/auth/context.go"
      provides: "UserFromContext and RoleFromContext helpers for reading auth context"
      contains: "RoleFromContext"
  key_links:
    - from: "internal/generator/templates/actions.go.tmpl"
      to: "internal/auth/context.go"
      via: "Generated code calls RoleFromContext to get current user role for permission checks"
      pattern: "RoleFromContext"
    - from: "internal/generator/templates/actions.go.tmpl"
      to: "internal/generator/funcmap.go (owned by Plan 01)"
      via: "Template uses hasPermission/permissionRoles funcmap helpers registered by Plan 01"
      pattern: "hasPermission"
---

<objective>
Implement CRUD-level permission checks and field-level visibility stripping in generated actions.

Purpose: AUTH-05 requires that generated actions enforce CRUD permissions based on the user's role. AUTH-06 requires that invisible fields (based on Visibility modifier) are stripped from responses. Together these enable role-based access control at both the operation and field level.

Output: Updated actions.go.tmpl with permission guards and field visibility filtering. New internal/auth/context.go with user/role context helpers. Funcmap helpers verified present (owned by Plan 01, not modified here).
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-RESEARCH.md
@.planning/phases/07-advanced-data-features/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth context helpers and add permission checks to actions</name>
  <files>
    internal/auth/context.go
    internal/generator/templates/actions.go.tmpl
  </files>
  <action>
    1. Create `internal/auth/context.go` (NEW file) in the existing internal/auth/ package:

       Define private context key types for user ID and role:
       ```go
       type userContextKey struct{}
       type roleContextKey struct{}
       ```

       Add context helpers:
       - `WithUserRole(ctx context.Context, userID uuid.UUID, role string) context.Context` — stores both user ID and role in context using two separate WithValue calls
       - `UserFromContext(ctx context.Context) uuid.UUID` — returns user UUID from context (uuid.Nil if not set)
       - `RoleFromContext(ctx context.Context) string` — returns role string from context (empty string if not set)

       Imports: `context`, `github.com/google/uuid`

    2. In `actions.go.tmpl`, add a `checkPermission` helper function AFTER the Default implementation methods, guarded by `{{- if hasAnyPermission .Options}}`:

       ```
       {{- if hasAnyPermission .Options}}
       // checkPermission verifies the current user's role is in the allowed roles list.
       // Returns a Forbidden error if the role is not permitted.
       func checkPermission(ctx context.Context, allowedRoles ...string) error {
           role := forgeauth.RoleFromContext(ctx)
           for _, r := range allowedRoles {
               if r == role {
                   return nil
               }
           }
           return errors.Forbidden("insufficient permissions")
       }
       {{- end}}
       ```

       Add conditional import for forgeauth:
       ```
       {{- if or (hasAnyPermission .Options) (hasAnyVisibility .Fields)}}
       forgeauth "github.com/forge-framework/forge/internal/auth"
       {{- end}}
       ```

    3. Add permission check at the TOP of each CRUD method body in actions.go.tmpl. For each method (List, Get, Create, Update, Delete), add:

       For List:
       ```
       {{- if hasPermission .Options "list"}}
       if err := checkPermission(ctx, {{permissionRoles .Options "list"}}); err != nil {
           return nil, 0, err
       }
       {{- end}}
       ```

       For Get:
       ```
       {{- if hasPermission .Options "read"}}
       if err := checkPermission(ctx, {{permissionRoles .Options "read"}}); err != nil {
           return nil, err
       }
       {{- end}}
       ```

       For Create:
       ```
       {{- if hasPermission .Options "create"}}
       if err := checkPermission(ctx, {{permissionRoles .Options "create"}}); err != nil {
           return nil, err
       }
       {{- end}}
       ```

       For Update:
       ```
       {{- if hasPermission .Options "update"}}
       if err := checkPermission(ctx, {{permissionRoles .Options "update"}}); err != nil {
           return nil, err
       }
       {{- end}}
       ```

       For Delete:
       ```
       {{- if hasPermission .Options "delete"}}
       if err := checkPermission(ctx, {{permissionRoles .Options "delete"}}); err != nil {
           return err
       }
       {{- end}}
       ```

       For Restore (if SoftDelete):
       ```
       {{- if hasPermission .Options "delete"}}
       if err := checkPermission(ctx, {{permissionRoles .Options "delete"}}); err != nil {
           return nil, err
       }
       {{- end}}
       ```
       (Restore uses "delete" permission since it's the inverse operation.)

       The `permissionRoles` funcmap helper (from Plan 01) returns a string like `"admin", "editor"` which is directly embedded as function arguments.

    User decision compliance:
    - "Roles defined as schema-level constants — compile-time known, generated into permission checks" — roles are string literals in generated code
    - "Permission denial is contextual: API returns 403 Forbidden" — checkPermission returns errors.Forbidden
    - "Permissions are role-only, not owner-aware" — only role is checked, no ownership logic
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/auth/... && go build ./internal/generator/...` — both compile.
  </verify>
  <done>
    internal/auth/context.go provides UserFromContext and RoleFromContext. actions.go.tmpl has checkPermission function and conditional permission checks at the top of every CRUD method. Permission checks use role from context against schema-defined allowed roles. 403 Forbidden returned for unauthorized access.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add field-level visibility stripping to actions</name>
  <files>
    internal/generator/templates/actions.go.tmpl
  </files>
  <action>
    1. In `actions.go.tmpl`, add a `roleFilter` method on Default{{.Name}}Actions that strips invisible fields. Guarded by `{{- if hasAnyVisibility .Fields}}`:

       ```
       {{- if hasAnyVisibility .Fields}}
       // roleFilter returns a map representation of the model with invisible fields omitted
       // based on the current user's role. Fields with Visibility("role") are only included
       // when the user's role matches. Fields without Visibility are always included.
       // Per user decision: invisible fields omitted entirely (key doesn't appear in JSON).
       func (a *Default{{.Name}}Actions) roleFilter(role string, item models.{{.Name}}) map[string]any {
           result := map[string]any{
               "id": item.ID,
               {{- range .Fields}}
               {{- if not (isIDField .)}}
               {{- if not (hasModifier .Modifiers "Visibility")}}
               "{{snake .Name}}": item.{{.Name}},
               {{- end}}
               {{- end}}
               {{- end}}
               {{- if .HasTimestamps}}
               "created_at": item.CreatedAt,
               "updated_at": item.UpdatedAt,
               {{- end}}
               {{- if .Options.SoftDelete}}
               "deleted_at": item.DeletedAt,
               {{- end}}
           }
           {{- range .Fields}}
           {{- if and (not (isIDField .)) (hasModifier .Modifiers "Visibility")}}
           // Field {{.Name}} visible only for role "{{getModifierValue .Modifiers "Visibility"}}"
           if role == "" || role == "{{getModifierValue .Modifiers "Visibility"}}" {
               result["{{snake .Name}}"] = item.{{.Name}}
           }
           {{- end}}
           {{- end}}
           return result
       }
       {{- end}}
       ```

       The `role == ""` check follows the Phase 6 convention: empty role means no auth context (admin/dev views), so all fields are visible.

    2. Add a `RoleFilterList` convenience method for filtering a slice:
       ```
       {{- if hasAnyVisibility .Fields}}
       // RoleFilterList applies roleFilter to a slice of items.
       func (a *Default{{.Name}}Actions) RoleFilterList(role string, items []models.{{.Name}}) []map[string]any {
           result := make([]map[string]any, len(items))
           for i, item := range items {
               result[i] = a.roleFilter(role, item)
           }
           return result
       }
       {{- end}}
       ```

    3. In the actions interface, add the roleFilter methods to the interface when visibility fields exist:
       ```
       {{- if hasAnyVisibility .Fields}}
       // RoleFilterList strips invisible fields from a list of items based on user role.
       RoleFilterList(role string, items []models.{{.Name}}) []map[string]any
       {{- end}}
       ```

       Note: roleFilter is lowercase (unexported helper). RoleFilterList is exported for handler use. API/HTML handlers call RoleFilterList after fetching data, passing the role from context. This keeps the action layer responsible for field-level access control.

    4. VERIFICATION ONLY (do NOT modify funcmap.go — it is owned by Plan 01): Verify that Plan 01 has already registered these funcmap helpers in `funcmap.go`: `hasAnyVisibility`, `hasPermission`, `permissionRoles`, and `hasAnyPermission`. Run `go build ./internal/generator/...` to confirm the template compiles with these helpers available. If any helper is missing, that is a Plan 01 execution failure — do not add them here, flag it as a blocker.

    User decision compliance:
    - "Invisible fields omitted from response entirely (key doesn't appear in API JSON or HTML template)" — roleFilter returns map[string]any without invisible keys
    - "Response shape changes per role" — different roles see different field sets
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Review actions.go.tmpl for roleFilter and RoleFilterList methods. Review funcmap.go for all permission/visibility helpers.
  </verify>
  <done>
    roleFilter method omits fields with Visibility modifier when user role doesn't match. RoleFilterList method filters a slice of items. Permission and visibility funcmap helpers verified present (from Plan 01). API handlers can call RoleFilterList to strip invisible fields before returning responses.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/auth/...` compiles (context.go)
2. `go build ./internal/generator/...` compiles (template + funcmap changes)
3. actions.go.tmpl has checkPermission function inside hasAnyPermission guard
4. Each CRUD method has conditional permission check at top
5. roleFilter method strips fields based on Visibility modifier and user role
6. RoleFilterList method handles list responses
7. funcmap has hasPermission, permissionRoles, hasAnyVisibility, hasAnyPermission (verified present from Plan 01, not modified by this plan)
</verification>

<success_criteria>
Permission checks guard every CRUD operation based on schema-defined roles. Field-level visibility filtering strips invisible fields from responses. Both features are conditionally generated — resources without permissions or visibility modifiers produce identical code to before. The auth context helpers provide clean user/role extraction from context.
</success_criteria>

<output>
After completion, create `.planning/phases/07-advanced-data-features/07-04-SUMMARY.md`
</output>
