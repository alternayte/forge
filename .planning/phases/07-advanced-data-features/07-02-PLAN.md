---
phase: 07-advanced-data-features
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/generator/templates/queries.go.tmpl
  - internal/generator/templates/actions.go.tmpl
  - internal/generator/templates/atlas_schema.hcl.tmpl
autonomous: true
requirements:
  - DATA-06
  - DATA-07
  - DATA-08
  - DATA-09

must_haves:
  truths:
    - "When SoftDelete is true, generated List/Get queries include WHERE deleted_at IS NULL by default"
    - "WithTrashed option removes the deleted_at filter; OnlyTrashed replaces it with IS NOT NULL"
    - "When SoftDelete is true and a field has Unique modifier, Atlas generates a partial unique index with WHERE deleted_at IS NULL"
    - "Generated Delete method sets deleted_at = NOW() instead of DELETE FROM"
    - "Generated Restore method sets deleted_at = NULL for a soft-deleted record"
  artifacts:
    - path: "internal/generator/templates/queries.go.tmpl"
      provides: "ActiveMod, OnlyTrashedMod soft delete filter methods"
      contains: "ActiveMod"
    - path: "internal/generator/templates/actions.go.tmpl"
      provides: "Soft delete in Delete method, Restore method, WithTrashed/OnlyTrashed List options"
      contains: "Restore"
    - path: "internal/generator/templates/atlas_schema.hcl.tmpl"
      provides: "Partial unique index with where = deleted_at IS NULL"
      contains: "deleted_at IS NULL"
  key_links:
    - from: "internal/generator/templates/actions.go.tmpl"
      to: "internal/generator/templates/queries.go.tmpl"
      via: "Actions List method calls ActiveMod() from queries package when SoftDelete enabled"
      pattern: "ActiveMod"
    - from: "internal/generator/templates/atlas_schema.hcl.tmpl"
      to: "ResourceOptionsIR.SoftDelete"
      via: "Conditional partial index generation when both SoftDelete and Unique are true"
      pattern: "SoftDelete"
---

<objective>
Implement soft delete behavior across queries, actions, and Atlas templates so that SoftDelete-enabled resources automatically exclude deleted records, support WithTrashed/OnlyTrashed scopes, use partial unique indexes, and provide a Restore method.

Purpose: DATA-06 through DATA-09 require that generated code treats soft-deleted records correctly — invisible by default, restorable, and properly indexed.

Output: Updated queries.go.tmpl, actions.go.tmpl, and atlas_schema.hcl.tmpl with conditional soft delete logic.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-RESEARCH.md
@.planning/phases/07-advanced-data-features/07-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add soft delete query mods and partial unique indexes</name>
  <files>
    internal/generator/templates/queries.go.tmpl
    internal/generator/templates/atlas_schema.hcl.tmpl
  </files>
  <action>
    1. In `queries.go.tmpl`, add soft delete filter methods AFTER the existing SortMod function, guarded by `{{- if .Options.SoftDelete}}`:

       a. `ActiveMod()` — returns `sm.Where(psql.Quote("deleted_at").IsNull())`. This is applied by default in List and Get queries.

       b. `OnlyTrashedMod()` — returns `sm.Where(psql.Quote("deleted_at").IsNotNull())`. For admin views showing only soft-deleted records.

       These methods should be on the `{{$resource}}Filters` receiver to stay consistent with existing filter methods.

       Example:
       ```
       {{- if .Options.SoftDelete}}

       // ActiveMod returns a query mod that excludes soft-deleted records.
       // Applied by default to List and Get queries.
       func (f {{$resource}}Filters) ActiveMod() sm.QueryMod[*psql.SelectQuery] {
           return sm.Where(psql.Quote("deleted_at").IsNull())
       }

       // OnlyTrashedMod returns a query mod that shows only soft-deleted records.
       func (f {{$resource}}Filters) OnlyTrashedMod() sm.QueryMod[*psql.SelectQuery] {
           return sm.Where(psql.Quote("deleted_at").IsNotNull())
       }
       {{- end}}
       ```

    2. In `atlas_schema.hcl.tmpl`, modify the existing unique index generation. Currently the template generates a standard unique index when a field has the Unique modifier. When SoftDelete is also true, it must generate a partial unique index instead.

       Replace the existing unique index block:
       ```
       {{if hasModifier .Modifiers "Unique"}}
       index "{{plural (snake $resourceName)}}_{{snake .Name}}_unique" {
         columns = [column.{{snake .Name}}]
         unique  = true
       }
       {{end}}
       ```

       With:
       ```
       {{if hasModifier .Modifiers "Unique"}}
       {{if $.Options.SoftDelete}}
       index "{{plural (snake $resourceName)}}_{{snake .Name}}_unique_active" {
         columns = [column.{{snake .Name}}]
         unique  = true
         where   = "deleted_at IS NULL"
       }
       {{else}}
       index "{{plural (snake $resourceName)}}_{{snake .Name}}_unique" {
         columns = [column.{{snake .Name}}]
         unique  = true
       }
       {{end}}
       {{end}}
       ```

       This ensures: SoftDelete + Unique = partial index (DATA-08); non-SoftDelete + Unique = standard unique index (no regression).
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Manually inspect the template changes to confirm conditional blocks are syntactically correct.
  </verify>
  <done>
    queries.go.tmpl has ActiveMod and OnlyTrashedMod methods guarded by SoftDelete. atlas_schema.hcl.tmpl generates partial unique index (WHERE deleted_at IS NULL) when SoftDelete + Unique, and standard unique index otherwise.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add soft delete behavior to actions (Delete as soft-delete, Restore method)</name>
  <files>
    internal/generator/templates/actions.go.tmpl
  </files>
  <action>
    1. Modify the existing `Delete` method in `actions.go.tmpl`. When SoftDelete is enabled, the Delete method should UPDATE the record to set deleted_at = NOW() instead of a hard DELETE. User decision: "No hard delete — soft delete is final state, records stay in DB permanently."

       Wrap the existing Delete method body with a conditional:
       ```
       {{- if .Options.SoftDelete}}
       // Soft delete: set deleted_at timestamp instead of removing the record.
       // Per design: no hard delete — soft delete is final state. Developer uses raw SQL if needed.
       _, err := a.DB.Exec(ctx,
           `UPDATE {{plural (snake .Name)}} SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL`,
           id,
       )
       if err != nil {
           return errors.InternalError("failed to soft-delete {{.Name}}")
       }
       return nil
       {{- else}}
       // Hard delete
       // TODO: Execute Bob delete query
       _ = id
       return errors.NotFound("{{.Name}}", id.String())
       {{- end}}
       ```

    2. Add a `Restore` method to the `{{.Name}}Actions` interface and `Default{{.Name}}Actions` implementation, guarded by `{{- if .Options.SoftDelete}}`:

       Interface addition (after Delete in the interface):
       ```
       {{- if .Options.SoftDelete}}
       // Restore restores a soft-deleted {{.Name}} by clearing its deleted_at timestamp.
       Restore(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error)
       {{- end}}
       ```

       Implementation:
       ```
       {{- if .Options.SoftDelete}}
       // Restore restores a soft-deleted {{.Name}} by clearing deleted_at.
       func (a *Default{{.Name}}Actions) Restore(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error) {
           result, err := a.DB.Exec(ctx,
               `UPDATE {{plural (snake .Name)}} SET deleted_at = NULL WHERE id = $1 AND deleted_at IS NOT NULL`,
               id,
           )
           if err != nil {
               return nil, errors.InternalError("failed to restore {{.Name}}")
           }
           if result.RowsAffected() == 0 {
               return nil, errors.NotFound("{{.Name}}", id.String())
           }
           return a.Get(ctx, id)
       }
       {{- end}}
       ```

    3. Modify the `List` method to apply ActiveMod by default when SoftDelete is enabled. Add after the filterMods line:
       ```
       {{- if .Options.SoftDelete}}
       // Exclude soft-deleted records by default (DATA-06)
       filterMods = append(filterMods, queries.{{.Name}}Filters{}.ActiveMod())
       {{- end}}
       ```

    4. Modify the `Get` method to include a deleted_at IS NULL check when SoftDelete is enabled. This prevents fetching soft-deleted records via direct ID lookup. The TODO placeholder for Get should include:
       ```
       {{- if .Options.SoftDelete}}
       // Note: Get excludes soft-deleted records. Use a custom action override with
       // OnlyTrashedMod or no ActiveMod filter for admin restore views.
       {{- end}}
       ```

    User decision compliance:
    - No cascade on soft delete (no related record deletion)
    - No hard delete (no DELETE FROM statement generated)
    - Only admin role can see and restore (enforced by permissions in Plan 04, not here)
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Review actions.go.tmpl to confirm: Delete uses UPDATE...SET deleted_at when SoftDelete, Restore method exists inside SoftDelete guard, List prepends ActiveMod.
  </verify>
  <done>
    Delete method uses UPDATE SET deleted_at = NOW() when SoftDelete is true. Restore method clears deleted_at and returns the restored record. List method prepends ActiveMod() filter when SoftDelete is true. No hard DELETE statement generated for SoftDelete resources. No cascade logic generated (per user decision).
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/generator/...` compiles
2. queries.go.tmpl has ActiveMod and OnlyTrashedMod inside `{{if .Options.SoftDelete}}`
3. atlas_schema.hcl.tmpl generates `where = "deleted_at IS NULL"` for Unique + SoftDelete
4. actions.go.tmpl Delete does `UPDATE ... SET deleted_at = NOW()` for SoftDelete
5. actions.go.tmpl has Restore method inside SoftDelete guard
6. No hard DELETE generated for SoftDelete resources
</verification>

<success_criteria>
Soft delete feature is fully wired: queries filter out deleted records by default, actions use UPDATE instead of DELETE, Restore is available, and Atlas generates partial unique indexes. WithTrashed/OnlyTrashed query scopes are available via query mods.
</success_criteria>

<output>
After completion, create `.planning/phases/07-advanced-data-features/07-02-SUMMARY.md`
</output>
