// Code generated by forge generate. DO NOT EDIT.

package queries

import (
	"encoding/base64"
	"encoding/json"
	"fmt"

	"github.com/google/uuid"
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"
)

// PageInfo contains pagination metadata for both offset and cursor-based pagination.
type PageInfo struct {
	HasNextPage bool    `json:"has_next_page"`
	HasPrevPage bool    `json:"has_prev_page"`
	StartCursor *string `json:"start_cursor,omitempty"`
	EndCursor   *string `json:"end_cursor,omitempty"`
	TotalCount  *int64  `json:"total_count,omitempty"` // Only populated for offset pagination
}

// cursor represents the position in a paginated result set.
// It is unexported and encoded as base64(json) for opaque tokens.
type cursor struct {
	ID        uuid.UUID   `json:"id"`
	SortValue interface{} `json:"sort_value"` // Value of the sort column at cursor position
	SortField string      `json:"sort_field"` // Which field was sorted
}

// EncodeCursor creates an opaque base64-encoded cursor from ID and sort field values.
func EncodeCursor(id uuid.UUID, sortField string, sortValue interface{}) (string, error) {
	c := cursor{
		ID:        id,
		SortValue: sortValue,
		SortField: sortField,
	}
	jsonBytes, err := json.Marshal(c)
	if err != nil {
		return "", fmt.Errorf("marshal cursor: %w", err)
	}
	return base64.URLEncoding.EncodeToString(jsonBytes), nil
}

// DecodeCursor decodes a base64-encoded cursor back to its components.
func DecodeCursor(encoded string) (*cursor, error) {
	jsonBytes, err := base64.URLEncoding.DecodeString(encoded)
	if err != nil {
		return nil, fmt.Errorf("decode cursor: %w", err)
	}
	var c cursor
	if err := json.Unmarshal(jsonBytes, &c); err != nil {
		return nil, fmt.Errorf("unmarshal cursor: %w", err)
	}
	return &c, nil
}

// OffsetPaginationMods returns Bob query mods for offset-based pagination.
// Page numbers start at 1. PageSize is capped at 100.
func OffsetPaginationMods(page, pageSize int) []bob.Mod[*dialect.SelectQuery] {
	// Validate and cap parameters
	if page < 1 {
		page = 1
	}
	if pageSize < 1 {
		pageSize = 10
	}
	if pageSize > 100 {
		pageSize = 100
	}

	offset := (page - 1) * pageSize

	return []bob.Mod[*dialect.SelectQuery]{
		sm.Limit(int64(pageSize)),
		sm.Offset(int64(offset)),
	}
}

// CursorPaginationMods returns Bob query mods for cursor-based pagination.
// Fetches pageSize + 1 records to detect if there's a next page.
// If cursor is nil, starts from the beginning.
// sortDir should be "asc" or "desc" to match the order of the query.
func CursorPaginationMods(cur *cursor, pageSize int, sortDir string) []bob.Mod[*dialect.SelectQuery] {
	// Validate and cap pageSize
	if pageSize < 1 {
		pageSize = 10
	}
	if pageSize > 100 {
		pageSize = 100
	}

	mods := []bob.Mod[*dialect.SelectQuery]{
		sm.Limit(int64(pageSize + 1)), // Fetch one extra to detect hasNext
	}

	// If cursor is provided, add WHERE clause for row value comparison
	if cur != nil {
		// Build tuple comparison: (sort_field, id) > (cursor.SortValue, cursor.ID) for ASC
		// or (sort_field, id) < (cursor.SortValue, cursor.ID) for DESC
		operator := ">"
		if sortDir == "desc" {
			operator = "<"
		}

		// Use raw SQL for tuple comparison
		whereClause := fmt.Sprintf("(%s, id) %s ($1, $2)", cur.SortField, operator)
		mods = append(mods, sm.Where(psql.Raw(whereClause, cur.SortValue, cur.ID)))
	}

	return mods
}
