---
phase: 01-foundation-schema-dsl
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/parser/ir.go
  - internal/errors/diagnostic.go
  - internal/errors/formatter.go
  - internal/errors/codes.go
  - internal/ui/styles.go
autonomous: true

must_haves:
  truths:
    - "Parser errors display Rust-style rich diagnostics with file:line, source snippet, underline, and suggestion"
    - "All errors in a parse pass are collected and displayed together (not one-at-a-time)"
    - "Each error type has a unique error code with reference link"
    - "CLI output uses consistent Cargo-like styled formatting with colors and icons"
  artifacts:
    - path: "internal/parser/ir.go"
      provides: "Intermediate representation types for parsed schemas"
      contains: "type ResourceIR struct"
    - path: "internal/errors/diagnostic.go"
      provides: "Diagnostic error type with source position and hints"
      contains: "type Diagnostic struct"
    - path: "internal/errors/formatter.go"
      provides: "Rust-style error rendering with source context"
      contains: "func (d *Diagnostic) Format() string"
    - path: "internal/errors/codes.go"
      provides: "Error code registry with descriptions and help links"
      contains: "type ErrorCode string"
    - path: "internal/ui/styles.go"
      provides: "Lipgloss styles for CLI output"
      contains: "lipgloss.NewStyle()"
  key_links:
    - from: "internal/errors/formatter.go"
      to: "internal/ui/styles.go"
      via: "Uses Lipgloss styles for colored error output"
      pattern: "ui\\..*Style"
    - from: "internal/errors/diagnostic.go"
      to: "internal/errors/codes.go"
      via: "Each Diagnostic references an ErrorCode"
      pattern: "Code\\s+ErrorCode"
---

<objective>
Create the intermediate representation (IR) types that the parser produces, the rich error diagnostic system, and the terminal UI styling. These are the data structures and formatting tools that the parser (Plan 03) and CLI (Plan 04) depend on.

Purpose: The IR is the bridge between go/ast parsing and code generation. The error system delivers the "Rust-style rich errors" the user specified. The UI styles ensure consistent polished output across all CLI commands.

Output: `internal/parser/ir.go`, `internal/errors/` package, `internal/ui/styles.go`
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-schema-dsl/01-CONTEXT.md
@.planning/phases/01-foundation-schema-dsl/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Define intermediate representation (IR) types for parsed schemas</name>
  <files>internal/parser/ir.go</files>
  <action>
Create `internal/parser/ir.go` with domain-model IR types (not AST mirrors). These types are what the parser produces and what the code generator (Phase 2) consumes.

Define the following structs:

`ResourceIR` — top-level parsed resource:
- `Name string` — resource name (e.g., "Product")
- `Fields []FieldIR` — parsed fields
- `Relationships []RelationshipIR` — parsed relationships
- `Options ResourceOptionsIR` — parsed options
- `HasTimestamps bool`
- `SourceFile string` — original file path for error reporting
- `SourceLine int` — line of schema.Define() call

`FieldIR` — a parsed field:
- `Name string` — field name
- `Type string` — field type as string (e.g., "String", "UUID", "Enum")
- `Modifiers []ModifierIR` — applied modifiers
- `EnumValues []string` — for Enum fields, the allowed values
- `SourceLine int` — line number in source

`ModifierIR` — a parsed modifier:
- `Type string` — modifier name (e.g., "Required", "MaxLen")
- `Value interface{}` — modifier argument if any (int for MaxLen, string for Default, etc.)
- `SourceLine int`

`RelationshipIR` — a parsed relationship:
- `Name string` — relationship name
- `Type string` — "BelongsTo", "HasMany", "HasOne", "ManyToMany"
- `Table string` — related table name
- `OnDelete string` — cascade action (empty string = default)
- `Optional bool`
- `SourceLine int`

`ResourceOptionsIR` — resource-level options:
- `SoftDelete bool`
- `Auditable bool`
- `TenantScoped bool`
- `Searchable bool`

`ParseResult` — output of parsing a directory:
- `Resources []ResourceIR` — all parsed resources
- `Errors []error` — all parse errors collected (not just first one)

The IR uses simple string types (not enums) so it's decoupled from the schema package. This makes it consumable by code generation without importing internal/schema.
  </action>
  <verify>Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/parser/` — must compile with zero errors.</verify>
  <done>IR types defined as domain model structs. ParseResult supports multiple errors for single-pass collection. All fields include SourceLine for error reporting. IR is decoupled from schema package (uses strings, not schema enums).</done>
</task>

<task type="auto">
  <name>Task 2: Build rich error diagnostic system with Rust-style formatting</name>
  <files>
    internal/errors/diagnostic.go
    internal/errors/formatter.go
    internal/errors/codes.go
    internal/errors/errors_test.go
  </files>
  <action>
Add Lipgloss dependency: `go get github.com/charmbracelet/lipgloss@latest`

Create `internal/errors/codes.go`:
- Define `ErrorCode` type (string, e.g., "E001").
- Define error code constants grouped by concern:
  - Parser errors E0xx: `ErrDynamicValue ErrorCode = "E001"`, `ErrUnsupportedType ErrorCode = "E002"`, `ErrInvalidFieldName ErrorCode = "E003"`, `ErrMissingArgument ErrorCode = "E004"`, `ErrInvalidModifierValue ErrorCode = "E005"`
  - Schema validation E1xx: `ErrDuplicateField ErrorCode = "E100"`, `ErrInvalidEnumDefault ErrorCode = "E101"`, `ErrMissingPrimaryKey ErrorCode = "E102"`
- Define `ErrorInfo` struct: `Code ErrorCode`, `Title string`, `HelpURL string`.
- Define `Registry` as `map[ErrorCode]ErrorInfo` with all codes populated.
- `Lookup(code ErrorCode) ErrorInfo` function.

Per user decision: Each error type includes a reference link or error code (e.g., "See: forge.dev/errors/E001" or `forge help schema-errors`). Use format `forge help E001` for now (CLI-based, no web dependency).

Create `internal/errors/diagnostic.go`:
- `Diagnostic` struct:
  - `Code ErrorCode`
  - `Message string` — human-readable error description
  - `Hint string` — suggestion for fixing (e.g., "use a constant or literal instead")
  - `File string` — source file path
  - `Line int` — 1-based line number
  - `Column int` — 1-based column number
  - `SourceLine string` — the actual line of source code
  - `UnderlineStart int` — column where underline begins (0-based within SourceLine)
  - `UnderlineLen int` — length of underline (number of chars to underline)
- `Diagnostic` implements `error` interface.
- `DiagnosticSet` struct: `Diagnostics []Diagnostic`, `HasErrors() bool`, `Error() string` (implements error), `Count() int`.
- `NewDiagnostic(code ErrorCode, msg string) *DiagnosticBuilder` with fluent builder: `.File(f)`, `.Line(l)`, `.Column(c)`, `.SourceLine(s)`, `.Underline(start, len)`, `.Hint(h)`, `.Build() Diagnostic`.

Create `internal/errors/formatter.go`:
- `Format(d Diagnostic) string` — renders a single diagnostic in Rust-style format.
- `FormatAll(ds DiagnosticSet) string` — renders all diagnostics with separator.
- Format output structure (per user decision — Rust-style rich errors):
  ```
  error[E001]: schema values must use literal values for static analysis
    --> resources/product/schema.go:12:34
     |
  12 |     schema.String("Title").MaxLen(maxLen),
     |                                   ^^^^^^
     |
     = hint: Forge schemas must use literal values for static analysis.
             Found variable 'maxLen' — use a constant or literal instead.
     = help: Run `forge help E001` for more information
  ```
- Use Lipgloss for colors: red for "error", blue for file position arrow, red for underline caret, cyan for "hint", dim for help line.
- When terminal doesn't support colors, degrade gracefully (Lipgloss handles this automatically).

Per user decision: Dynamic value errors explain the constraint — "Forge schemas must use literal values for static analysis. Found variable 'maxLen' — use a constant or literal instead." Teach the why, not just the what.

Create `internal/errors/errors_test.go`:
- Test that Format() produces expected output structure (check for key substrings: error code, file:line:col, source line, underline, hint).
- Test DiagnosticSet collects multiple errors.
- Test error code Lookup returns correct info.
  </action>
  <verify>Run `cd /Users/nathananderson-tennant/Development/forge-go && go test ./internal/errors/` — all tests pass. Run `go build ./internal/errors/` — compiles.</verify>
  <done>Diagnostic type captures all error context (file, line, column, source, underline). Formatter produces Rust-style output with colors via Lipgloss. Error codes registry maps codes to titles and help commands. DiagnosticSet collects all errors for single-pass reporting. Tests verify formatting output structure.</done>
</task>

<task type="auto">
  <name>Task 3: Create terminal UI styles for CLI output</name>
  <files>internal/ui/styles.go</files>
  <action>
Create `internal/ui/styles.go` with Lipgloss style definitions for consistent CLI output across all commands.

Define exported style variables:
- `SuccessIcon` — green checkmark: `lipgloss.NewStyle().Foreground(lipgloss.Color("10")).Bold(true).Render("✓")`
- `ErrorIcon` — red cross: `lipgloss.NewStyle().Foreground(lipgloss.Color("9")).Bold(true).Render("✗")`
- `WarnIcon` — yellow warning: `lipgloss.NewStyle().Foreground(lipgloss.Color("11")).Bold(true).Render("!")`
- `InfoIcon` — blue info: `lipgloss.NewStyle().Foreground(lipgloss.Color("12")).Bold(true).Render("i")`

Define reusable style objects:
- `HeaderStyle` — bold, used for section headers (e.g., "Compiling resources...")
- `SuccessStyle` — green foreground
- `ErrorStyle` — red foreground, bold
- `WarnStyle` — yellow foreground
- `DimStyle` — dim/faint for secondary info
- `BoldStyle` — just bold
- `FilePathStyle` — cyan, for file paths
- `CommandStyle` — bold cyan, for CLI commands in help text

Define output helper functions:
- `Success(msg string) string` — renders "  ✓ {msg}" in green
- `Error(msg string) string` — renders "  ✗ {msg}" in red
- `Warn(msg string) string` — renders "  ! {msg}" in yellow
- `Info(msg string) string` — renders "  i {msg}" in blue
- `Header(msg string) string` — renders bold header
- `Grouped(header string, items []string) string` — renders a header followed by indented items (for Cargo-style grouped output)

Per user decision: Polished styled output — colors, icons (checkmarks/crosses), grouped by category — similar feel to `cargo build` or `next dev`.
  </action>
  <verify>Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/ui/` — must compile with zero errors.</verify>
  <done>UI styles package provides consistent Lipgloss-based styling. Success/Error/Warn/Info helpers produce formatted output with icons. Grouped() function enables Cargo-style category output. All styles degrade gracefully on terminals without color support.</done>
</task>

</tasks>

<verification>
- `go build ./internal/parser/` compiles (IR types)
- `go build ./internal/errors/` compiles (error system)
- `go test ./internal/errors/` passes (formatter and codes tests)
- `go build ./internal/ui/` compiles (UI styles)
- Diagnostic Format() output matches Rust-style pattern: error[CODE], file:line:col, source, underline, hint
- Error codes are registered with descriptions and help links
- UI styles use Lipgloss with icons and color categories
</verification>

<success_criteria>
The IR types can represent any schema that Plan 01's DSL can express. The error diagnostic system formats errors in Rust-style with file positions, source context, underlines, hints, and error codes. The UI styles provide a consistent Cargo-like visual language for CLI output.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-schema-dsl/01-02-SUMMARY.md`
</output>
