---
phase: 02-code-generation-engine
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/generator/generator.go
  - internal/generator/formatting.go
  - internal/generator/models.go
  - internal/generator/templates.go
  - internal/generator/templates/model.go.tmpl
  - internal/generator/funcmap.go
autonomous: true

must_haves:
  truths:
    - "Generator infrastructure can render a Go template from IR data and produce formatted, import-managed Go source"
    - "Running model generation on a ResourceIR produces compilable Go file with Resource, ResourceCreate, ResourceUpdate, ResourceFilter, ResourceSort structs"
    - "Generated model files include standard DO NOT EDIT header"
    - "All 14 IR field types map to correct Go types (UUID->uuid.UUID, String->string, Decimal->decimal.Decimal, etc.)"
  artifacts:
    - path: "internal/generator/generator.go"
      provides: "Generation orchestrator and shared utilities"
      exports: ["Generate", "GenerateModels"]
    - path: "internal/generator/formatting.go"
      provides: "Format + import management via golang.org/x/tools/imports"
      exports: ["FormatGoSource"]
    - path: "internal/generator/models.go"
      provides: "Model type generation from ResourceIR"
      exports: ["GenerateModels"]
    - path: "internal/generator/templates/model.go.tmpl"
      provides: "Go model template with Resource/Create/Update/Filter/Sort structs"
    - path: "internal/generator/templates.go"
      provides: "Embedded template filesystem"
    - path: "internal/generator/funcmap.go"
      provides: "Template helper functions (goType, sqlNullType, lower, plural, camel, snake)"
  key_links:
    - from: "internal/generator/models.go"
      to: "internal/parser/ir.go"
      via: "Consumes ResourceIR and FieldIR structs"
      pattern: "parser\\.ResourceIR"
    - from: "internal/generator/models.go"
      to: "internal/generator/formatting.go"
      via: "Calls FormatGoSource on rendered template output"
      pattern: "FormatGoSource"
    - from: "internal/generator/models.go"
      to: "internal/generator/templates.go"
      via: "Loads model.go.tmpl from embedded FS"
      pattern: "TemplatesFS"
---

<objective>
Create the generator infrastructure and Go model type generation that transforms Phase 1's ResourceIR into compilable Go source files.

Purpose: This is the foundation of Phase 2 -- the template rendering pipeline and model generation that all other generators (Atlas HCL, factories) will reuse. Without this, nothing else in Phase 2 can function.
Output: internal/generator/ package with template infrastructure, formatting pipeline, and Go model generation producing Resource/ResourceCreate/ResourceUpdate/ResourceFilter/ResourceSort types.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-code-generation-engine/02-RESEARCH.md
@internal/parser/ir.go
@internal/schema/field_type.go
@internal/scaffold/templates.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create generator infrastructure with template engine and formatting pipeline</name>
  <files>
    internal/generator/generator.go
    internal/generator/formatting.go
    internal/generator/templates.go
    internal/generator/funcmap.go
    go.mod
  </files>
  <action>
Create the generator package foundation that all generators will share.

1. **internal/generator/templates.go**: Create embedded template filesystem using `//go:embed templates/*` directive exposing `TemplatesFS embed.FS`. Follow the exact pattern from internal/scaffold/templates.go.

2. **internal/generator/formatting.go**: Create FormatGoSource function:
   - Takes filename (string) and source ([]byte)
   - Calls `imports.Process(filename, source, nil)` from golang.org/x/tools/imports
   - Returns ([]byte, error) with formatted+import-managed Go source
   - This is the buffer-then-format-then-write pattern from research

3. **internal/generator/funcmap.go**: Create template FuncMap with these helpers:
   - `goType(fieldType string) string` — maps IR field type strings to Go types:
     - UUID -> "uuid.UUID" (github.com/google/uuid)
     - String -> "string"
     - Text -> "string"
     - Int -> "int"
     - BigInt -> "int64"
     - Decimal -> "decimal.Decimal" (github.com/shopspring/decimal)
     - Bool -> "bool"
     - DateTime -> "time.Time"
     - Date -> "time.Time"
     - Enum -> "string"
     - JSON -> "json.RawMessage"
     - Slug -> "string"
     - Email -> "string"
     - URL -> "string"
   - `goPointerType(fieldType string) string` — same as goType but wraps in pointer (*time.Time, *string, etc.) for optional/update fields
   - `lower(s string) string` — strings.ToLower
   - `plural(s string) string` — naive pluralize (append "s", handle "y"->"ies", "s"->"ses")
   - `camel(s string) string` — PascalCase (first letter upper, rest as-is since IR names are already PascalCase)
   - `snake(s string) string` — convert PascalCase to snake_case for DB column names
   - `hasModifier(modifiers []parser.ModifierIR, name string) bool` — check if modifier exists
   - `getModifierValue(modifiers []parser.ModifierIR, name string) interface{}` — get modifier value
   - `isRequired(modifiers []parser.ModifierIR) bool` — shorthand for hasModifier "Required"
   - `BuildFuncMap() template.FuncMap` — returns the FuncMap

4. **internal/generator/generator.go**: Create the orchestrator:
   - `type GenerateConfig struct` with OutputDir (string), ProjectModule (string)
   - `func Generate(resources []parser.ResourceIR, cfg GenerateConfig) error` that calls GenerateModels (and later GenerateAtlasSchema, GenerateFactories)
   - `func renderTemplate(tmplName string, data interface{}) ([]byte, error)` shared helper that parses template from TemplatesFS with FuncMap, executes to bytes.Buffer, returns raw bytes
   - `func writeGoFile(outputPath string, raw []byte) error` that calls FormatGoSource then os.WriteFile
   - `func writeRawFile(outputPath string, raw []byte) error` for non-Go files (HCL) that just writes directly
   - `func ensureDir(path string) error` to create output directories

5. **go.mod**: Add `golang.org/x/tools` dependency. Run `go get golang.org/x/tools/imports`.

Do NOT add github.com/google/uuid or github.com/shopspring/decimal to go.mod yet -- those are dependencies of the GENERATED project, not of forge itself. The goType function returns type name strings used in templates.
  </action>
  <verify>
Run `go build ./internal/generator/` -- must compile with zero errors. Run `go vet ./internal/generator/`.
  </verify>
  <done>
Generator package exists with: embedded template FS, FormatGoSource using imports.Process(), FuncMap with all type mapping helpers, and orchestrator with renderTemplate/writeGoFile utilities. Package compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Go model template and GenerateModels function</name>
  <files>
    internal/generator/templates/model.go.tmpl
    internal/generator/models.go
    internal/generator/generator_test.go
  </files>
  <action>
Create the model template and generation function that produces compilable Go struct types from ResourceIR.

1. **internal/generator/templates/model.go.tmpl**: Create the model template that generates 5 struct types per resource:

```
// Code generated by forge generate. DO NOT EDIT.

package models

{{ range imports for types used }}
import (...)
{{ end }}

// {{.Name}} represents a {{.Name}} record.
type {{.Name}} struct {
    ID        uuid.UUID  `json:"id" db:"id"`
    {{range .Fields}}
    {{.Name}} {{goType .Type}} `json:"{{snake .Name}}" db:"{{snake .Name}}"`
    {{end}}
    {{if .HasTimestamps}}
    CreatedAt time.Time  `json:"created_at" db:"created_at"`
    UpdatedAt time.Time  `json:"updated_at" db:"updated_at"`
    {{end}}
    {{if .Options.SoftDelete}}
    DeletedAt *time.Time `json:"deleted_at,omitempty" db:"deleted_at"`
    {{end}}
}

// {{.Name}}Create holds data for creating a new {{.Name}}.
type {{.Name}}Create struct {
    {{range .Fields}}{{if not (isIDField .)}}{{if isRequired .Modifiers}}
    {{.Name}} {{goType .Type}} `json:"{{snake .Name}}" validate:"required"`
    {{else}}
    {{.Name}} *{{goType .Type}} `json:"{{snake .Name}},omitempty"`
    {{end}}{{end}}{{end}}
}

// {{.Name}}Update holds data for updating an existing {{.Name}}.
type {{.Name}}Update struct {
    {{range .Fields}}{{if not (isIDField .)}}
    {{.Name}} *{{goType .Type}} `json:"{{snake .Name}},omitempty"`
    {{end}}{{end}}
}

// {{.Name}}Filter holds filter criteria for listing {{.Name}} records.
type {{.Name}}Filter struct {
    {{range .Fields}}{{if isFiltirable .Modifiers}}
    {{.Name}}    *{{goType .Type}} `json:"{{snake .Name}},omitempty"`
    {{.Name}}Neq *{{goType .Type}} `json:"{{snake .Name}}_neq,omitempty"`
    {{end}}{{end}}
}

// {{.Name}}Sort defines sort options for {{.Name}} queries.
type {{.Name}}Sort struct {
    Field     string `json:"field" validate:"required"`
    Direction string `json:"direction" validate:"required,oneof=asc desc"`
}
```

The actual template should use proper Go template syntax. Key decisions:
- ID field is always uuid.UUID, always present, never in Create/Update
- Required fields in Create are non-pointer; optional fields are pointer
- ALL fields in Update are pointer (partial updates)
- Filter only includes fields with Filterable modifier
- Sort is generic (field name + direction string)
- Use `json` and `db` struct tags
- Import block must include time, uuid, decimal etc. based on which types appear

Add template helper `isIDField` to funcmap.go that checks if field name is "ID" and type is "UUID".
Add template helper `isFilterable` that checks for Filterable modifier.
Add template helper `isSortable` that checks for Sortable modifier.

2. **internal/generator/models.go**: Create GenerateModels function:
   - `func GenerateModels(resources []parser.ResourceIR, outputDir string, projectModule string) error`
   - For each resource: render model.go.tmpl with ResourceIR data, format via writeGoFile, write to `{outputDir}/models/{snake(resource.Name)}.go`
   - Create `{outputDir}/models/` directory if not exists

3. **internal/generator/generator_test.go**: Create tests:
   - TestGenerateModels_ProductSchema: Use a Product ResourceIR (matching the example from Phase 1), generate to temp dir, verify:
     - File exists at gen/models/product.go
     - Contains "DO NOT EDIT" header
     - Contains "type Product struct"
     - Contains "type ProductCreate struct"
     - Contains "type ProductUpdate struct"
     - Contains "type ProductFilter struct"
     - Contains "type ProductSort struct"
     - File passes go/format.Source() (valid Go syntax)
   - TestGoTypeMapping: Verify all 14 field type mappings return correct Go types
   - TestSnakeCase: Verify PascalCase to snake_case conversion (CreatedAt -> created_at, ID -> id, HTTPStatus -> http_status)
  </action>
  <verify>
Run `go test ./internal/generator/ -v` -- all tests must pass. Run `go vet ./internal/generator/`. Verify the generated model file contains all 5 struct types and passes go/format.Source().
  </verify>
  <done>
GenerateModels produces a Go file per resource containing Resource, ResourceCreate, ResourceUpdate, ResourceFilter, ResourceSort struct types. Generated code includes proper struct tags, DO NOT EDIT header, and passes go/format. Tests confirm type mappings, snake_case conversion, and end-to-end generation.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/generator/` compiles without errors
2. `go test ./internal/generator/ -v` all tests pass
3. `go vet ./internal/generator/` reports no issues
4. Generated model files contain all 5 struct types per resource
5. Generated model files include "DO NOT EDIT" header
6. Generated model files pass go/format.Source() (valid Go syntax)
</verification>

<success_criteria>
- Generator infrastructure package exists with template rendering, formatting, and file writing
- Model generation produces compilable Go files from ResourceIR
- All 14 field types map to correct Go types
- Generated structs have proper json/db struct tags
- Tests verify end-to-end generation pipeline
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation-engine/02-01-SUMMARY.md`
</output>
