---
phase: 06-hypermedia-ui-generation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/auth/session.go
  - internal/auth/password.go
  - internal/auth/html_middleware.go
  - internal/config/config.go
autonomous: true

must_haves:
  truths:
    - "Session manager stores sessions in PostgreSQL via pgxstore (no Redis dependency)"
    - "Password hashing uses bcrypt with cost factor 12"
    - "HTML auth middleware redirects unauthenticated requests to /auth/login"
    - "Session cookie is httpOnly with SameSite=Lax"
  artifacts:
    - path: "internal/auth/session.go"
      provides: "SCS session manager with pgxstore"
      contains: "NewSessionManager"
    - path: "internal/auth/password.go"
      provides: "bcrypt password hashing"
      contains: "HashPassword"
    - path: "internal/auth/html_middleware.go"
      provides: "Session-based auth middleware for HTML routes"
      contains: "RequireSession"
  key_links:
    - from: "internal/auth/session.go"
      to: "pgxstore.New"
      via: "SCS store configuration"
      pattern: "pgxstore\\.New"
    - from: "internal/auth/html_middleware.go"
      to: "internal/auth/session.go"
      via: "session manager usage"
      pattern: "scs\\.SessionManager"
---

<objective>
Create session-based authentication infrastructure for HTML routes

Purpose: Enable session-based email/password authentication using SCS + pgxstore (PostgreSQL-backed, satisfying AUTH-03). Provide bcrypt password hashing and an HTML-specific auth middleware that redirects to login page (unlike the API middleware that returns 401 JSON).

Output: Session manager, password utilities, HTML auth middleware
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/api/middleware/auth.go
@internal/config/config.go
@.planning/phases/06-hypermedia-ui-generation/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SCS session manager and bcrypt password utilities</name>
  <files>
    internal/auth/session.go
    internal/auth/password.go
  </files>
  <action>
    Install dependencies first:
    ```
    go get github.com/alexedwards/scs/v2@v2.9.0
    go get github.com/alexedwards/scs/pgxstore
    go get golang.org/x/crypto/bcrypt
    ```

    Create session.go in internal/auth/ with:

    1. NewSessionManager(pool *pgxpool.Pool) *scs.SessionManager:
       - Creates scs.New() session manager
       - Sets Store to pgxstore.New(pool)
       - Sets Lifetime to 24 * time.Hour
       - Sets Cookie.Name to "forge_session"
       - Sets Cookie.HttpOnly to true
       - Sets Cookie.SameSite to http.SameSiteLaxMode
       - Sets Cookie.Secure based on an isDev bool parameter (false for dev, true for prod)
       - Returns the configured session manager

    2. SessionMiddleware(sm *scs.SessionManager) func(http.Handler) http.Handler:
       - Returns sm.LoadAndSave â€” this is the Chi-compatible middleware that loads and commits session data on each request

    3. Constants:
       - SessionKeyUserID = "user_id" (string key for storing user ID in session)
       - SessionKeyUserEmail = "user_email" (for storing email)

    Create password.go in internal/auth/ with:

    1. const BcryptCost = 12 (higher than default 10 for 2026 hardware)

    2. HashPassword(plaintext string) (string, error):
       - Validates plaintext length <= 72 (bcrypt truncation limit)
       - Returns error if too long
       - Calls bcrypt.GenerateFromPassword([]byte(plaintext), BcryptCost)
       - Returns string(hash), err

    3. CheckPassword(plaintext, hash string) error:
       - Calls bcrypt.CompareHashAndPassword([]byte(hash), []byte(plaintext))
       - Returns nil on match, bcrypt.ErrMismatchedHashAndPassword on mismatch

    Imports use the full package paths: github.com/alexedwards/scs/v2, github.com/alexedwards/scs/pgxstore, golang.org/x/crypto/bcrypt, github.com/jackc/pgx/v5/pgxpool.

    Run go mod tidy after creating the files.
  </action>
  <verify>
    go build ./internal/auth/
    go vet ./internal/auth/
  </verify>
  <done>
    NewSessionManager creates SCS session manager with pgxstore PostgreSQL backend, httpOnly cookie, SameSite=Lax. HashPassword and CheckPassword use bcrypt with cost 12. Password length validated against 72-byte bcrypt limit.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTML auth middleware with session-based redirect</name>
  <files>
    internal/auth/html_middleware.go
    internal/config/config.go
  </files>
  <action>
    Create html_middleware.go in internal/auth/ with:

    1. RequireSession(sm *scs.SessionManager) func(http.Handler) http.Handler:
       - Returns a middleware that checks sm.GetString(r.Context(), SessionKeyUserID)
       - If empty (not logged in), redirects to /auth/login with http.StatusFound (302)
       - If present, calls next.ServeHTTP(w, r)
       - This is intentionally different from the API AuthMiddleware (which returns 401 JSON)

    2. GetSessionUserID(sm *scs.SessionManager, r *http.Request) string:
       - Returns sm.GetString(r.Context(), SessionKeyUserID)
       - Helper for handlers to read the current user from session

    3. GetSessionUserEmail(sm *scs.SessionManager, r *http.Request) string:
       - Returns sm.GetString(r.Context(), SessionKeyUserEmail)

    4. LoginUser(sm *scs.SessionManager, r *http.Request, userID, email string) error:
       - Calls sm.RenewToken(r.Context()) to prevent session fixation
       - Calls sm.Put(r.Context(), SessionKeyUserID, userID)
       - Calls sm.Put(r.Context(), SessionKeyUserEmail, email)
       - Returns any error from RenewToken

    5. LogoutUser(sm *scs.SessionManager, r *http.Request) error:
       - Calls sm.Destroy(r.Context()) to remove all session data
       - Returns any error

    Update internal/config/config.go to add a SessionConfig struct if not already present:
    - Add SessionConfig with fields: Secret string, Secure bool, Lifetime string (duration)
    - Add SessionConfig field to the main Config struct
    - Only add what's needed; don't restructure existing config
  </action>
  <verify>
    go build ./internal/auth/
    go build ./internal/config/
    go vet ./internal/...
  </verify>
  <done>
    RequireSession middleware redirects unauthenticated users to /auth/login. LoginUser prevents session fixation via RenewToken. LogoutUser destroys session. SessionConfig added to config for runtime configuration.
  </done>
</task>

</tasks>

<verification>
- go build ./internal/auth/ compiles cleanly
- go build ./internal/config/ compiles cleanly
- go vet ./internal/auth/ reports no issues
- session.go uses pgxstore.New(pool) for PostgreSQL session storage
- session.go sets HttpOnly=true, SameSite=Lax on cookie
- password.go uses bcrypt.GenerateFromPassword with cost 12
- password.go validates 72-byte max length before hashing
- html_middleware.go redirects to /auth/login when session missing
- html_middleware.go calls sm.RenewToken on login (session fixation prevention)
</verification>

<success_criteria>
- AUTH-01 partially satisfied: Session-based email/password auth infrastructure ready
- AUTH-03 satisfied: Sessions stored in PostgreSQL via pgxstore (no Redis)
- Session middleware and auth helpers ready for HTML route wiring in Plan 08
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypermedia-ui-generation/06-02-SUMMARY.md`
</output>
