---
phase: 05-rest-api-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/generator/api.go
  - internal/generator/api_test.go
  - internal/generator/templates/api_inputs.go.tmpl
  - internal/generator/templates/api_outputs.go.tmpl
  - internal/generator/templates/api_register.go.tmpl
  - internal/generator/funcmap.go
autonomous: true

must_haves:
  truths:
    - "forge generate produces Huma Input structs with validation tags for all 5 CRUD operations per resource"
    - "forge generate produces Huma Output structs with response envelope wrapping (data/pagination)"
    - "forge generate produces route registration functions that wire handlers to action layer"
    - "Generated operationIds follow verb+noun camelCase convention for SDK generation"
    - "List endpoint responses include RFC 8288 Link headers with rel=next for cursor pagination"
  artifacts:
    - path: "internal/generator/templates/api_inputs.go.tmpl"
      provides: "Per-resource Huma Input struct generation with validation tags"
      contains: "ListInput"
    - path: "internal/generator/templates/api_outputs.go.tmpl"
      provides: "Response envelope structs with data wrapper and pagination metadata"
      contains: "PaginationMeta"
    - path: "internal/generator/templates/api_register.go.tmpl"
      provides: "Huma route registration calling action layer, with Link header on List"
      contains: "huma.Register"
    - path: "internal/generator/api.go"
      provides: "GenerateAPI function following existing generator pattern"
      exports: ["GenerateAPI"]
    - path: "internal/generator/api_test.go"
      provides: "Comprehensive tests for API generation"
      contains: "TestGenerateAPI"
  key_links:
    - from: "api_register.go.tmpl"
      to: "gen/actions"
      via: "action layer calls in handlers"
      pattern: "actions\\.(List|Get|Create|Update|Delete)"
    - from: "api_register.go.tmpl"
      to: "Link header"
      via: "List handler sets RFC 8288 Link header from PaginationMeta"
      pattern: "Link.*rel=\"next\""
    - from: "api_inputs.go.tmpl"
      to: "gen/models"
      via: "Body struct fields matching model Create/Update types"
      pattern: "Body struct"
    - from: "api_outputs.go.tmpl"
      to: "gen/models"
      via: "Data field using model type"
      pattern: "Data.*json:\"data\""
---

<objective>
Generate Huma API struct templates and route registration templates for per-resource REST API code generation.

Purpose: This plan creates the core code generation templates that produce Huma Input/Output structs (with validation tags from schema modifiers) and route registration functions (that call the Phase 4 action layer). These templates are the foundation — they produce the gen/api/ directory containing all API endpoint definitions.

Output: Three Go templates (api_inputs.go.tmpl, api_outputs.go.tmpl, api_register.go.tmpl), a GenerateAPI function, comprehensive tests, and new template helpers.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-rest-api-generation/05-CONTEXT.md
@.planning/phases/05-rest-api-generation/05-RESEARCH.md
@.planning/phases/04-action-layer-error-handling/04-02-SUMMARY.md

@internal/generator/generator.go
@internal/generator/actions.go
@internal/generator/funcmap.go
@internal/generator/templates/actions.go.tmpl
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Huma Input/Output struct templates and new funcmap helpers</name>
  <files>
    internal/generator/templates/api_inputs.go.tmpl
    internal/generator/templates/api_outputs.go.tmpl
    internal/generator/funcmap.go
  </files>
  <action>
Create two Go templates that generate per-resource Huma Input and Output structs.

**api_inputs.go.tmpl** — generates `gen/api/{snake_name}_inputs.go` per resource:

1. `List{Resource}Input` struct with:
   - `Cursor string` with tag `query:"cursor" doc:"Pagination cursor for next page"`
   - `Limit int` with tag `query:"limit" default:"20" minimum:"1" maximum:"100" doc:"Number of items per page"`
   - For each field with Filterable modifier: optional query param (pointer type) with `query:"{snake_name}" doc:"Filter by {field name}"`
   - For each field with Sortable modifier: `Sort string` with `query:"sort" enum:"{sortable_fields}" doc:"Sort field"`
   - `SortDir string` with tag `query:"sort_dir" enum:"asc,desc" default:"asc" doc:"Sort direction"`

2. `Get{Resource}Input` struct with:
   - `ID string` with tag `path:"id" doc:"{Resource} ID"`

3. `Create{Resource}Input` struct with:
   - `Body` embedded struct containing fields matching the resource Create model
   - Required fields: non-pointer with `json:"{snake}" minLength/maxLength/minimum/maximum` tags derived from schema modifiers (MinLen, MaxLen mapped to Huma validation tags)
   - Optional fields: pointer types with `json:"{snake},omitempty"`
   - Skip ID field (auto-generated)
   - Enum fields: add `enum:"{val1},{val2}"` tag from EnumValues

4. `Update{Resource}Input` struct with:
   - `ID string` with tag `path:"id" doc:"{Resource} ID"`
   - `Body` embedded struct with ALL fields as pointers (partial update) with `json:"{snake},omitempty"` and validation tags where applicable

5. `Delete{Resource}Input` struct with:
   - `ID string` with tag `path:"id" doc:"{Resource} ID"`

All structs include `// DO NOT EDIT` header and `package api` declaration.

**api_outputs.go.tmpl** — generates `gen/api/{snake_name}_outputs.go` per resource:

1. `List{Resource}Output` struct with:
   - `Body` struct containing:
     - `Data []{Resource}` with tag `json:"data" doc:"List of {lower plural resource}"`
     - `Pagination PaginationMeta` with tag `json:"pagination" doc:"Pagination metadata"`

2. `Get{Resource}Output` / `Create{Resource}Output` / `Update{Resource}Output` (all same shape):
   - `Body` struct containing:
     - `Data {Resource}` with tag `json:"data" doc:"{Resource} resource"`

3. `Delete{Resource}Output` — empty struct `struct{}`

4. `PaginationMeta` struct (only once, in a shared types file):
   - `NextCursor string` with `json:"next_cursor,omitempty" doc:"Cursor for next page"`
   - `HasMore bool` with `json:"has_more" doc:"Whether more results exist"`

Note: The Output structs reference the gen/models.{Resource} type for the Data field. Use `{{.ProjectModule}}/gen/models` import.

**funcmap.go additions** — add these new template helpers:
- `kebab(s string)` — converts PascalCase to kebab-case (e.g., "BlogPost" -> "blog-post") for URL paths. Similar logic to snake() but uses hyphens.
- `lowerCamel(s string)` — converts PascalCase to camelCase (e.g., "BlogPost" -> "blogPost") for operationIds.
- `humaValidationTag(field FieldIR)` — builds Huma validation tag string from field modifiers: MinLen -> minLength, MaxLen -> maxLength, etc.
- `sortableFieldNames(fields []FieldIR)` — returns comma-separated list of snake_case names of sortable fields for enum tag.
- `filterableFields(fields []FieldIR)` — returns only fields with Filterable modifier.
- `buildLinkHeader(basePath string, cursor string) string` — builds RFC 8288 Link header value: `<{basePath}?cursor={cursor}>; rel="next"`. This helper will be used in the route registration template to set the Link header on List responses.
  </action>
  <verify>
Run `go build ./internal/generator/` to confirm funcmap.go compiles with new helpers. Run `go vet ./internal/generator/` for static analysis.
  </verify>
  <done>
Two template files exist in internal/generator/templates/ generating per-resource Input/Output structs. Input structs have Huma validation tags derived from schema modifiers. Output structs wrap responses in `{"data": ...}` envelope per user decision. New funcmap helpers (kebab, lowerCamel, humaValidationTag, sortableFieldNames, filterableFields, buildLinkHeader) compile and are registered.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create route registration template, GenerateAPI function, and tests</name>
  <files>
    internal/generator/templates/api_register.go.tmpl
    internal/generator/api.go
    internal/generator/api_test.go
  </files>
  <action>
**api_register.go.tmpl** — generates `gen/api/{snake_name}_routes.go` per resource:

1. `Register{Resource}Routes(api huma.API, actions {Resource}Actions)` function that registers 5 endpoints:

   - **List**: `GET /api/v1/{kebab-plural-name}`
     - OperationID: `list{Plural}` (e.g., "listBlogPosts")
     - Tags: `[]string{"{kebab-name}"}`
     - Handler calls `actions.List(ctx, filter, sort, page, pageSize)`, wraps result in List output envelope
     - Base64 encodes cursor from action layer raw cursor data (action returns raw, API layer encodes per research recommendation)
     - **RFC 8288 Link header**: After getting pagination result from action layer, if `hasMore` is true and `nextCursor` is non-empty, set a `Link` header on the response: `<{request_base_path}?cursor={encoded_cursor}&limit={limit}>; rel="next"`. Use `ctx.SetHeader("Link", linkValue)` to set the header. Build the link value using the request path and the encoded cursor. This satisfies API-06 (RFC 8288 pagination links).

   - **Get**: `GET /api/v1/{kebab-plural-name}/{id}`
     - OperationID: `get{Resource}` (e.g., "getBlogPost")
     - Handler calls `actions.Get(ctx, id)`, wraps in single-resource envelope

   - **Create**: `POST /api/v1/{kebab-plural-name}`
     - OperationID: `create{Resource}` (e.g., "createBlogPost")
     - Handler maps Input.Body fields to models.{Resource}Create struct, calls `actions.Create(ctx, input)`
     - Returns 201 status

   - **Update**: `PUT /api/v1/{kebab-plural-name}/{id}`
     - OperationID: `update{Resource}` (e.g., "updateBlogPost")
     - Handler maps Input.Body to models.{Resource}Update struct, calls `actions.Update(ctx, id, input)`

   - **Delete**: `DELETE /api/v1/{kebab-plural-name}/{id}`
     - OperationID: `delete{Resource}` (e.g., "deleteBlogPost")
     - Handler calls `actions.Delete(ctx, id)`, returns 204

2. Each handler delegates ALL business logic to the action layer per locked decision ("no business logic in handlers"). Handlers are thin: parse input -> call action -> wrap output -> return.

3. Error handling: each handler converts action errors to Huma errors using a `toHumaError` helper function (generated in a shared api types file). This maps forge.Error status codes to huma.Error4xx/5xx helpers. Validation errors (422) include per-field detail array per user decision.

4. Include a `RegisterAllRoutes(api huma.API, registry *actions.Registry)` function that iterates registered resources and calls individual Register functions.

**api.go** — GenerateAPI function following existing pattern (see actions.go):
- `GenerateAPI(resources []parser.ResourceIR, outputDir string, projectModule string) error`
- Creates `gen/api/` directory
- Generates shared `gen/api/types.go` with PaginationMeta, toHumaError helper, common response types
- For each resource: renders api_inputs.go.tmpl -> `gen/api/{snake}_inputs.go`
- For each resource: renders api_outputs.go.tmpl -> `gen/api/{snake}_outputs.go`
- For each resource: renders api_register.go.tmpl -> `gen/api/{snake}_routes.go`
- Uses writeGoFile for formatting and import management

**api_test.go** — comprehensive tests:
- `TestGenerateAPI` — end-to-end with a Product resource (Name:String/Required/MaxLen:200, Price:Decimal/Required, Status:Enum/Filterable):
  - Verify inputs.go contains ListProductInput with Cursor, Limit, Status filter param
  - Verify inputs.go contains CreateProductInput with Body.Name (minLength, maxLength tags), Body.Price
  - Verify outputs.go contains ListProductOutput with Data []Product and PaginationMeta
  - Verify outputs.go contains GetProductOutput with Data Product wrapped in json:"data"
  - Verify routes.go contains RegisterProductRoutes function
  - Verify routes.go contains huma.Register calls with correct OperationIDs (listProducts, getProduct, createProduct, updateProduct, deleteProduct)
  - Verify routes.go contains /api/v1/products path
  - Verify routes.go calls actions.List, actions.Get, actions.Create, actions.Update, actions.Delete
  - Verify routes.go contains Link header setting logic (SetHeader with "Link" and rel="next") in the List handler
  - Verify types.go contains PaginationMeta and toHumaError
- `TestGenerateAPI_MultipleResources` — verify separate files per resource
- `TestGenerateAPI_OperationIDs` — verify camelCase verb+noun format
- `TestGenerateAPI_LinkHeader` — verify generated List handler contains Link header generation with RFC 8288 format (`rel="next"`)
  </action>
  <verify>
Run `go test ./internal/generator/ -run TestGenerateAPI -v` to verify all tests pass. Run `go build ./internal/generator/` and `go vet ./internal/generator/` for clean compile.
  </verify>
  <done>
Route registration template generates 5 CRUD endpoints per resource with correct Huma OperationIDs, paths (/api/v1/{kebab-plural}), tags, and thin handlers calling action layer. List handler sets RFC 8288 Link header with rel="next" when pagination has more results. GenerateAPI function produces gen/api/ directory with inputs, outputs, routes, and types files per resource. All tests pass including Link header verification.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/ -run TestGenerateAPI -v` — all API generation tests pass
2. `go build ./internal/generator/` — clean compile
3. `go vet ./internal/generator/` — no issues
4. Generated input structs contain Huma validation tags (minLength, maxLength, minimum, maximum, enum)
5. Generated output structs wrap all responses in `{"data": ...}` envelope
6. Generated route registration uses /api/v1/{kebab-plural} paths
7. Generated OperationIDs follow verb+noun camelCase (listProducts, getProduct, etc.)
8. Handlers delegate to action layer (no business logic in handlers)
9. List handler sets RFC 8288 Link header with `rel="next"` when pagination has more results
</verification>

<success_criteria>
- GenerateAPI function exists and follows existing generator pattern (renderTemplate + writeGoFile)
- Three templates produce per-resource Input/Output structs and route registration
- Input struct validation tags derived from schema modifiers (Required, MinLen, MaxLen, Enum)
- Output structs enforce response envelope: single resources in {"data": ...}, lists in {"data": [...], "pagination": {...}}
- Route registration generates 5 CRUD endpoints per resource with SDK-ready operationIds
- All handlers call action layer methods (List, Get, Create, Update, Delete) — zero business logic in handlers
- List handler generates RFC 8288 Link header (`<url>; rel="next"`) from PaginationMeta when hasMore is true
- New funcmap helpers (kebab, lowerCamel, humaValidationTag, buildLinkHeader) registered and tested
</success_criteria>

<output>
After completion, create `.planning/phases/05-rest-api-generation/05-01-SUMMARY.md`
</output>
