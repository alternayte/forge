// Code generated by forge generate. DO NOT EDIT.

package validation

import (
	"strings"

	"{{.ProjectModule}}/gen/models"
	"github.com/google/uuid"
)

// Validate{{.Name}}Create validates a {{.Name}}Create input.
func Validate{{.Name}}Create(input models.{{.Name}}Create) ValidationErrors {
	errors := NewValidationErrors()

	{{- range .Fields}}
	{{- if not (isIDField .)}}
	{{- if isRequired .Modifiers}}
	// Check required field: {{.Name}}
	{{- if eq (goType .Type) "string"}}
	if input.{{.Name}} == "" {
		errors.Add("{{snake .Name}}", "required", "{{.Name}} is required")
	}
	{{- else if eq (goType .Type) "int"}}
	if input.{{.Name}} == 0 {
		errors.Add("{{snake .Name}}", "required", "{{.Name}} is required")
	}
	{{- else if eq (goType .Type) "int64"}}
	if input.{{.Name}} == 0 {
		errors.Add("{{snake .Name}}", "required", "{{.Name}} is required")
	}
	{{- else if eq (goType .Type) "bool"}}
	// Bool fields cannot be validated for "required" as they always have a value
	{{- else if eq (goType .Type) "uuid.UUID"}}
	if input.{{.Name}} == uuid.UUID{} {
		errors.Add("{{snake .Name}}", "required", "{{.Name}} is required")
	}
	{{- end}}
	{{- end}}

	{{- if hasModifier .Modifiers "MaxLen"}}
	// Check max length for {{.Name}}
	{{- if eq (goType .Type) "string"}}
	{{- if isRequired .Modifiers}}
	if len(input.{{.Name}}) > {{getModifierValue .Modifiers "MaxLen"}} {
		errors.Add("{{snake .Name}}", "max_len", "{{.Name}} must be at most {{getModifierValue .Modifiers "MaxLen"}} characters")
	}
	{{- else}}
	if input.{{.Name}} != nil && len(*input.{{.Name}}) > {{getModifierValue .Modifiers "MaxLen"}} {
		errors.Add("{{snake .Name}}", "max_len", "{{.Name}} must be at most {{getModifierValue .Modifiers "MaxLen"}} characters")
	}
	{{- end}}
	{{- end}}
	{{- end}}

	{{- if hasModifier .Modifiers "MinLen"}}
	// Check min length for {{.Name}}
	{{- if eq (goType .Type) "string"}}
	{{- if isRequired .Modifiers}}
	if len(input.{{.Name}}) < {{getModifierValue .Modifiers "MinLen"}} {
		errors.Add("{{snake .Name}}", "min_len", "{{.Name}} must be at least {{getModifierValue .Modifiers "MinLen"}} characters")
	}
	{{- else}}
	if input.{{.Name}} != nil && len(*input.{{.Name}}) < {{getModifierValue .Modifiers "MinLen"}} {
		errors.Add("{{snake .Name}}", "min_len", "{{.Name}} must be at least {{getModifierValue .Modifiers "MinLen"}} characters")
	}
	{{- end}}
	{{- end}}
	{{- end}}

	{{- if eq .Type "Enum"}}
	// Check enum membership for {{.Name}}
	{{- if isRequired .Modifiers}}
	validValues := []string{ {{- range .EnumValues}}"{{.}}", {{end}} }
	found := false
	for _, v := range validValues {
		if input.{{.Name}} == v {
			found = true
			break
		}
	}
	if !found {
		errors.Add("{{snake .Name}}", "enum", "{{.Name}} must be one of: {{range $i, $v := .EnumValues}}{{if $i}}, {{end}}{{$v}}{{end}}")
	}
	{{- else}}
	if input.{{.Name}} != nil {
		validValues := []string{ {{- range .EnumValues}}"{{.}}", {{end}} }
		found := false
		for _, v := range validValues {
			if *input.{{.Name}} == v {
				found = true
				break
			}
		}
		if !found {
			errors.Add("{{snake .Name}}", "enum", "{{.Name}} must be one of: {{range $i, $v := .EnumValues}}{{if $i}}, {{end}}{{$v}}{{end}}")
		}
	}
	{{- end}}
	{{- end}}

	{{- if eq .Type "Email"}}
	// Check email format for {{.Name}}
	{{- if isRequired .Modifiers}}
	if !strings.Contains(input.{{.Name}}, "@") || !strings.Contains(input.{{.Name}}, ".") {
		errors.Add("{{snake .Name}}", "format", "{{.Name}} must be a valid email address")
	}
	{{- else}}
	if input.{{.Name}} != nil && (!strings.Contains(*input.{{.Name}}, "@") || !strings.Contains(*input.{{.Name}}, ".")) {
		errors.Add("{{snake .Name}}", "format", "{{.Name}} must be a valid email address")
	}
	{{- end}}
	{{- end}}
	{{- end}}
	{{- end}}

	return errors
}

// Validate{{.Name}}Update validates a {{.Name}}Update input.
func Validate{{.Name}}Update(input models.{{.Name}}Update) ValidationErrors {
	errors := NewValidationErrors()

	{{- range .Fields}}
	{{- if not (isIDField .)}}
	{{- if hasModifier .Modifiers "MaxLen"}}
	// Check max length for {{.Name}}
	{{- if eq (goType .Type) "string"}}
	if input.{{.Name}} != nil && len(*input.{{.Name}}) > {{getModifierValue .Modifiers "MaxLen"}} {
		errors.Add("{{snake .Name}}", "max_len", "{{.Name}} must be at most {{getModifierValue .Modifiers "MaxLen"}} characters")
	}
	{{- end}}
	{{- end}}

	{{- if hasModifier .Modifiers "MinLen"}}
	// Check min length for {{.Name}}
	{{- if eq (goType .Type) "string"}}
	if input.{{.Name}} != nil && len(*input.{{.Name}}) < {{getModifierValue .Modifiers "MinLen"}} {
		errors.Add("{{snake .Name}}", "min_len", "{{.Name}} must be at least {{getModifierValue .Modifiers "MinLen"}} characters")
	}
	{{- end}}
	{{- end}}

	{{- if eq .Type "Enum"}}
	// Check enum membership for {{.Name}}
	if input.{{.Name}} != nil {
		validValues := []string{ {{- range .EnumValues}}"{{.}}", {{end}} }
		found := false
		for _, v := range validValues {
			if *input.{{.Name}} == v {
				found = true
				break
			}
		}
		if !found {
			errors.Add("{{snake .Name}}", "enum", "{{.Name}} must be one of: {{range $i, $v := .EnumValues}}{{if $i}}, {{end}}{{$v}}{{end}}")
		}
	}
	{{- end}}

	{{- if eq .Type "Email"}}
	// Check email format for {{.Name}}
	if input.{{.Name}} != nil && (!strings.Contains(*input.{{.Name}}, "@") || !strings.Contains(*input.{{.Name}}, ".")) {
		errors.Add("{{snake .Name}}", "format", "{{.Name}} must be a valid email address")
	}
	{{- end}}
	{{- end}}
	{{- end}}

	return errors
}
