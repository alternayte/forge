---
phase: 05-rest-api-generation
plan: 03
type: execute
wave: 2
depends_on: ["05-01", "05-02"]
files_modified:
  - internal/api/server.go
  - internal/api/docs.go
  - internal/generator/generator.go
  - internal/generator/templates/api_types.go.tmpl
autonomous: true

must_haves:
  truths:
    - "API server sets up Huma with Chi router and wires middleware in correct order"
    - "OpenAPI 3.1 spec is served at /api/openapi.json and /api/openapi.yaml"
    - "Interactive API docs (Scalar UI) are served at /api/docs without CDN dependency"
    - "forge generate produces gen/api/ directory with all API structs and route registration"
    - "Generated route registration functions are called after middleware wiring to register all resource endpoints"
  artifacts:
    - path: "internal/api/server.go"
      provides: "API server setup with Huma, Chi, middleware wiring, and route registration"
      contains: "SetupAPI"
    - path: "internal/api/docs.go"
      provides: "Scalar UI documentation handler"
      contains: "scalarui"
    - path: "internal/generator/generator.go"
      provides: "Updated orchestrator calling GenerateAPI"
      contains: "GenerateAPI"
  key_links:
    - from: "internal/api/server.go"
      to: "internal/api/middleware"
      via: "Middleware wiring in correct order"
      pattern: "UseMiddleware"
    - from: "internal/api/server.go"
      to: "gen/api"
      via: "Route registration via RegisterAllRoutes called after middleware wiring"
      pattern: "RegisterAllRoutes"
    - from: "internal/api/docs.go"
      to: "scalarui"
      via: "Scalar UI rendering for embedded docs"
      pattern: "scalarui\\.New"
    - from: "internal/generator/generator.go"
      to: "internal/generator/api.go"
      via: "GenerateAPI called in orchestrator"
      pattern: "GenerateAPI"
---

<objective>
Wire the API server with Huma framework, embed Scalar UI documentation, and integrate API code generation into the forge generate orchestrator.

Purpose: This plan connects all the pieces: the generated API structs/routes (Plan 01) get wired into a Huma server with proper middleware ordering (Plan 02), Scalar UI provides interactive documentation at /api/docs, and the generator orchestrator produces all API files when `forge generate` runs.

Output: API server setup function, Scalar UI docs handler, and updated generator orchestrator.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-rest-api-generation/05-CONTEXT.md
@.planning/phases/05-rest-api-generation/05-RESEARCH.md
@.planning/phases/05-rest-api-generation/05-01-SUMMARY.md
@.planning/phases/05-rest-api-generation/05-02-SUMMARY.md

@internal/generator/generator.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create API server setup with Huma, middleware wiring, route registration, and Scalar UI docs</name>
  <files>
    internal/api/server.go
    internal/api/docs.go
  </files>
  <action>
Create the API server setup that wires Huma with Chi and all middleware, plus Scalar UI documentation.

**internal/api/server.go** — API server setup:

1. `SetupAPI(router chi.Router, cfg config.APIConfig, tokenStore auth.TokenStore, apiKeyStore auth.APIKeyStore) huma.API` function:

   a. Wire router-level middleware (Chi) in order:
      - `middleware.RealIP` — extract real client IP for rate limiting
      - Logging middleware (use Chi's middleware.Logger or slog-based)
      - Panic recovery from gen/middleware (already generated in Phase 4)

   b. Create Huma API instance with Chi adapter:
      ```go
      api := humachi.New(router, huma.DefaultConfig("Forge API", "1.0.0"))
      ```
      Then override config fields:
      - OpenAPI info: Title from forge.toml or "Forge API", Version "1.0.0"
      - Description: "Production-ready REST API generated by Forge"
      - Contact, License info per research recommendations (discretion area)

   c. Wire Huma-level middleware in order (per research: CORS -> Rate Limit -> Auth):
      - CORS middleware from middleware/cors.go
      - Rate limit middleware from middleware/ratelimit.go
      - Auth middleware from middleware/auth.go

   d. **Call generated route registration functions** to register all resource endpoints:
      - Call `api.RegisterAllRoutes(api, actionRegistry)` after all middleware is wired
      - This connects the generated routes from `gen/api/` (produced by Plan 01) to the running server
      - The `actionRegistry` parameter is the `*actions.Registry` from the action layer (Phase 4)
      - This step is CRITICAL — without it, middleware is configured but no endpoints are accessible
      - Example wiring:
        ```go
        // After middleware wiring is complete:
        genapi.RegisterAllRoutes(api, actionRegistry)
        ```

   e. Return the configured huma.API instance

2. `ServerConfig` struct combining:
   - `APIConfig config.APIConfig`
   - `TokenStore auth.TokenStore`
   - `APIKeyStore auth.APIKeyStore`

3. Note: Huma automatically serves OpenAPI spec at the configured OpenAPIPath. Default is "/api/openapi" which serves both .json and .yaml. Per user decision, spec must be at /api/openapi.json and /api/openapi.yaml — Huma handles this natively when OpenAPIPath is set to "/api/openapi".

**internal/api/docs.go** — Scalar UI documentation handler:

1. `RegisterDocsHandler(router chi.Router, specURL string)` function:
   - Uses `github.com/nyxstack/scalarui` package (per research recommendation and user decision for CDN-free embedded docs)
   - Creates scalarui config:
     ```go
     config := scalarui.NewConfig().
         WithTitle("Forge API Documentation").
         WithDescription("Production-ready REST API").
         WithURL(specURL).  // "/api/openapi.json"
         WithTheme("purple").
         WithDarkMode(true).
         WithSidebar(true).
         WithInteractive(true)
     ```
   - Renders HTML via `ui.Render()`
   - Registers at `/api/docs` route on the Chi router
   - Sets Content-Type: text/html; charset=utf-8

2. Note: Huma has a built-in DocsPath but it uses a CDN-hosted Stoplight Elements. Per user decision, we use nyxstack/scalarui for CDN-free embedded docs. Override Huma's default by setting DocsPath to "" (disable) and registering our own handler.

Install required dependencies:
```bash
go get -u github.com/danielgtaylor/huma/v2
go get -u github.com/danielgtaylor/huma/v2/adapters/humachi
go get -u github.com/go-chi/chi/v5
go get -u github.com/go-chi/chi/v5/middleware
go get -u github.com/nyxstack/scalarui
```
  </action>
  <verify>
Run `go build ./internal/api/` to confirm compilation. Run `go vet ./internal/api/`. Verify Huma, Chi, and scalarui appear in go.mod. Verify server.go contains a call to `RegisterAllRoutes` (grep for the pattern).
  </verify>
  <done>
SetupAPI function creates Huma API with Chi router, wires middleware in correct order (RealIP -> Logging -> Recovery -> CORS -> RateLimit -> Auth), calls RegisterAllRoutes to register all generated resource endpoints, and returns configured API. Scalar UI serves embedded docs at /api/docs with no CDN dependency. OpenAPI spec served at /api/openapi.json and /api/openapi.yaml via Huma.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire GenerateAPI into generator orchestrator and create shared API types template</name>
  <files>
    internal/generator/generator.go
    internal/generator/templates/api_types.go.tmpl
  </files>
  <action>
Wire the API code generation into the forge generate pipeline and create the shared types template.

**internal/generator/templates/api_types.go.tmpl** — shared API types generated once (not per-resource):
1. Package declaration: `package api`
2. DO NOT EDIT header
3. `PaginationMeta` struct:
   - `NextCursor string` with `json:"next_cursor,omitempty" doc:"Cursor for next page"`
   - `HasMore bool` with `json:"has_more" doc:"Whether more results exist"`
4. `toHumaError(err error) error` function:
   - Type-asserts err to `*errors.Error` (from gen/errors)
   - Maps error Status to Huma error constructors:
     - 400 -> huma.Error400BadRequest
     - 401 -> huma.Error401Unauthorized
     - 403 -> huma.Error403Forbidden
     - 404 -> huma.Error404NotFound
     - 409 -> huma.Error409Conflict
     - 422 -> custom huma.ErrorModel with validation detail (per user decision: per-field errors array)
     - 500 -> huma.Error500InternalServerError
     - Default -> huma.Error500InternalServerError
   - For 422 validation errors: create huma.ErrorModel with Status 422, Title "Validation Failed", Detail from error.Message, and Errors array with per-field detail
5. Import paths for gen/errors using `{{.ProjectModule}}/gen/errors`

**internal/generator/generator.go** — add GenerateAPI call:
1. Add `GenerateAPI` call after GenerateMiddleware (12th generator):
   ```go
   // Generate API input/output structs and route registration
   if err := GenerateAPI(resources, cfg.OutputDir, cfg.ProjectModule); err != nil {
       return err
   }
   ```
2. This makes the orchestrator produce 12 outputs total:
   Models -> Atlas -> Factories -> Validation -> Queries -> Pagination -> Transaction -> SQLCConfig -> Errors -> Actions -> Middleware -> API
  </action>
  <verify>
Run `go test ./internal/generator/ -v` to verify all tests pass (including new API tests from Plan 01 and all existing tests). Run `go build ./internal/generator/` and `go vet ./internal/generator/`.
  </verify>
  <done>
GenerateAPI wired into generator orchestrator as 12th generator. Shared api_types.go.tmpl generates PaginationMeta struct and toHumaError helper. `forge generate` now produces gen/api/ alongside all other generated directories. All 12 generators run in dependency order.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/api/` — clean compile
2. `go build ./internal/generator/` — clean compile
3. `go test ./internal/generator/ -v` — all tests pass (40+ existing + new API tests)
4. `go vet ./internal/...` — no issues
5. generator.go contains GenerateAPI call after GenerateMiddleware
6. Huma, Chi, scalarui in go.mod
7. Middleware order in server.go: RealIP -> Logging -> Recovery -> CORS -> RateLimit -> Auth
8. server.go calls RegisterAllRoutes after middleware wiring to register generated routes
</verification>

<success_criteria>
- SetupAPI creates Huma with Chi router and returns configured API
- Middleware wired in researched order: Logging -> Panic Recovery -> CORS -> Rate Limiting -> Authentication
- RegisterAllRoutes is called after middleware wiring to register all generated resource endpoints from gen/api/
- Scalar UI embedded at /api/docs with no CDN dependency per user decision
- OpenAPI spec served at /api/openapi.json and /api/openapi.yaml per user decision
- GenerateAPI is 12th generator in orchestrator, runs after all Phase 4 generators
- Shared API types template generates PaginationMeta and toHumaError converter
- forge generate now produces gen/api/ directory
</success_criteria>

<output>
After completion, create `.planning/phases/05-rest-api-generation/05-03-SUMMARY.md`
</output>
