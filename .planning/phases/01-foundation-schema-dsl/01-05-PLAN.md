---
phase: 01-foundation-schema-dsl
plan: 05
type: execute
wave: 3
depends_on: ["01-04"]
files_modified:
  - internal/toolsync/registry.go
  - internal/toolsync/platform.go
  - internal/toolsync/download.go
  - internal/toolsync/toolsync_test.go
  - internal/cli/tool.go
  - internal/cli/tool_sync.go
autonomous: true

must_haves:
  truths:
    - "forge tool sync downloads templ, sqlc, tailwind, and atlas binaries for the current platform"
    - "Tool binaries are downloaded to .forge/tools/ in the project directory"
    - "Download includes progress indication and checksum verification"
    - "Platform detection works correctly for darwin/linux + amd64/arm64"
    - "Zero npm — Tailwind uses standalone CLI binary, not npm package"
  artifacts:
    - path: "internal/toolsync/registry.go"
      provides: "Tool definitions with versions, URLs, and checksums"
      contains: "type ToolDef struct"
    - path: "internal/toolsync/platform.go"
      provides: "Platform detection and URL construction"
      contains: "func DetectPlatform()"
    - path: "internal/toolsync/download.go"
      provides: "HTTP download with progress and checksum verification"
      contains: "func DownloadTool"
    - path: "internal/cli/tool_sync.go"
      provides: "forge tool sync command"
      contains: "func newToolSyncCmd()"
  key_links:
    - from: "internal/cli/tool_sync.go"
      to: "internal/toolsync/download.go"
      via: "CLI command calls DownloadTool for each tool"
      pattern: "toolsync\\.DownloadTool"
    - from: "internal/toolsync/download.go"
      to: "internal/toolsync/registry.go"
      via: "Download uses ToolDef for URL and checksum"
      pattern: "ToolDef"
    - from: "internal/toolsync/download.go"
      to: "internal/toolsync/platform.go"
      via: "Download uses platform for URL construction"
      pattern: "DetectPlatform"
---

<objective>
Build the tool binary management system that downloads and manages external tool binaries (templ, sqlc, tailwind, atlas) required by Forge commands. This ensures zero npm dependency by using standalone CLI binaries.

Purpose: Forge relies on external tools (templ for template compilation, sqlc for query generation, tailwind for CSS, atlas for migrations) but none should require npm. The tool sync system downloads platform-appropriate binaries on demand.

Output: `internal/toolsync/` package with download/verification logic, `forge tool sync` CLI command.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-schema-dsl/01-CONTEXT.md
@.planning/phases/01-foundation-schema-dsl/01-RESEARCH.md
@.planning/phases/01-foundation-schema-dsl/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tool registry, platform detection, and download logic</name>
  <files>
    internal/toolsync/registry.go
    internal/toolsync/platform.go
    internal/toolsync/download.go
    internal/toolsync/toolsync_test.go
  </files>
  <action>
Create `internal/toolsync/platform.go`:
- `Platform` struct: `OS string` (darwin, linux, windows), `Arch string` (amd64, arm64).
- `DetectPlatform() Platform` — uses `runtime.GOOS` and `runtime.GOARCH`.
- `(p Platform) String() string` — returns "darwin_arm64", "linux_amd64", etc.
- `(p Platform) Validate() error` — returns error if OS/Arch combination is unsupported.

Create `internal/toolsync/registry.go`:
- `ToolDef` struct:
  - `Name string` — tool name (e.g., "templ")
  - `Version string` — pinned version
  - `URLTemplate string` — URL template with {{.OS}}, {{.Arch}}, {{.Version}} placeholders
  - `BinaryName string` — expected binary filename after extraction
  - `IsArchive bool` — true if download is tar.gz/zip that needs extraction
  - `Checksums map[string]string` — platform string -> SHA256 hex (e.g., "darwin_arm64" -> "abc123...")
- `DefaultRegistry() []ToolDef` — returns tool definitions for:
  - **templ**: GitHub releases at `github.com/a-h/templ`. URL pattern: `https://github.com/a-h/templ/releases/download/v{{.Version}}/templ_{{.OS}}_{{.Arch}}.tar.gz`. IsArchive=true.
  - **sqlc**: GitHub releases at `github.com/sqlc-dev/sqlc`. URL pattern: `https://downloads.sqlc.dev/sqlc_{{.Version}}_{{.OS}}_{{.Arch}}.tar.gz`. IsArchive=true.
  - **tailwind**: GitHub releases at `github.com/tailwindlabs/tailwindcss`. Standalone CLI binary (no npm!). URL pattern: `https://github.com/tailwindlabs/tailwindcss/releases/download/v{{.Version}}/tailwindcss-{{.OS}}-{{.Arch}}`. IsArchive=false (standalone binary).
  - **atlas**: Release from ariga.io. URL pattern: `https://release.ariga.io/atlas/atlas-{{.OS}}-{{.Arch}}-latest`. IsArchive=false.
- Use placeholder checksums for now (empty string means skip verification) — actual checksums will be populated when versions are pinned. Add a TODO comment noting this.
- `FindTool(name string) (*ToolDef, bool)` — lookup tool by name.

Create `internal/toolsync/download.go`:
- `DownloadTool(tool ToolDef, platform Platform, destDir string, progress func(pct float64)) error`:
  1. Construct URL from URLTemplate using text/template with platform values.
  2. Create destDir (`.forge/tools/`) if not exists.
  3. Download using standard `net/http` (avoid grab dependency for now — simpler, fewer deps).
  4. If tool has non-empty checksum, verify SHA256 after download.
  5. If IsArchive, extract tar.gz to destDir (use archive/tar and compress/gzip from stdlib).
  6. If not archive, write directly as binary.
  7. chmod 0755 on the binary (Unix).
  8. Call progress callback during download with percentage (based on Content-Length).
  9. Return nil on success, wrapped error on failure.
- `SyncAll(tools []ToolDef, platform Platform, destDir string, onProgress func(tool string, pct float64)) error`:
  - Iterate tools, skip if binary already exists at expected path and version matches.
  - Download missing/outdated tools.
  - Report progress for each tool.
- `ToolBinPath(destDir, toolName string) string` — returns expected path to tool binary.
- `IsToolInstalled(destDir, toolName string) bool` — checks if binary exists.

Create `internal/toolsync/toolsync_test.go`:
- Test `DetectPlatform()` returns valid OS/Arch.
- Test URL template construction produces correct URL for known platform.
- Test `FindTool()` returns correct tool by name.
- Do NOT test actual downloads in unit tests (those are integration tests). Test the URL construction, platform detection, and path logic.
  </action>
  <verify>Run `cd /Users/nathananderson-tennant/Development/forge-go && go test ./internal/toolsync/` — all tests pass. Run `go build ./internal/toolsync/` — compiles.</verify>
  <done>Tool registry defines templ, sqlc, tailwind (standalone CLI — zero npm), and atlas with versioned URL templates. Platform detection works for darwin/linux + amd64/arm64. Download logic handles both archive and standalone binary tools with progress callback and checksum verification. Unit tests verify platform detection and URL construction.</done>
</task>

<task type="auto">
  <name>Task 2: Wire forge tool sync command into CLI</name>
  <files>
    internal/cli/tool.go
    internal/cli/tool_sync.go
    internal/cli/root.go
  </files>
  <action>
Create `internal/cli/tool.go`:
- `newToolCmd() *cobra.Command` — parent command for tool subcommands.
  - `Use: "tool"`, `Short: "Manage tool binaries"`.
  - Registers `newToolSyncCmd()` as subcommand.

Create `internal/cli/tool_sync.go`:
- `newToolSyncCmd() *cobra.Command`:
  - `Use: "sync"`, `Short: "Download required tool binaries"`.
  - Optional flag: `--tools` (string slice) to sync specific tools only (default: all).
  - Optional flag: `--force` to re-download even if already installed.
  - RunE logic:
    1. Detect platform via `toolsync.DetectPlatform()`.
    2. Determine project root (find forge.toml walking up directories, or use cwd).
    3. Set dest dir to `{projectRoot}/.forge/tools/`.
    4. Get tool registry from `toolsync.DefaultRegistry()`.
    5. If --tools flag provided, filter to only those tools.
    6. Print header: `ui.Header("Syncing tools...")`.
    7. For each tool:
       - If already installed and not --force: print `ui.Success("templ v0.2.793 (already installed)")` and skip.
       - Otherwise: print `ui.Info("Downloading templ v0.2.793...")`, call `toolsync.DownloadTool()` with progress callback that updates a spinner or percentage.
       - On success: print `ui.Success("templ v0.2.793")`.
       - On failure: print `ui.Error("templ: download failed: {reason}")`, continue to next tool, track failures.
    8. Print summary: `ui.Grouped("Tools", items)` with results.
    9. If any failures, return error.

Update `internal/cli/root.go`:
- Add `rootCmd.AddCommand(newToolCmd())` in init().

Per user decision: Tool sync is on-demand — binaries downloaded only when a command needs them, not upfront. The `forge tool sync` command is the explicit way to pre-download. Future commands (forge generate, forge dev) will auto-trigger tool sync for tools they need.

The output should look like:
```
  Syncing tools...

  ✓ templ v0.2.793
  ✓ sqlc v1.27.0
  ✓ tailwind v3.4.17 (standalone CLI)
  ✓ atlas v0.29.0

  4 tools synced
```
  </action>
  <verify>Run `cd /Users/nathananderson-tennant/Development/forge-go && go build -o /tmp/forge . && /tmp/forge tool sync --help` — shows help for tool sync command with --tools and --force flags. Run `go run . tool --help` — shows tool subcommand group. Verify `go build .` compiles the full binary without errors.</verify>
  <done>`forge tool sync` command registered under `forge tool` group. Command downloads tools to .forge/tools/ with progress reporting and styled output. Platform detection selects correct binaries. --tools flag allows selective sync. --force flag re-downloads existing tools. Output matches Cargo-like grouped style with checkmarks.</done>
</task>

</tasks>

<verification>
- `go build .` compiles full CLI binary
- `forge tool sync --help` shows correct usage and flags
- `forge tool --help` shows tool subcommand group
- Platform detection returns correct OS/Arch
- Tool registry has entries for templ, sqlc, tailwind (standalone), atlas
- URL templates produce valid download URLs
- Tailwind uses standalone CLI binary (zero npm verified)
- Unit tests pass for platform detection and URL construction
</verification>

<success_criteria>
`forge tool sync` downloads platform-appropriate binaries for templ, sqlc, tailwind (standalone CLI), and atlas to .forge/tools/. Progress is shown during download. Already-installed tools are skipped. The Tailwind standalone binary ensures zero npm dependency. Output is polished with icons and grouped formatting.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-schema-dsl/01-05-SUMMARY.md`
</output>
