---
phase: 07-advanced-data-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/schema/modifier.go
  - internal/schema/field.go
  - internal/schema/permission.go
  - internal/schema/option.go
  - internal/parser/ir.go
  - internal/parser/extractor.go
  - internal/generator/funcmap.go
autonomous: true
requirements:
  - SCHEMA-07
  - SCHEMA-08

must_haves:
  truths:
    - "Visibility('admin') and Mutability('admin') modifiers are recognized by the parser and appear in FieldIR.Modifiers"
    - "Permission('list', 'admin', 'editor') resource-level option is parsed into PermissionsIR on ResourceOptionsIR"
    - "Eager() modifier on relationships is parsed into RelationshipIR.Eager boolean"
    - "Existing parser tests still pass (no regressions)"
  artifacts:
    - path: "internal/schema/modifier.go"
      provides: "ModVisibility and ModMutability modifier type constants"
      contains: "ModVisibility"
    - path: "internal/schema/permission.go"
      provides: "Permission type with operation and role variadic args"
      contains: "Permission"
    - path: "internal/parser/ir.go"
      provides: "PermissionsIR type and Eager bool on RelationshipIR"
      contains: "PermissionsIR"
    - path: "internal/parser/extractor.go"
      provides: "Visibility, Mutability, Eager in isModifierMethod; Permission extraction"
      contains: "Visibility"
    - path: "internal/generator/funcmap.go"
      provides: "hasPermission, permissionRoles, hasAnyVisibility, getVisibilityRole, hasAuditableResource funcmap helpers"
      contains: "hasPermission"
  key_links:
    - from: "internal/schema/field.go"
      to: "internal/schema/modifier.go"
      via: "Visibility() and Mutability() methods use ModVisibility/ModMutability constants"
      pattern: "ModVisibility"
    - from: "internal/parser/extractor.go"
      to: "internal/parser/ir.go"
      via: "extractPermissions populates PermissionsIR on ResourceOptionsIR"
      pattern: "PermissionsIR"
---

<objective>
Extend the schema DSL, parser, IR, and template funcmap to support Visibility, Mutability, Permissions, and Eager modifiers.

Purpose: All Phase 7 features (soft delete, tenant scoping, permissions, audit, eager loading) depend on the IR and parser recognizing the new annotations. This foundation plan must complete first so downstream plans can generate conditional code based on these IR fields.

Output: Updated schema DSL types, parser extraction logic, IR types, and funcmap helpers ready for template consumption.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Visibility, Mutability, Permission, and Eager to schema DSL and IR</name>
  <files>
    internal/schema/modifier.go
    internal/schema/field.go
    internal/schema/permission.go
    internal/schema/option.go
    internal/parser/ir.go
  </files>
  <action>
    1. In `internal/schema/modifier.go`, add two new ModifierType constants after `ModHelp`:
       - `ModVisibility` — field-level visibility role restriction
       - `ModMutability` — field-level mutability role restriction
       These follow the same pattern as existing ModLabel/ModPlaceholder (value is a string).

    2. In `internal/schema/field.go`, add two new fluent methods on *Field:
       - `Visibility(role string) *Field` — calls addModifier with ModVisibility and role as Value
       - `Mutability(role string) *Field` — calls addModifier with ModMutability and role as Value
       Follow exact pattern of existing `Label(s string) *Field`.

    3. Create `internal/schema/permission.go` (NEW file):
       - Define `PermissionItem` struct with fields: `Operation string`, `Roles []string`
       - Implement `schemaItem()` method to satisfy SchemaItem interface
       - Create constructor `Permission(operation string, roles ...string) *PermissionItem`
       - The operation string should be one of: "list", "read", "create", "update", "delete"
       - Example usage: `schema.Permission("list", "admin", "editor")`

    4. In `internal/parser/ir.go`:
       - Add `PermissionsIR` type: `map[string][]string` (operation -> allowed roles)
       - Add `Permissions PermissionsIR` field to `ResourceOptionsIR` struct
       - Add `Eager bool` field to `RelationshipIR` struct

    5. In `internal/schema/option.go`: No changes needed — SoftDelete, Auditable, TenantScoped already exist. Permission is a separate SchemaItem, not an Option.
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/schema/... && go build ./internal/parser/...` — both compile without errors.
  </verify>
  <done>
    ModVisibility and ModMutability constants exist in modifier.go. Field.Visibility() and Field.Mutability() methods exist in field.go. PermissionItem type with Permission() constructor exists in permission.go. PermissionsIR type and Eager bool exist in ir.go. All packages compile cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire parser extraction and add funcmap template helpers</name>
  <files>
    internal/parser/extractor.go
    internal/generator/funcmap.go
  </files>
  <action>
    1. In `internal/parser/extractor.go`:

       a. Add "Visibility", "Mutability", and "Eager" to the `isModifierMethod()` map. These are string-value modifiers (Visibility/Mutability take a role string arg; Eager takes no args) and the existing extractModifiersFromChain already handles both zero-arg and one-arg modifiers.

       b. Add `isPermissionType()` function:
          ```go
          func isPermissionType(name string) bool {
              return name == "Permission"
          }
          ```

       c. In `extractSchemaDefinition()`, in the argument processing loop, add a branch BEFORE the existing `isFieldType` check. After the `findRootCall` call, check:
          ```go
          // Check if it's a permission definition
          // Permission is parsed from schema.Permission("list", "admin", "editor") calls
          // It doesn't chain from schema.X like fields — it's a direct call
          ```
          Actually, Permission is called as `schema.Permission("list", "admin", "editor")` which means findRootCall will find "Permission" as the funcName. Add an `else if isPermissionType(funcName)` branch that calls `extractPermission()`.

       d. Create `extractPermission()` function:
          ```go
          func extractPermission(fset *token.FileSet, call *ast.CallExpr, source []byte, filename string) (string, []string) {
              rootCall, _ := findRootCall(call)
              if rootCall == nil || len(rootCall.Args) < 2 {
                  return "", nil
              }
              // First arg: operation string
              opLit, ok := rootCall.Args[0].(*ast.BasicLit)
              if !ok || opLit.Kind != token.STRING {
                  return "", nil
              }
              op, _ := strconv.Unquote(opLit.Value)
              // Remaining args: role strings
              var roles []string
              for i := 1; i < len(rootCall.Args); i++ {
                  roleLit, ok := rootCall.Args[i].(*ast.BasicLit)
                  if ok && roleLit.Kind == token.STRING {
                      role, _ := strconv.Unquote(roleLit.Value)
                      roles = append(roles, role)
                  }
              }
              return op, roles
          }
          ```

       e. In the `extractSchemaDefinition` loop, add the permission branch:
          ```go
          } else if isPermissionType(funcName) {
              op, roles := extractPermission(fset, argCall, source, filename)
              if op != "" && len(roles) > 0 {
                  if resource.Options.Permissions == nil {
                      resource.Options.Permissions = make(PermissionsIR)
                  }
                  resource.Options.Permissions[op] = roles
              }
          }
          ```

       f. In `extractRelationship()`, after processing OnDelete and Optional modifiers, add Eager handling:
          ```go
          } else if mod.Type == "Eager" {
              rel.Eager = true
          }
          ```

    2. In `internal/generator/funcmap.go`:

       Add these template helpers to BuildFuncMap() and implement them:

       a. `hasPermission(opts parser.ResourceOptionsIR, operation string) bool` — returns true if opts.Permissions has the given operation key
       b. `permissionRoles(opts parser.ResourceOptionsIR, operation string) string` — returns Go code literal like `"admin", "editor"` for the roles
       c. `hasAnyVisibility(fields []parser.FieldIR) bool` — returns true if any field has a "Visibility" modifier
       d. `hasAnyPermission(opts parser.ResourceOptionsIR) bool` — returns true if opts.Permissions is non-empty
       e. `hasAuditableResource(resources []parser.ResourceIR) bool` — returns true if any resource has Options.Auditable == true
       f. `hasTenantScopedResource(resources []parser.ResourceIR) bool` — returns true if any resource has Options.TenantScoped == true

       Register all in BuildFuncMap() under a "// Phase 7: Advanced data feature helpers" comment section.
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/parser/... && go build ./internal/generator/... && go test ./internal/parser/... -count=1` — all compile and existing parser tests pass.
  </verify>
  <done>
    Parser recognizes Visibility, Mutability, Eager as modifiers and Permission as a schema item type. extractPermission produces PermissionsIR correctly. Eager sets RelationshipIR.Eager = true. funcmap provides hasPermission, permissionRoles, hasAnyVisibility, hasAnyPermission, hasAuditableResource, hasTenantScopedResource helpers. Existing tests pass without regression.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/schema/...` compiles (DSL additions)
2. `go build ./internal/parser/...` compiles (IR + extraction additions)
3. `go build ./internal/generator/...` compiles (funcmap additions)
4. `go test ./internal/parser/... -count=1` passes (no regressions)
5. New types are accessible: `schema.Permission("list", "admin")`, `field.Visibility("admin")`, `field.Mutability("editor")`
</verification>

<success_criteria>
Schema DSL, parser, IR, and funcmap fully support Visibility, Mutability, Permission, and Eager annotations. All existing tests pass. Downstream plans can reference these IR fields in template conditionals.
</success_criteria>

<output>
After completion, create `.planning/phases/07-advanced-data-features/07-01-SUMMARY.md`
</output>
