---
phase: 06-hypermedia-ui-generation
plan: 05
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - internal/auth/oauth.go
  - internal/generator/templates/atlas_schema.hcl.tmpl
  - internal/generator/atlas.go
autonomous: true

must_haves:
  truths:
    - "OAuth2 providers (Google, GitHub) configured via Goth library"
    - "OAuth callback creates or finds user and stores userID in SCS session"
    - "Sessions table generated in Atlas HCL schema for pgxstore"
    - "OAuth temp state uses signed cookie (completed sessions use PostgreSQL via SCS)"
  artifacts:
    - path: "internal/auth/oauth.go"
      provides: "Goth OAuth2 provider setup and callback handler"
      contains: "SetupOAuth"
    - path: "internal/generator/templates/atlas_schema.hcl.tmpl"
      provides: "Updated Atlas schema with sessions table"
      contains: "sessions"
  key_links:
    - from: "internal/auth/oauth.go"
      to: "internal/auth/session.go"
      via: "session manager usage in callback"
      pattern: "LoginUser|SessionKeyUserID"
    - from: "internal/auth/oauth.go"
      to: "goth"
      via: "OAuth2 provider registration"
      pattern: "goth\\.UseProviders"
---

<objective>
Add OAuth2 provider support and sessions table for PostgreSQL session storage

Purpose: Enable Google and GitHub OAuth2 authentication using Goth library, and add the required sessions table to the Atlas HCL schema so pgxstore can persist sessions in PostgreSQL.

Output: OAuth2 setup, callback handler, sessions table in Atlas schema
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/auth/session.go
@internal/generator/templates/atlas_schema.hcl.tmpl
@internal/generator/atlas.go
@.planning/phases/06-hypermedia-ui-generation/06-RESEARCH.md
@.planning/phases/06-hypermedia-ui-generation/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create OAuth2 provider setup and callback handler</name>
  <files>
    internal/auth/oauth.go
  </files>
  <action>
    Install dependency first:
    ```
    go get github.com/markbates/goth@v1.82.0
    ```

    Create oauth.go in internal/auth/ with:

    1. OAuthConfig struct:
       - Google struct { ClientID, ClientSecret string }
       - GitHub struct { ClientID, ClientSecret string }
       - CallbackBaseURL string (e.g., "http://localhost:8080")
       - SessionSecret string (for gothic.Store cookie signing)

    2. SetupOAuth(cfg OAuthConfig):
       - Calls goth.UseProviders with:
         - google.New(cfg.Google.ClientID, cfg.Google.ClientSecret, cfg.CallbackBaseURL+"/auth/google/callback")
         - github.New(cfg.GitHub.ClientID, cfg.GitHub.ClientSecret, cfg.CallbackBaseURL+"/auth/github/callback")
       - Sets gothic.Store to sessions.NewCookieStore([]byte(cfg.SessionSecret))
       - Note in comment: OAuth temp state (30-60 second CSRF token) stays in signed cookie. Completed auth sessions go to SCS + pgxstore (AUTH-03 compliant).

    3. HandleOAuthCallback(sm *scs.SessionManager, findOrCreateUser UserFinder) http.HandlerFunc:
       - Calls gothic.CompleteUserAuth(w, r) to get goth.User
       - Calls findOrCreateUser(ctx, goth.User) to get internal user ID
       - Calls LoginUser(sm, r, userID, user.Email) to store in session
       - Redirects to "/" via http.Redirect with StatusFound

    4. UserFinder type: func(ctx context.Context, gothUser goth.User) (userID string, err error)
       - This is a callback the generated app provides to map OAuth users to internal users

    5. RegisterOAuthRoutes(router chi.Router, sm *scs.SessionManager, findOrCreateUser UserFinder):
       - Public route group (no auth middleware):
         - GET /auth/{provider} -> gothic.BeginAuthHandler
         - GET /auth/{provider}/callback -> HandleOAuthCallback(sm, findOrCreateUser)
       - Note: These routes MUST be outside the RequireSession middleware group to avoid infinite redirect loops (see Pitfall 4 from research)

    6. HandleLogin(sm *scs.SessionManager) http.HandlerFunc:
       - Renders a login page (simple inline HTML for now; templ template comes later)
       - Shows email/password form + OAuth provider buttons (Google, GitHub)

    7. HandleLoginSubmit(sm *scs.SessionManager, authenticateUser PasswordAuthenticator) http.HandlerFunc:
       - Reads email and password from form POST
       - Calls authenticateUser(ctx, email, password) to verify credentials
       - On success: calls LoginUser, redirects to /
       - On failure: re-renders login page with error message

    8. PasswordAuthenticator type: func(ctx context.Context, email, password string) (userID string, err error)

    9. HandleLogout(sm *scs.SessionManager) http.HandlerFunc:
       - Calls LogoutUser(sm, r)
       - Redirects to /auth/login

    Run go mod tidy after.
  </action>
  <verify>
    go build ./internal/auth/
    go vet ./internal/auth/
  </verify>
  <done>
    SetupOAuth configures Google and GitHub providers via Goth. HandleOAuthCallback completes OAuth flow and stores user in SCS session. RegisterOAuthRoutes sets up public auth routes. Login/logout handlers provide email/password authentication. OAuth temp state uses signed cookie; completed sessions use PostgreSQL.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add sessions table to Atlas HCL schema generation</name>
  <files>
    internal/generator/templates/atlas_schema.hcl.tmpl
    internal/generator/atlas.go
  </files>
  <action>
    Update atlas_schema.hcl.tmpl to append the sessions table required by pgxstore.

    After the existing resource table definitions, add a static block:

    ```
    table "sessions" {
      schema = schema.public
      column "token" {
        type = text
        null = false
      }
      column "data" {
        type = sql("bytea")
        null = false
      }
      column "expiry" {
        type = timestamptz
        null = false
      }
      primary_key {
        columns = [column.token]
      }
      index "sessions_expiry_idx" {
        columns = [column.expiry]
      }
    }
    ```

    This is the exact schema required by pgxstore (from alexedwards/scs/pgxstore documentation). The table must exist for sessions to work.

    This sessions table is always generated (not conditional) because session management is a core framework feature. It does NOT depend on any resource — it's infrastructure.

    Update atlas.go if needed to ensure the sessions table block is included. If the template simply appends it after the range loop, no Go code changes are needed — just the template update.
  </action>
  <verify>
    go test ./internal/generator/ -run TestGenerateAtlas -v
    go build ./internal/generator/
  </verify>
  <done>
    Atlas HCL schema includes sessions table with token (text PK), data (bytea), expiry (timestamptz), and sessions_expiry_idx index. pgxstore can use this table for PostgreSQL session storage.
  </done>
</task>

</tasks>

<verification>
- go build ./internal/auth/ compiles cleanly with goth dependency
- go vet ./internal/auth/ reports no issues
- oauth.go uses goth.UseProviders with Google and GitHub
- oauth.go uses gothic.Store for OAuth temp state (cookie-based)
- oauth.go callback calls LoginUser to store completed session in SCS
- Auth routes registered outside RequireSession middleware group
- Atlas schema includes sessions table with correct pgxstore schema
- Existing atlas tests still pass
</verification>

<success_criteria>
- AUTH-01 satisfied: Session-based email/password auth configurable via HandleLogin/HandleLoginSubmit
- AUTH-02 satisfied: OAuth2 providers (Google, GitHub) configurable via SetupOAuth
- AUTH-03 reinforced: Sessions table in PostgreSQL (pgxstore schema generated)
- OAuth flow complete: begin -> provider -> callback -> session -> redirect
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypermedia-ui-generation/06-05-SUMMARY.md`
</output>
