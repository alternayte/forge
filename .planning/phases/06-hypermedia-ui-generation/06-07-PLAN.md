---
phase: 06-hypermedia-ui-generation
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/forgetest/db.go
  - internal/forgetest/app.go
  - internal/forgetest/datastar.go
autonomous: true

must_haves:
  truths:
    - "forgetest.NewTestDB creates isolated PostgreSQL test schema with auto-cleanup"
    - "forgetest.NewApp creates httptest.Server from any http.Handler"
    - "forgetest.PostDatastar sends Datastar SSE form submissions with JSON signals"
    - "Test database uses atlas migrator for schema setup"
  artifacts:
    - path: "internal/forgetest/db.go"
      provides: "NewTestDB with isolated PostgreSQL schema"
      contains: "NewTestDB"
    - path: "internal/forgetest/app.go"
      provides: "NewApp HTTP test server"
      contains: "NewApp"
    - path: "internal/forgetest/datastar.go"
      provides: "PostDatastar SSE form test helper"
      contains: "PostDatastar"
  key_links:
    - from: "internal/forgetest/db.go"
      to: "testdb"
      via: "peterldowns/testdb for isolated schemas"
      pattern: "testdb\\.New"
    - from: "internal/forgetest/datastar.go"
      to: "application/json"
      via: "JSON signal body"
      pattern: "application/json"
---

<objective>
Create testing infrastructure package (forgetest)

Purpose: Provide forgetest.NewTestDB (isolated PostgreSQL schemas per test), forgetest.NewApp (HTTP test server), and forgetest.PostDatastar (Datastar SSE form submission helper) for integration testing of generated forge applications.

Output: Complete forgetest package with 3 test utilities
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-hypermedia-ui-generation/06-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create NewTestDB with peterldowns/testdb and atlas migrator</name>
  <files>
    internal/forgetest/db.go
  </files>
  <action>
    Install dependencies:
    ```
    go get github.com/peterldowns/testdb
    ```
    Note: peterldowns/testdb may have a specific import path for the atlas migrator. Check the module structure. If atlasmigrator is not available or the API differs, use the SQL migrator with the project's Atlas HCL schema file instead.

    Create db.go in internal/forgetest/ with:

    1. TestDBConfig struct:
       - Host, Port, User, Password, Database string
       - SchemaPath string (path to gen/atlas/schema.hcl)

    2. DefaultTestDBConfig() TestDBConfig:
       - Returns config with localhost:5432, postgres/postgres, sslmode=disable
       - SchemaPath computed using runtime.Caller(0) to find repo root:
         ```go
         _, filename, _, _ := runtime.Caller(0)
         repoRoot := filepath.Join(filepath.Dir(filename), "../..")
         ```
       - SchemaPath = filepath.Join(repoRoot, "gen/atlas/schema.hcl")
       - This resolves Pitfall 7 (relative path issues in tests)

    3. NewTestDB(t *testing.T, opts ...func(*TestDBConfig)) *sql.DB:
       - Applies default config, then applies option functions
       - Creates testdb.Config from TestDBConfig
       - Creates atlas migrator pointing to SchemaPath
       - Calls testdb.New(t, conf, migrator) — returns *sql.DB with auto-cleanup
       - t.Helper() at the top

    4. WithSchemaPath(path string) func(*TestDBConfig):
       - Option function to override schema path

    5. WithDatabaseURL(url string) func(*TestDBConfig):
       - Option function to parse a DATABASE_URL and set Host/Port/User/Password/Database

    Note on pgxpool: The rest of the project uses pgxpool.Pool. Provide a WrapToPgxPool helper or document that callers should use pgxpool.NewWithConfig from the *sql.DB's DSN. Keep this simple — NewTestDB returns *sql.DB (what testdb provides), and a separate helper converts if needed:

    6. NewTestPool(t *testing.T, opts ...func(*TestDBConfig)) *pgxpool.Pool:
       - Calls NewTestDB to get *sql.DB
       - Extracts connection string from the *sql.DB driver
       - Creates pgxpool.New with that connection string
       - Registers t.Cleanup to close the pool
       - This is the primary function most tests will use
  </action>
  <verify>
    go build ./internal/forgetest/
    go vet ./internal/forgetest/
  </verify>
  <done>
    NewTestDB creates isolated PostgreSQL schema per test with atlas migrator and auto-cleanup. NewTestPool wraps it in pgxpool.Pool for project compatibility. DefaultTestDBConfig uses runtime.Caller for reliable path resolution.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create NewApp HTTP test server and PostDatastar helper</name>
  <files>
    internal/forgetest/app.go
    internal/forgetest/datastar.go
  </files>
  <action>
    Create app.go in internal/forgetest/ with:

    1. NewApp(t *testing.T, handler http.Handler) *httptest.Server:
       - t.Helper()
       - Creates httptest.NewServer(handler)
       - Registers t.Cleanup(srv.Close)
       - Returns the server
       - Note: The handler is the fully-assembled application router. This is intentionally a thin wrapper — the generated app builds its own router and passes it here. This keeps forgetest generic (TEST-04 design from research open question #3).

    2. AppURL(srv *httptest.Server, path string) string:
       - Returns srv.URL + path
       - Convenience helper for building test request URLs

    Create datastar.go in internal/forgetest/ with:

    1. PostDatastar(t *testing.T, srv *httptest.Server, path string, signals any) *http.Response:
       - t.Helper()
       - Marshals signals to JSON via json.Marshal
       - Creates POST request to srv.URL + path
       - Sets Content-Type: application/json
       - Sets Accept: text/event-stream (signals Datastar client to server)
       - Uses http.DefaultClient.Do(req)
       - Registers t.Cleanup to close response body
       - Returns response for assertion

    2. GetDatastar(t *testing.T, srv *httptest.Server, path string) *http.Response:
       - t.Helper()
       - Creates GET request to srv.URL + path
       - Sets Accept: text/event-stream
       - Returns response

    3. ReadSSEEvents(t *testing.T, resp *http.Response) []SSEEvent:
       - Reads response body line by line
       - Parses SSE format: lines starting with "event:" and "data:"
       - Returns slice of SSEEvent{Type, Data string}
       - Helper for asserting on Datastar responses

    4. SSEEvent struct:
       - Type string (event name, e.g., "datastar-merge-fragments")
       - Data string (event data payload)
  </action>
  <verify>
    go build ./internal/forgetest/
    go vet ./internal/forgetest/
  </verify>
  <done>
    NewApp wraps httptest.NewServer with auto-cleanup. PostDatastar sends Datastar SSE form submissions with JSON signals. GetDatastar sends SSE GET requests. ReadSSEEvents parses SSE response into structured events. All helpers use t.Helper() for clean test output.
  </done>
</task>

</tasks>

<verification>
- go build ./internal/forgetest/ compiles cleanly
- go vet ./internal/forgetest/ reports no issues
- db.go uses testdb.New with atlas migrator for isolated schemas
- db.go uses runtime.Caller for reliable schema path resolution
- app.go NewApp accepts http.Handler and returns httptest.Server with cleanup
- datastar.go PostDatastar sets Content-Type: application/json and Accept: text/event-stream
- datastar.go ReadSSEEvents parses SSE event/data lines
</verification>

<success_criteria>
- TEST-02 satisfied: forgetest.NewTestDB provides isolated test schema with auto-cleanup
- TEST-03 note: Action layer testability without HTTP is an architectural property established in Phase 4 (Actions interface with direct List/Get/Create/Update/Delete methods accepting a pool). NewTestPool enables this by providing a test-ready pgxpool.Pool, but the testability itself comes from the Phase 4 Actions design, not from forgetest.
- TEST-04 satisfied: forgetest.NewApp provides full HTTP testing, PostDatastar helper for Datastar form submissions
- TEST-01 already satisfied: Test factories generated in Phase 2 with builder pattern
</success_criteria>

<output>
After completion, create `.planning/phases/06-hypermedia-ui-generation/06-07-SUMMARY.md`
</output>
