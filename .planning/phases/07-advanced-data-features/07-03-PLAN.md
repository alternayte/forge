---
phase: 07-advanced-data-features
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified:
  - internal/auth/tenant.go
  - internal/generator/templates/queries.go.tmpl
  - internal/generator/templates/atlas_schema.hcl.tmpl
  - internal/generator/templates/model.go.tmpl
  - internal/generator/templates/factory.go.tmpl
autonomous: true
requirements:
  - TENANT-01
  - DATA-05
  - TENANT-02
  - TENANT-03
  - TENANT-04

must_haves:
  truths:
    - "TenantResolver interface with header, subdomain, and path implementations exists in internal/auth"
    - "TenantFromContext and WithTenant helpers propagate tenant ID via context.Context"
    - "When TenantScoped is true, generated queries include tenant_id WHERE clause automatically"
    - "Atlas generates row_level_security block and tenant isolation policy for tenant-scoped resources"
    - "Model struct includes TenantID field and factory sets a default test tenant"
  artifacts:
    - path: "internal/auth/tenant.go"
      provides: "TenantResolver interface, HeaderTenantResolver, SubdomainTenantResolver, PathTenantResolver, WithTenant, TenantFromContext"
      contains: "TenantResolver"
    - path: "internal/generator/templates/queries.go.tmpl"
      provides: "TenantMod query method for automatic tenant scoping"
      contains: "TenantMod"
    - path: "internal/generator/templates/atlas_schema.hcl.tmpl"
      provides: "tenant_id column, RLS enabled block, and tenant isolation policy for tenant-scoped tables"
      contains: "row_level_security"
    - path: "internal/generator/templates/model.go.tmpl"
      provides: "TenantID uuid.UUID field on model struct when TenantScoped"
      contains: "TenantID"
    - path: "internal/generator/templates/factory.go.tmpl"
      provides: "Default test TenantID in factory when TenantScoped"
      contains: "TenantID"
  key_links:
    - from: "internal/auth/tenant.go"
      to: "internal/generator/templates/queries.go.tmpl"
      via: "TenantFromContext used by generated TenantMod to read tenant from context"
      pattern: "TenantFromContext"
    - from: "internal/generator/templates/atlas_schema.hcl.tmpl"
      to: "ResourceOptionsIR.TenantScoped"
      via: "Conditional tenant_id column, row_level_security block, and tenant_isolation policy when TenantScoped is true"
      pattern: "row_level_security"
---

<objective>
Implement tenant isolation: runtime tenant context propagation, query-level tenant scoping, Atlas RLS policies, and tenant-aware model/factory generation.

Purpose: TENANT-01 through TENANT-04 and DATA-05 require that tenant-scoped resources automatically filter by tenant_id and have PostgreSQL RLS as a safety net. This enables multi-tenant applications where data is strictly isolated per tenant.

Output: New internal/auth/tenant.go runtime file. Updated queries, atlas, model, and factory templates with tenant-conditional logic.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-RESEARCH.md
@.planning/phases/07-advanced-data-features/07-01-SUMMARY.md
@.planning/phases/07-advanced-data-features/07-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tenant runtime (context helpers + resolvers) and update model/factory templates</name>
  <files>
    internal/auth/tenant.go
    internal/generator/templates/model.go.tmpl
    internal/generator/templates/factory.go.tmpl
  </files>
  <action>
    1. Create `internal/auth/tenant.go` (NEW file) with the following:

       Package `auth` (matches existing files in internal/auth/).

       a. Private context key types using the standard Go pattern (struct{} keys):
          ```go
          type tenantContextKey struct{}
          ```

       b. Context helpers:
          - `WithTenant(ctx context.Context, id uuid.UUID) context.Context` — stores tenant ID in context
          - `TenantFromContext(ctx context.Context) (uuid.UUID, bool)` — retrieves tenant ID from context
          Uses `context.WithValue` with the private key type to prevent collisions.

       c. `TenantResolver` interface:
          ```go
          type TenantResolver interface {
              Resolve(r *http.Request) (uuid.UUID, error)
          }
          ```

       d. Three implementations per user decision (developer configures strategy):
          - `HeaderTenantResolver` — reads tenant ID from configurable header (default: X-Tenant-ID)
            ```go
            type HeaderTenantResolver struct{ Header string }
            func (h HeaderTenantResolver) Resolve(r *http.Request) (uuid.UUID, error) {
                raw := r.Header.Get(h.Header)
                if raw == "" { return uuid.Nil, fmt.Errorf("missing tenant header %s", h.Header) }
                return uuid.Parse(raw)
            }
            ```
          - `SubdomainTenantResolver` — extracts first subdomain segment from Host header, parses as UUID
          - `PathTenantResolver` — extracts tenant ID from URL path prefix (e.g., /tenants/{id}/...)

       e. `TenantMiddleware` function that wraps an http.Handler:
          ```go
          func TenantMiddleware(resolver TenantResolver) func(http.Handler) http.Handler {
              return func(next http.Handler) http.Handler {
                  return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                      tenantID, err := resolver.Resolve(r)
                      if err != nil {
                          http.Error(w, "tenant not found", http.StatusUnauthorized)
                          return
                      }
                      ctx := WithTenant(r.Context(), tenantID)
                      next.ServeHTTP(w, r.WithContext(ctx))
                  })
              }
          }
          ```

       Imports: `context`, `fmt`, `net/http`, `strings`, `github.com/google/uuid`

    2. In `model.go.tmpl`, add TenantID field to the main model struct when TenantScoped:
       After the ID field line and before the `{{- range .Fields}}` loop, add:
       ```
       {{- if .Options.TenantScoped}}
       TenantID uuid.UUID `json:"tenant_id" db:"tenant_id"`
       {{- end}}
       ```

    3. In `factory.go.tmpl`, add TenantID default value when TenantScoped:
       Inside the `New{{.Name}}()` function return block, after the range loop over Fields, add:
       ```
       {{- if .Options.TenantScoped}}
       TenantID: uuid.MustParse("00000000-0000-0000-0000-000000000001"), // default test tenant
       {{- end}}
       ```
       Also add a `WithTenantID` builder method inside a TenantScoped guard:
       ```
       {{- if .Options.TenantScoped}}
       // WithTenantID sets the TenantID field.
       func (b *{{.Name}}Builder) WithTenantID(v uuid.UUID) *{{.Name}}Builder {
           b.instance.TenantID = v
           return b
       }
       {{- end}}
       ```
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/auth/... && go build ./internal/generator/...` — both compile.
  </verify>
  <done>
    internal/auth/tenant.go exists with TenantResolver interface, 3 resolver implementations (header/subdomain/path), TenantMiddleware, WithTenant, and TenantFromContext. model.go.tmpl includes TenantID field when TenantScoped. factory.go.tmpl provides default test tenant UUID and WithTenantID builder method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tenant query scoping and Atlas RLS policies</name>
  <files>
    internal/generator/templates/queries.go.tmpl
    internal/generator/templates/atlas_schema.hcl.tmpl
  </files>
  <action>
    1. In `queries.go.tmpl`, add tenant scoping query mod AFTER the soft delete mods (from Plan 02), guarded by `{{- if .Options.TenantScoped}}`:

       ```
       {{- if .Options.TenantScoped}}

       // TenantMod scopes the query to the current tenant from context.
       // Panics if tenant ID is not in context — ensure TenantMiddleware is applied.
       func (f {{$resource}}Filters) TenantMod(ctx context.Context) sm.QueryMod[*psql.SelectQuery] {
           tenantID, ok := forgeauth.TenantFromContext(ctx)
           if !ok {
               panic("{{$resource}}: tenant ID required in context — is TenantMiddleware applied?")
           }
           return sm.Where(psql.Quote("tenant_id").EQ(psql.Arg(tenantID)))
       }
       {{- end}}
       ```

       Add the import for the auth package. The import section at the top of queries.go.tmpl currently imports models, psql, and sm. Add a conditional import:
       ```
       {{- if .Options.TenantScoped}}
       "context"
       forgeauth "github.com/forge-framework/forge/internal/auth"
       {{- end}}
       ```
       Note: Use `forgeauth` alias to avoid collision with any other `auth` package.

    2. In `atlas_schema.hcl.tmpl`, add tenant_id column, index, RLS enable block, and RLS policy for TenantScoped resources:

       a. Inside the table block, AFTER the SoftDelete column block and BEFORE the primary_key block, add the tenant_id column:
       ```
       {{if .Options.TenantScoped}}
       column "tenant_id" {
         type = uuid
         null = false
       }
       {{end}}
       ```

       b. Inside the table block, AFTER the existing index blocks, add the tenant_id index:
       ```
       {{if .Options.TenantScoped}}
       index "{{plural (snake $resourceName)}}_tenant_id_idx" {
         columns = [column.tenant_id]
       }
       {{end}}
       ```

       c. Inside the table block, AFTER the tenant_id index, add the RLS enable block:
       ```
       {{if .Options.TenantScoped}}
       row_level_security {
         enabled  = true
         enforced = true
       }
       {{end}}
       ```
       Atlas HCL v0.14+ supports the `row_level_security` block natively.

       d. Inside the table block, AFTER the row_level_security block, add the tenant isolation policy:
       ```
       {{if .Options.TenantScoped}}
       # Tenant isolation RLS policy (defense-in-depth safety net).
       # Application-level WHERE clause via TenantMod handles performance (index usage).
       # RLS blocks access when SET LOCAL app.current_tenant is not set (secure by default).
       policy "tenant_isolation" {
         for = SELECT
         to  = [PUBLIC]
         using = "(tenant_id = current_setting('app.current_tenant')::uuid)"
       }
       policy "tenant_isolation_mod" {
         for = ALL
         to  = [PUBLIC]
         using       = "(tenant_id = current_setting('app.current_tenant')::uuid)"
         with_check  = "(tenant_id = current_setting('app.current_tenant')::uuid)"
       }
       {{end}}
       ```

       Per user decision: "RLS context via SET LOCAL per-transaction — middleware runs SET LOCAL app.current_tenant = $1 at transaction start." The policy uses `current_setting('app.current_tenant')::uuid` to read the per-transaction setting. If Atlas HCL policy syntax requires adjustment at runtime, the executor can adapt the exact attribute names, but the intent is clear: generate actual RLS policy blocks, not just comments.
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Review queries.go.tmpl for TenantMod method. Review atlas_schema.hcl.tmpl for tenant_id column and index.
  </verify>
  <done>
    queries.go.tmpl has TenantMod method that reads tenant from context and applies WHERE tenant_id = $1. atlas_schema.hcl.tmpl generates tenant_id column (uuid, not null), tenant_id index, row_level_security { enabled = true, enforced = true } block, and tenant_isolation policy blocks (SELECT + ALL) that enforce tenant_id = current_setting('app.current_tenant')::uuid for TenantScoped resources. Application-level WHERE is the primary tenant isolation; RLS is the generated safety net.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/auth/...` compiles (tenant.go)
2. `go build ./internal/generator/...` compiles (template changes)
3. internal/auth/tenant.go has TenantResolver interface + 3 implementations
4. queries.go.tmpl has TenantMod inside `{{if .Options.TenantScoped}}`
5. atlas_schema.hcl.tmpl has tenant_id column, index, row_level_security block, and tenant_isolation policy blocks inside TenantScoped guard
6. model.go.tmpl has TenantID field inside TenantScoped guard
7. factory.go.tmpl has default test TenantID inside TenantScoped guard
</verification>

<success_criteria>
Tenant isolation is fully wired: runtime context helpers exist, queries automatically scope by tenant_id, Atlas generates the tenant_id column with index and actual RLS policy blocks (row_level_security enabled + tenant_isolation policies), models include TenantID, and test factories scope to a test tenant. The application-level WHERE clause provides the primary isolation with RLS as the generated safety net.
</success_criteria>

<output>
After completion, create `.planning/phases/07-advanced-data-features/07-03-SUMMARY.md`
</output>
