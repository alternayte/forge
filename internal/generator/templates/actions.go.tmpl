// Code generated by forge generate. DO NOT EDIT.

package actions

import (
	"context"
{{- if .Options.Auditable}}
	"encoding/json"
	"reflect"
{{- end}}
{{- if or (hasAnyPermission .Options) (hasAnyVisibility .Fields) (.Options.Auditable) (hasHooks .Options)}}
	forgeauth "github.com/alternayte/forge/forge/auth"
{{- end}}
{{- if hasHooks .Options}}
	"github.com/jackc/pgx/v5"
	"github.com/riverqueue/river"
{{- end}}

	"github.com/google/uuid"
	"{{.ProjectModule}}/gen/errors"
	"{{.ProjectModule}}/gen/models"
	"{{.ProjectModule}}/gen/queries"
	"{{.ProjectModule}}/gen/validation"
)
{{- if hasHooks .Options}}

// Job args types (generated inline to avoid import cycles with resources/)
{{- range .Options.Hooks.AfterCreate}}
type {{pascal .Kind}}Args struct {
	ResourceID uuid.UUID `json:"resource_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
}

func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }
{{- end}}
{{- range .Options.Hooks.AfterUpdate}}
type {{pascal .Kind}}Args struct {
	ResourceID uuid.UUID `json:"resource_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
}

func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }
{{- end}}
{{- end}}

// {{.Name}}Actions defines the business logic interface for {{.Name}} operations.
// Both HTML and API handlers call this interface to prevent logic duplication.
type {{.Name}}Actions interface {
	// List retrieves {{plural .Name | lower}} with filtering, sorting, and pagination.
	List(ctx context.Context, filter models.{{.Name}}Filter, sort models.{{.Name}}Sort, page int, pageSize int) ([]models.{{.Name}}, int64, error)

	// Get retrieves a single {{.Name}} by ID.
	Get(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error)

	// Create creates a new {{.Name}} after validation.
	Create(ctx context.Context, input models.{{.Name}}Create) (*models.{{.Name}}, error)

	// Update updates an existing {{.Name}} after validation.
	Update(ctx context.Context, id uuid.UUID, input models.{{.Name}}Update) (*models.{{.Name}}, error)

	// Delete removes a {{.Name}} by ID.
	Delete(ctx context.Context, id uuid.UUID) error
{{- if .Options.SoftDelete}}

	// Restore restores a soft-deleted {{.Name}} by clearing its deleted_at timestamp.
	Restore(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error)
{{- end}}
{{- if hasAnyVisibility .Fields}}

	// RoleFilterList strips invisible fields from a list of items based on user role.
	RoleFilterList(role string, items []models.{{.Name}}) []map[string]any
{{- end}}
}

// Default{{.Name}}Actions is the default implementation of {{.Name}}Actions.
// Developers can embed this struct and override specific methods for custom behavior.
type Default{{.Name}}Actions struct {
	DB DB
{{- if hasHooks .Options}}
	River *river.Client[pgx.Tx]
{{- end}}
}

// List retrieves {{plural .Name | lower}} with filtering, sorting, and pagination.
func (a *Default{{.Name}}Actions) List(ctx context.Context, filter models.{{.Name}}Filter, sort models.{{.Name}}Sort, page int, pageSize int) ([]models.{{.Name}}, int64, error) {
{{- if hasPermission .Options "list"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "list"}}); err != nil {
		return nil, 0, err
	}
{{- end}}
	// Build query mods from filter
	filterMods := queries.{{.Name}}FilterMods(filter)
{{- if .Options.SoftDelete}}
	// Exclude soft-deleted records by default (DATA-06)
	filterMods = append(filterMods, queries.{{.Name}}Filters{}.ActiveMod())
{{- end}}

	// Build sort mod
	sortMod := queries.{{.Name}}SortMod(sort)

	// TODO: Execute Bob query with filterMods and sortMod
	// This will be implemented when Bob query execution layer is complete.
	// For now, return empty results to maintain compilable interface.
	_ = filterMods
	_ = sortMod

	return []models.{{.Name}}{}, 0, nil
}

// Get retrieves a single {{.Name}} by ID.
func (a *Default{{.Name}}Actions) Get(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "read"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "read"}}); err != nil {
		return nil, err
	}
{{- end}}
{{- if .Options.SoftDelete}}
	// Note: Get excludes soft-deleted records. Use a custom action override with
	// OnlyTrashedMod or no ActiveMod filter for admin restore views.
{{- end}}
	// TODO: Execute Bob query to fetch by ID
	// This will be implemented when Bob query execution layer is complete.
	// For now, return not found error to maintain compilable interface.
	_ = id

	return nil, errors.NotFound("{{.Name}}", id.String())
}

// Create creates a new {{.Name}} after validation.
func (a *Default{{.Name}}Actions) Create(ctx context.Context, input models.{{.Name}}Create) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "create"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "create"}}); err != nil {
		return nil, err
	}
{{- end}}
	// Validate input using generated validation
	valErrs := validation.Validate{{.Name}}Create(input)
	if valErrs.HasErrors() {
		return nil, errors.NewValidationError(valErrs)
	}

{{- if .Options.Hooks.AfterCreate}}
	// Transactional create with AfterCreate job hooks (JOBS-02)
	var result *models.{{.Name}}
	err := pgx.BeginFunc(ctx, a.DB, func(tx pgx.Tx) error {
		// TODO: Execute Bob insert via tx (replace when Bob is wired)
		_ = tx
		if result == nil {
			return errors.InternalError("Create not yet implemented")
		}
		{{- range .Options.Hooks.AfterCreate}}
		// Enqueue {{.Kind}} job in same transaction (JOBS-02)
		tenantID, _ := forgeauth.TenantFromContext(ctx)
		if _, enqErr := a.River.InsertTx(ctx, tx, {{pascal .Kind}}Args{
			ResourceID: result.ID,
			TenantID:   tenantID,
		}, &river.InsertOpts{ {{- if .Queue}}Queue: "{{.Queue}}",{{end}} }); enqErr != nil {
			return enqErr
		}
		{{- end}}
		return nil
	})
	return result, err
{{- else}}
	// TODO: Execute Bob insert query
	// This will be implemented when Bob query execution layer is complete.
	// For now, return internal error to maintain compilable interface.
{{- if .Options.Auditable}}
	// Note: When Bob insert is wired, set created_by from forgeauth.UserFromContext(ctx)
	// on the insert payload before executing the query (AUDIT-01).
{{- end}}

	return nil, errors.InternalError("Create not yet implemented")
{{- end}}
}

// Update updates an existing {{.Name}} after validation.
func (a *Default{{.Name}}Actions) Update(ctx context.Context, id uuid.UUID, input models.{{.Name}}Update) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "update"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "update"}}); err != nil {
		return nil, err
	}
{{- end}}
	// Validate input using generated validation
	valErrs := validation.Validate{{.Name}}Update(input)
	if valErrs.HasErrors() {
		return nil, errors.NewValidationError(valErrs)
	}

{{- if .Options.Auditable}}
	// Fetch before-state for audit diff (must happen before UPDATE) (AUDIT-02)
	beforeItem, _ := a.Get(ctx, id)
{{- end}}

{{- if .Options.Hooks.AfterUpdate}}
	// Transactional update with AfterUpdate job hooks (JOBS-02)
	var item *models.{{.Name}}
	err := pgx.BeginFunc(ctx, a.DB, func(tx pgx.Tx) error {
		// TODO: Execute Bob update via tx (replace when Bob is wired)
		_ = tx
		_ = id
		if item == nil {
			return errors.NotFound("{{.Name}}", id.String())
		}
		{{- range .Options.Hooks.AfterUpdate}}
		// Enqueue {{.Kind}} job in same transaction (JOBS-02)
		tenantID, _ := forgeauth.TenantFromContext(ctx)
		if _, enqErr := a.River.InsertTx(ctx, tx, {{pascal .Kind}}Args{
			ResourceID: item.ID,
			TenantID:   tenantID,
		}, &river.InsertOpts{ {{- if .Queue}}Queue: "{{.Queue}}",{{end}} }); enqErr != nil {
			return enqErr
		}
		{{- end}}
		return nil
	})
{{- if .Options.Auditable}}
	// Record update in audit log with JSONB diff (AUDIT-02)
	// No-op updates produce empty diff — no audit entry (AUDIT-03)
	if beforeItem != nil && item != nil {
		if auditErr := a.recordAudit(ctx, "update", id, beforeItem, item); auditErr != nil {
			_ = auditErr // Log but don't fail the update
		}
	}
{{- end}}
	return item, err
{{- else}}
	// TODO: Execute Bob update query
	// This will be implemented when Bob query execution layer is complete.
	// For now, return not found error to maintain compilable interface.
	_ = id

	// TODO: Replace placeholder item below with the actual updated record from Bob query
	var item *models.{{.Name}}

{{- if .Options.Auditable}}
	// Record update in audit log with JSONB diff (AUDIT-02)
	// No-op updates produce empty diff — no audit entry (AUDIT-03)
	if beforeItem != nil && item != nil {
		if err := a.recordAudit(ctx, "update", id, beforeItem, item); err != nil {
			_ = err // Log but don't fail the update
		}
	}
{{- end}}

	return nil, errors.NotFound("{{.Name}}", id.String())
{{- end}}
}

// Delete removes a {{.Name}} by ID.
func (a *Default{{.Name}}Actions) Delete(ctx context.Context, id uuid.UUID) error {
{{- if hasPermission .Options "delete"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "delete"}}); err != nil {
		return err
	}
{{- end}}
{{- if .Options.SoftDelete}}
	// Soft delete: set deleted_at timestamp instead of removing the record.
	// Per design: no hard delete — soft delete is final state. Developer uses raw SQL if needed.
	_, err := a.DB.Exec(ctx,
		`UPDATE {{plural (snake .Name)}} SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL`,
		id,
	)
	if err != nil {
		return errors.InternalError("failed to soft-delete {{.Name}}")
	}
{{- if .Options.Auditable}}
	// Record soft-delete in audit log (AUDIT-02)
	a.recordAudit(ctx, "delete", id, nil, map[string]any{"deleted_at": "now"}) //nolint:errcheck
{{- end}}
	return nil
{{- else}}
	// Hard delete
	// TODO: Execute Bob delete query
	_ = id
	return errors.NotFound("{{.Name}}", id.String())
{{- end}}
}
{{- if .Options.SoftDelete}}

// Restore restores a soft-deleted {{.Name}} by clearing deleted_at.
func (a *Default{{.Name}}Actions) Restore(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "delete"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "delete"}}); err != nil {
		return nil, err
	}
{{- end}}
	result, err := a.DB.Exec(ctx,
		`UPDATE {{plural (snake .Name)}} SET deleted_at = NULL WHERE id = $1 AND deleted_at IS NOT NULL`,
		id,
	)
	if err != nil {
		return nil, errors.InternalError("failed to restore {{.Name}}")
	}
	if result.RowsAffected() == 0 {
		return nil, errors.NotFound("{{.Name}}", id.String())
	}
	return a.Get(ctx, id)
}
{{- end}}
{{- if hasAnyPermission .Options}}

// checkPermission verifies the current user's role is in the allowed roles list.
// Returns a Forbidden error if the role is not permitted.
func checkPermission(ctx context.Context, allowedRoles ...string) error {
	role := forgeauth.RoleFromContext(ctx)
	for _, r := range allowedRoles {
		if r == role {
			return nil
		}
	}
	return errors.Forbidden("insufficient permissions")
}
{{- end}}
{{- if .Options.Auditable}}

// computeJSONDiff compares two map representations and returns only changed fields.
// Each changed field has "before" and "after" values. Returns nil if no changes.
func computeJSONDiff(before, after map[string]any) map[string]any {
	diff := make(map[string]any)
	for k, afterVal := range after {
		beforeVal, exists := before[k]
		if !exists {
			diff[k] = map[string]any{"before": nil, "after": afterVal}
		} else if !reflect.DeepEqual(beforeVal, afterVal) {
			diff[k] = map[string]any{"before": beforeVal, "after": afterVal}
		}
	}
	// Check for deleted keys (in before but not in after)
	for k, beforeVal := range before {
		if _, exists := after[k]; !exists {
			diff[k] = map[string]any{"before": beforeVal, "after": nil}
		}
	}
	if len(diff) == 0 {
		return nil
	}
	return diff
}

// recordAudit records a change to the audit_logs table.
// before is nil for creates (all fields recorded as new values).
// If before and after are identical, no entry is recorded (AUDIT-03: no-op updates).
func (a *Default{{.Name}}Actions) recordAudit(ctx context.Context, op string, resourceID uuid.UUID, before, after any) error {
	var beforeMap, afterMap map[string]any

	if before != nil {
		b, _ := json.Marshal(before)
		json.Unmarshal(b, &beforeMap) //nolint:errcheck
	}
	a2, _ := json.Marshal(after)
	json.Unmarshal(a2, &afterMap) //nolint:errcheck

	diff := computeJSONDiff(beforeMap, afterMap)
	if diff == nil && op != "create" {
		return nil // No changes — skip audit entry (AUDIT-03)
	}

	// For creates, record all fields as the diff
	if op == "create" && diff == nil {
		diff = afterMap
	}

	userID := forgeauth.UserFromContext(ctx)
	diffJSON, _ := json.Marshal(diff)

	var userIDPtr *uuid.UUID
	if userID != (uuid.UUID{}) {
		userIDPtr = &userID
	}

	_, err := a.DB.Exec(ctx,
		`INSERT INTO audit_logs (resource_type, resource_id, operation, changed_fields, created_by)
		 VALUES ($1, $2, $3, $4, $5)`,
		"{{snake .Name}}", resourceID, op, diffJSON, userIDPtr,
	)
	return err
}

// GetDB returns the database connection for direct queries (e.g., audit log).
func (a *Default{{.Name}}Actions) GetDB() DB {
	return a.DB
}
{{- end}}
{{- if hasAnyVisibility .Fields}}

// roleFilter returns a map representation of the model with invisible fields omitted
// based on the current user's role. Fields with Visibility("role") are only included
// when the user's role matches. Fields without Visibility are always included.
// Per user decision: invisible fields omitted entirely (key doesn't appear in JSON).
func (a *Default{{.Name}}Actions) roleFilter(role string, item models.{{.Name}}) map[string]any {
	result := map[string]any{
		"id": item.ID,
		{{- range .Fields}}
		{{- if not (isIDField .)}}
		{{- if not (hasModifier .Modifiers "Visibility")}}
		"{{snake .Name}}": item.{{.Name}},
		{{- end}}
		{{- end}}
		{{- end}}
		{{- if .HasTimestamps}}
		"created_at": item.CreatedAt,
		"updated_at": item.UpdatedAt,
		{{- end}}
		{{- if .Options.SoftDelete}}
		"deleted_at": item.DeletedAt,
		{{- end}}
	}
	{{- range .Fields}}
	{{- if and (not (isIDField .)) (hasModifier .Modifiers "Visibility")}}
	// Field {{.Name}} visible only for role "{{getModifierValue .Modifiers "Visibility"}}"
	if role == "" || role == "{{getModifierValue .Modifiers "Visibility"}}" {
		result["{{snake .Name}}"] = item.{{.Name}}
	}
	{{- end}}
	{{- end}}
	return result
}

// RoleFilterList applies roleFilter to a slice of items, stripping invisible fields
// based on the current user's role.
func (a *Default{{.Name}}Actions) RoleFilterList(role string, items []models.{{.Name}}) []map[string]any {
	result := make([]map[string]any, len(items))
	for i, item := range items {
		result[i] = a.roleFilter(role, item)
	}
	return result
}
{{- end}}
