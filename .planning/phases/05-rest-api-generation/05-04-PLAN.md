---
phase: 05-rest-api-generation
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - internal/cli/routes.go
  - internal/cli/openapi.go
  - internal/cli/root.go
autonomous: true

must_haves:
  truths:
    - "forge routes lists all API routes grouped by resource with method, path, and operation"
    - "forge openapi export writes the OpenAPI spec to a file in JSON or YAML format"
    - "forge routes output is scannable and grouped like rails routes"
  artifacts:
    - path: "internal/cli/routes.go"
      provides: "forge routes command listing API routes grouped by resource"
      contains: "routesCmd"
    - path: "internal/cli/openapi.go"
      provides: "forge openapi export command with --format flag"
      contains: "openapiExportCmd"
    - path: "internal/cli/root.go"
      provides: "Updated root command with routes and openapi subcommands"
      contains: "routesCmd"
  key_links:
    - from: "internal/cli/routes.go"
      to: "internal/parser"
      via: "Parses schemas to derive route listing from IR"
      pattern: "parser\\.Parse"
    - from: "internal/cli/openapi.go"
      to: "huma"
      via: "Creates temporary Huma API to generate spec from IR"
      pattern: "huma\\."
---

<objective>
Create CLI commands for listing API routes and exporting the OpenAPI spec.

Purpose: These commands give developers visibility into their generated API. `forge routes` provides a quick overview of all endpoints grouped by resource (inspired by `rails routes`). `forge openapi export` generates the OpenAPI spec file for SDK generation, CI linting, or sharing with API consumers.

Output: Two new Cobra CLI commands registered under the forge root command.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-rest-api-generation/05-CONTEXT.md
@.planning/phases/05-rest-api-generation/05-RESEARCH.md
@.planning/phases/05-rest-api-generation/05-01-SUMMARY.md

@internal/cli/root.go
@internal/cli/generate.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forge routes command with grouped output</name>
  <files>
    internal/cli/routes.go
    internal/cli/root.go
  </files>
  <action>
Create the `forge routes` command that lists all registered API routes grouped by resource.

**internal/cli/routes.go**:

1. Create `routesCmd` Cobra command:
   - Use: "routes"
   - Short: "List all registered routes"
   - Long: "Display all HTML and API routes grouped by resource"

2. RunE function:
   a. Find and parse schema files using the existing parser (same flow as forge generate):
      - Read forge.toml for schema directory
      - Call parser.ParseDir() to get resources
   b. For each resource, derive the 5 CRUD API routes:
      - GET    /api/v1/{kebab-plural}        list{Plural}
      - GET    /api/v1/{kebab-plural}/{id}    get{Resource}
      - POST   /api/v1/{kebab-plural}         create{Resource}
      - PUT    /api/v1/{kebab-plural}/{id}    update{Resource}
      - DELETE /api/v1/{kebab-plural}/{id}    delete{Resource}
   c. Use the same kebab/plural/lowerCamel helpers from funcmap (import them or replicate the conversion logic in the CLI package)

3. Output format — grouped by resource, styled with lipgloss (already in go.mod):
   ```
   Routes:

   Product (5 routes)
     GET    /api/v1/products          listProducts
     GET    /api/v1/products/{id}     getProduct
     POST   /api/v1/products          createProduct
     PUT    /api/v1/products/{id}     updateProduct
     DELETE /api/v1/products/{id}     deleteProduct

   Category (5 routes)
     GET    /api/v1/categories        listCategories
     GET    /api/v1/categories/{id}   getCategory
     POST   /api/v1/categories        createCategory
     PUT    /api/v1/categories/{id}   updateCategory
     DELETE /api/v1/categories/{id}   deleteCategory

   Total: 10 routes (2 resources)
   ```

4. Use column alignment for scannable output (pad METHOD to 6 chars, PATH to max path length + 2). Use lipgloss for resource headers (bold) and method coloring (GET=green, POST=blue, PUT=yellow, DELETE=red).

5. Per user decision: "forge routes output grouped by resource (not flat table)" and "should feel like rails routes — grouped, scannable, quick to find what you need".

**internal/cli/root.go** — register the routes command:
- Add `rootCmd.AddCommand(routesCmd)` alongside existing commands

Note: For Phase 5 this only lists API routes. Phase 6 (HTML) will add HTML routes to the same command. Structure the code so adding HTML routes later is straightforward (e.g., separate `apiRoutes(resource)` and `htmlRoutes(resource)` functions).
  </action>
  <verify>
Run `go build ./cmd/forge/` to confirm the CLI compiles. Run `go vet ./internal/cli/`. Verify `forge routes --help` works (shows command description).
  </verify>
  <done>
forge routes command parses schemas and displays API routes grouped by resource with styled output. Methods are color-coded, paths are column-aligned, output shows total route count. Command registered in root.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create forge openapi export command with JSON/YAML format flag</name>
  <files>
    internal/cli/openapi.go
    internal/cli/root.go
  </files>
  <action>
Create the `forge openapi export` command that exports the OpenAPI spec to a file.

**internal/cli/openapi.go**:

1. Create `openapiCmd` Cobra command (parent):
   - Use: "openapi"
   - Short: "OpenAPI spec management"

2. Create `openapiExportCmd` Cobra command (subcommand of openapi):
   - Use: "export [file]"
   - Short: "Export the OpenAPI spec to a file"
   - Long: "Export the OpenAPI 3.1 spec generated from your schemas. Supports JSON and YAML formats."
   - Args: cobra.MaximumNArgs(1) — optional output filename
   - Flags:
     - `--format` string (default: "json") — "json" or "yaml"

3. RunE function:
   a. Parse schema files (same flow as forge routes):
      - Read forge.toml for schema directory and project config
      - Call parser.ParseDir() to get resources
   b. Create a temporary Chi router and Huma API instance (in-memory, no server):
      ```go
      router := chi.NewRouter()
      api := humachi.New(router, huma.DefaultConfig("Forge API", "1.0.0"))
      ```
   c. For each resource, programmatically register dummy operations matching the generated route structure:
      - Use huma.Register with correct OperationID, Method, Path, Summary, Tags
      - Handler functions can be nil/noop (we only need the spec, not actual handlers)
      - Input/Output types from IR: build struct types dynamically or use empty placeholder types with correct field tags
      - NOTE: Huma generates the OpenAPI spec from the registered operations and their Input/Output types. For a complete spec, use the actual generated gen/api/ types. Since this is a CLI command, it can import gen/api if the project has been generated. If gen/ doesn't exist yet, fall back to schema-only spec generation.
   d. Export the spec:
      - Get OpenAPI bytes from api using Huma's built-in method
      - For JSON: `api.OpenAPI().MarshalJSON()` or access the spec object
      - For YAML: marshal the spec to YAML using `encoding/json` -> JSON -> YAML converter, or use Huma's YAML path
   e. Write to file:
      - If filename argument provided: write to that file
      - If no filename: default to `openapi.{format}` (e.g., "openapi.json" or "openapi.yaml")
   f. Print success message: "OpenAPI spec exported to {filename}"

4. Per user decision: "forge openapi export supports both JSON and YAML formats via --format flag"

5. Approach consideration: The cleanest approach is to have the export command run `forge generate` first (ensuring gen/ exists), then import and call a spec-building function from gen/api. However, since gen/ is user-project code (not forge framework code), the CLI can't import it directly. Instead:
   - Build the OpenAPI spec programmatically from IR (same data the templates use)
   - Register Huma operations using data from IR — the same resource names, field types, and modifiers
   - This produces an accurate spec without needing compiled user code
   - Create a helper function `buildSpecFromIR(resources []parser.ResourceIR, projectModule string) ([]byte, error)` that does the in-memory registration and spec extraction

**internal/cli/root.go** — register the openapi command group:
- Add `rootCmd.AddCommand(openapiCmd)` alongside routes
- openapiCmd.AddCommand(openapiExportCmd)
  </action>
  <verify>
Run `go build ./cmd/forge/` to confirm the CLI compiles. Run `go vet ./internal/cli/`. Verify `forge openapi --help` shows export subcommand. Verify `forge openapi export --help` shows --format flag.
  </verify>
  <done>
forge openapi export command builds OpenAPI spec from parsed schemas and writes to file. Supports --format json|yaml per user decision. Creates in-memory Huma API from IR for spec generation. Command registered as subcommand of forge openapi.
  </done>
</task>

</tasks>

<verification>
1. `go build ./cmd/forge/` — clean compile
2. `go vet ./internal/cli/` — no issues
3. `forge routes --help` — shows command description
4. `forge openapi --help` — shows export subcommand
5. `forge openapi export --help` — shows --format flag with json/yaml options
6. Route listing is grouped by resource (not flat table) per user decision
7. Routes show correct /api/v1/{kebab-plural} paths with SDK-ready operationIds
</verification>

<success_criteria>
- forge routes lists API routes grouped by resource with method, path, and operationId
- Output is color-coded and column-aligned for scannability (feels like rails routes per user request)
- forge openapi export writes OpenAPI 3.1 spec to file
- Export supports --format json and --format yaml per user decision
- Default export filename is openapi.json (or openapi.yaml if --format yaml)
- Both commands derive routes/spec from parsed schema IR (no compiled user code needed)
- Commands registered in root.go alongside existing forge commands
</success_criteria>

<output>
After completion, create `.planning/phases/05-rest-api-generation/05-04-SUMMARY.md`
</output>
