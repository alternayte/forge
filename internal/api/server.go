package api

import (
	"net/http"

	"github.com/danielgtaylor/huma/v2"
	"github.com/danielgtaylor/huma/v2/adapters/humachi"
	"github.com/go-chi/chi/v5"
	chimiddleware "github.com/go-chi/chi/v5/middleware"

	apimiddleware "github.com/alternayte/forge/internal/api/middleware"
	"github.com/alternayte/forge/forge/auth"
	"github.com/alternayte/forge/internal/config"
)

// SetupAPI creates a Huma API instance on the provided Chi router, wires all middleware in
// the correct order, then calls registerRoutes to register every generated resource endpoint.
//
// Middleware order (per security and operational best-practices):
//  1. Chi-level: RealIP — extract real client IP before any processing
//  2. Chi-level: Logger — log every request with final status code
//  3. Chi-level: Recovery (gen/middleware) — catch panics before they terminate the process
//  4. Huma-level: CORS — set cross-origin headers before auth check
//  5. Huma-level: RateLimit — enforce rate limits before expensive auth lookup
//  6. Huma-level: Auth — validate bearer tokens / API keys
//
// After all middleware is wired, SetupAPI calls registerRoutes (i.e. genapi.RegisterAllRoutes)
// to register all generated CRUD endpoints. Huma automatically serves the OpenAPI spec at
// /api/openapi.json and /api/openapi.yaml because OpenAPIPath is set to "/api/openapi".
// The Scalar UI docs handler must be registered separately via RegisterDocsHandler.
//
// Example wiring in a generated project's main.go:
//
//	api, err := apiserver.SetupAPI(router, cfg.API, tokenStore, apiKeyStore, gen_middleware.Recovery, genapi.RegisterAllRoutes)
func SetupAPI(
	router chi.Router,
	cfg config.APIConfig,
	tokenStore auth.TokenStore,
	apiKeyStore auth.APIKeyStore,
	recoveryMiddleware func(http.Handler) http.Handler,
	registerRoutes func(api huma.API),
) (huma.API, error) {
	// --- Chi-level middleware (runs before Huma processes the request) ---

	// 1. RealIP: extract real client IP from X-Real-IP / X-Forwarded-For headers.
	//    Must be first so rate limiting and logging use the actual client address.
	router.Use(chimiddleware.RealIP)

	// 2. Logger: log each request with method, path, status, latency, and remote address.
	router.Use(chimiddleware.Logger)

	// 3. Recovery: catch panics and return HTTP 500 without crashing the server.
	//    Uses the generated gen/middleware.Recovery that produces forge error shapes.
	router.Use(recoveryMiddleware)

	// --- Huma API instance ---

	humaConfig := huma.DefaultConfig("Forge API", "1.0.0")
	humaConfig.Info.Description = "Production-ready REST API generated by Forge"
	// OpenAPIPath drives both /api/openapi.json and /api/openapi.yaml natively in Huma v2.
	humaConfig.OpenAPIPath = "/api/openapi"
	// Disable Huma's built-in CDN-hosted Stoplight Elements docs — we serve Scalar UI instead.
	humaConfig.DocsPath = ""

	api := humachi.New(router, humaConfig)

	// --- Huma-level middleware (wraps individual operation handlers) ---

	// 4. CORS: set cross-origin headers. Runs early so preflight OPTIONS requests short-circuit.
	corsHandler := apimiddleware.CORSMiddleware(cfg.CORS)
	api.UseMiddleware(wrapHTTPMiddleware(corsHandler))

	// 5. RateLimit: enforce per-IP token-bucket limits. Runs after CORS so OPTIONS pass through,
	//    and before auth so unauthenticated probing is bounded.
	rateLimitHandler, err := apimiddleware.RateLimitMiddleware(cfg.RateLimit)
	if err != nil {
		return nil, err
	}
	api.UseMiddleware(wrapHTTPMiddleware(rateLimitHandler))

	// 6. Auth: validate bearer tokens and API keys. Must run last so auth context values
	//    (user_id, api_key_id) are available to route handlers.
	authMiddleware := apimiddleware.NewAuthMiddleware(api, tokenStore, apiKeyStore)
	api.UseMiddleware(authMiddleware.Handle)

	// --- Route registration ---

	// RegisterAllRoutes wires all generated CRUD endpoints onto the Huma API.
	// This is called AFTER all middleware is wired so every endpoint inherits the
	// complete middleware chain (CORS -> RateLimit -> Auth).
	if registerRoutes != nil {
		registerRoutes(api)
	}

	return api, nil
}

// wrapHTTPMiddleware converts a standard Go http.Handler middleware into a Huma middleware.
// This bridges the gap between Chi-style http.Handler wrappers (CORS, rate limit) and
// Huma's context-based middleware interface.
func wrapHTTPMiddleware(mw func(http.Handler) http.Handler) func(huma.Context, func(huma.Context)) {
	return func(ctx huma.Context, next func(huma.Context)) {
		// Unwrap the huma.Context to get the underlying http.Request and ResponseWriter.
		r, w := humachi.Unwrap(ctx)

		// Run the standard middleware, calling next(ctx) as the inner handler.
		mw(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {
			next(ctx)
		})).ServeHTTP(w, r)
	}
}

// ServerConfig groups the configuration dependencies needed to set up the API server.
// This is a convenience struct for applications that assemble the server from a single
// configuration object rather than passing each dependency individually.
type ServerConfig struct {
	APIConfig   config.APIConfig
	TokenStore  auth.TokenStore
	APIKeyStore auth.APIKeyStore
}

