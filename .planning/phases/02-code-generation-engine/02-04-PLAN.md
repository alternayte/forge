---
phase: 02-code-generation-engine
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - internal/migrate/commands.go
  - internal/migrate/destructive.go
  - internal/migrate/migrate_test.go
  - internal/cli/migrate.go
  - internal/cli/root.go
autonomous: true

must_haves:
  truths:
    - "forge migrate diff generates a SQL migration file by running Atlas CLI against gen/atlas/schema.hcl"
    - "forge migrate up applies pending migrations via Atlas CLI"
    - "forge migrate down rolls back the last migration via Atlas CLI"
    - "forge migrate status shows current migration state via Atlas CLI"
    - "Destructive migrations (DROP TABLE, DROP COLUMN, ALTER COLUMN TYPE) print a prominent warning and require --force flag"
    - "Hand-written SQL migration files in migrations/ directory are preserved and included in Atlas operations"
  artifacts:
    - path: "internal/migrate/commands.go"
      provides: "Atlas CLI wrapper functions for diff, up, down, status"
      exports: ["Diff", "Up", "Down", "Status"]
    - path: "internal/migrate/destructive.go"
      provides: "Destructive migration change detection via SQL parsing"
      exports: ["ContainsDestructiveChange", "DestructiveWarning"]
    - path: "internal/cli/migrate.go"
      provides: "forge migrate {diff,up,down,status} CLI commands"
      exports: ["newMigrateCmd"]
  key_links:
    - from: "internal/migrate/commands.go"
      to: "internal/toolsync/download.go"
      via: "Ensures Atlas binary is available before running commands"
      pattern: "toolsync\\.ToolBinPath|toolsync\\.IsToolInstalled"
    - from: "internal/migrate/commands.go"
      to: "gen/atlas/schema.hcl"
      via: "Points Atlas --to flag at generated HCL schema"
      pattern: "gen/atlas/schema\\.hcl"
    - from: "internal/cli/migrate.go"
      to: "internal/migrate/commands.go"
      via: "CLI commands call migrate package functions"
      pattern: "migrate\\.(Diff|Up|Down|Status)"
    - from: "internal/cli/migrate.go"
      to: "internal/config/config.go"
      via: "Reads database URL from forge.toml"
      pattern: "config\\.Load"
---

<objective>
Create Atlas migration management commands (diff, up, down, status) with destructive change detection and safety warnings.

Purpose: Migrations bridge the gap between generated HCL schema and the live database. Developers need to diff schema changes into SQL files, apply them, roll back when needed, and check status -- all through the forge CLI wrapping Atlas.
Output: internal/migrate/ package with Atlas CLI wrappers, destructive change detection, and forge migrate {diff,up,down,status} CLI commands.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-code-generation-engine/02-RESEARCH.md
@.planning/phases/02-code-generation-engine/02-01-SUMMARY.md
@internal/toolsync/download.go
@internal/config/config.go
@internal/cli/root.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create migrate package with Atlas CLI wrappers and destructive change detection</name>
  <files>
    internal/migrate/commands.go
    internal/migrate/destructive.go
    internal/migrate/migrate_test.go
  </files>
  <action>
Create the migrate package that wraps Atlas CLI commands and detects destructive changes.

1. **internal/migrate/commands.go**: Create Atlas CLI wrapper functions.

Define a `Config` struct:
```go
type Config struct {
    AtlasBin     string // Path to atlas binary
    MigrationDir string // Path to migrations/ directory
    SchemaURL    string // Path to gen/atlas/schema.hcl (file:// URL)
    DatabaseURL  string // PostgreSQL connection URL
    DevURL       string // Dev database URL for atlas diff
}
```

Implement these functions:

- `func Diff(cfg Config, name string, force bool) (string, error)`:
  - Runs: `atlas migrate diff {name} --dir file://{cfg.MigrationDir} --to file://{cfg.SchemaURL} --dev-url {cfg.DevURL}`
  - Captures stdout+stderr
  - If diff generates a migration file, read it from migrations/ directory (find newest .sql file)
  - If not force, check for destructive changes via ContainsDestructiveChange()
  - If destructive and not force, return error with DestructiveWarning message
  - Return path to new migration file on success

- `func Up(cfg Config) (string, error)`:
  - Runs: `atlas migrate apply --dir file://{cfg.MigrationDir} --url {cfg.DatabaseURL}`
  - Returns Atlas output

- `func Down(cfg Config) (string, error)`:
  - Runs: `atlas migrate down --dir file://{cfg.MigrationDir} --url {cfg.DatabaseURL} --dev-url {cfg.DevURL}`
  - Returns Atlas output

- `func Status(cfg Config) (string, error)`:
  - Runs: `atlas migrate status --dir file://{cfg.MigrationDir} --url {cfg.DatabaseURL}`
  - Returns Atlas output

- `func Hash(cfg Config) error`:
  - Runs: `atlas migrate hash --dir file://{cfg.MigrationDir}`
  - Used after manual edits to recompute atlas.sum

All commands use exec.Command to shell out to the Atlas binary. Each checks that atlas binary exists (using cfg.AtlasBin path) and returns clear error if not: "atlas binary not found. Run 'forge tool sync' to download it."

2. **internal/migrate/destructive.go**: Create destructive change detection.

```go
var destructivePatterns = []*regexp.Regexp{
    regexp.MustCompile(`(?i)DROP\s+TABLE`),
    regexp.MustCompile(`(?i)DROP\s+COLUMN`),
    regexp.MustCompile(`(?i)ALTER\s+COLUMN\s+\S+\s+TYPE`),
    regexp.MustCompile(`(?i)DROP\s+INDEX`),
}

func ContainsDestructiveChange(sql string) bool
func FindDestructiveChanges(sql string) []string  // returns matching lines
func DestructiveWarning(changes []string) string   // formatted warning message
```

The DestructiveWarning should produce:
```
WARNING: Destructive migration detected!

This migration contains operations that will permanently delete data:
  - DROP COLUMN "name" (line 5)
  - DROP TABLE "old_products" (line 12)

If you are CERTAIN you want to proceed, run:
  forge migrate diff --force

Otherwise, review your schema changes.
```

Use ui.WarnStyle and ui.ErrorIcon for styling.

3. **internal/migrate/migrate_test.go**: Create tests:
   - TestContainsDestructiveChange_DropTable: Verify DROP TABLE detected
   - TestContainsDestructiveChange_DropColumn: Verify DROP COLUMN detected
   - TestContainsDestructiveChange_AlterType: Verify ALTER COLUMN TYPE detected
   - TestContainsDestructiveChange_SafeChanges: Verify ADD COLUMN, CREATE TABLE, CREATE INDEX are NOT flagged
   - TestFindDestructiveChanges_MultipleMatches: Verify all destructive lines found
   - TestDestructiveWarning_Format: Verify warning message format includes instructions

Note: Atlas CLI integration tests require a running database, so unit tests focus on destructive detection logic and command construction. Do NOT write tests that require `atlas` binary or PostgreSQL.
  </action>
  <verify>
Run `go test ./internal/migrate/ -v` -- all tests pass. Run `go build ./internal/migrate/` -- compiles. Run `go vet ./internal/migrate/`.
  </verify>
  <done>
Migrate package exists with Atlas CLI wrappers (Diff, Up, Down, Status, Hash) and destructive change detection. Destructive patterns detect DROP TABLE, DROP COLUMN, ALTER TYPE, DROP INDEX. Warning message includes specific changes and --force instruction. Unit tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire forge migrate CLI commands</name>
  <files>
    internal/cli/migrate.go
    internal/cli/root.go
  </files>
  <action>
Create the forge migrate command group with diff, up, down, and status subcommands.

1. **internal/cli/migrate.go**: Create newMigrateCmd() as parent command with subcommands:

```go
func newMigrateCmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "migrate",
        Short: "Manage database migrations",
        Long:  `Create, apply, and manage database migrations using Atlas.`,
    }
    cmd.AddCommand(
        newMigrateDiffCmd(),
        newMigrateUpCmd(),
        newMigrateDownCmd(),
        newMigrateStatusCmd(),
    )
    return cmd
}
```

**newMigrateDiffCmd():**
- Use: "diff [name]", Short: "Create a new migration from schema changes"
- Flags: `--force` (bool) to bypass destructive change warning
- RunE logic:
  a. Find project root (forge.toml)
  b. Load config for database URL
  c. Determine atlas binary path from toolsync.ToolBinPath("atlas", projectRoot)
  d. Check if atlas installed, if not prompt to run `forge tool sync`
  e. Check gen/atlas/schema.hcl exists, if not error: "No schema found. Run 'forge generate' first."
  f. Get migration name from args (default: "migration" with timestamp)
  g. Build migrate.Config with paths
  h. Call migrate.Diff(cfg, name, force)
  i. On success: print created migration file path with ui.Success
  j. On destructive error: print warning (already formatted by migrate package)

**newMigrateUpCmd():**
- Use: "up", Short: "Apply pending migrations"
- RunE: Find root, load config, check atlas, call migrate.Up(cfg), print result

**newMigrateDownCmd():**
- Use: "down", Short: "Roll back the last migration"
- RunE: Find root, load config, check atlas, call migrate.Down(cfg), print result

**newMigrateStatusCmd():**
- Use: "status", Short: "Show current migration state"
- RunE: Find root, load config, check atlas, call migrate.Status(cfg), print result

All subcommands should use the DevURL from config or construct a sensible default. The database URL comes from config.Database.URL. The migration directory is `{projectRoot}/migrations/`.

For the DevURL (used by Atlas for diffing), use: `config.Database.URL` with a `_dev` suffix on the database name, or accept a `--dev-url` flag. Default to the main database URL if not specified (Atlas creates a temporary schema).

MIGRATE-06 (hand-written migrations): Supported automatically because Atlas versioned workflow reads ALL .sql files from the migrations/ directory. Hand-written files are preserved alongside generated ones. The atlas.sum file tracks integrity of all files. If a developer adds a manual .sql file, they should run `forge migrate hash` to update the checksum. Document this in the `--help` long description.

2. **Update internal/cli/root.go**: Add `rootCmd.AddCommand(newMigrateCmd())` in init().
  </action>
  <verify>
Run `go build .` -- forge binary compiles. Run `forge migrate --help` -- shows subcommands (diff, up, down, status). Run `forge migrate diff --help` -- shows --force flag. Run `go vet ./internal/cli/`.
  </verify>
  <done>
forge migrate command group exists with diff, up, down, status subcommands. diff has --force flag for destructive changes. All commands read config from forge.toml, locate atlas binary, and delegate to migrate package. migrate registered in root CLI. Build compiles cleanly.
  </done>
</task>

</tasks>

<verification>
1. `go build .` compiles forge binary with migrate commands
2. `go test ./internal/migrate/ -v` all tests pass
3. `forge migrate --help` shows diff, up, down, status subcommands
4. `forge migrate diff --help` shows --force flag and description
5. Destructive changes in SQL are detected and produce formatted warnings
6. Hand-written migration files are documented as supported in help text
</verification>

<success_criteria>
- forge migrate diff runs Atlas schema diff against gen/atlas/schema.hcl
- forge migrate up/down applies/rolls back migrations
- forge migrate status shows migration state
- Destructive changes detected and blocked without --force
- Atlas binary checked and helpful error shown if missing
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-code-generation-engine/02-04-SUMMARY.md`
</output>
