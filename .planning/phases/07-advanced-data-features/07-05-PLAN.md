---
phase: 07-advanced-data-features
plan: 05
type: execute
wave: 4
depends_on: ["07-03", "07-04"]
files_modified:
  - internal/generator/templates/model.go.tmpl
  - internal/generator/templates/atlas_schema.hcl.tmpl
  - internal/generator/templates/actions.go.tmpl
  - internal/generator/templates/api_register.go.tmpl
autonomous: true
requirements:
  - AUDIT-01
  - AUDIT-02
  - AUDIT-03

must_haves:
  truths:
    - "When Auditable is true, model has CreatedBy and UpdatedBy uuid.UUID fields auto-populated from context user"
    - "When Auditable is true, Create and Update methods record changes in audit_logs table with JSONB diffs"
    - "No-op updates (no actual changes) do not generate audit log entries"
    - "Creation is recorded as first audit entry with all initial field values"
    - "audit_logs table is generated once (static block) when any resource is Auditable"
    - "GET /api/v1/{resource}/:id/audit endpoint returns audit log entries for a resource"
    - "DATA-12 (eager loading with soft-delete awareness) is deferred — blocked by Bob query execution integration; Eager IR flag is set (Plan 01) but batch loading not yet implemented"
  artifacts:
    - path: "internal/generator/templates/model.go.tmpl"
      provides: "CreatedBy and UpdatedBy fields when Auditable"
      contains: "CreatedBy"
    - path: "internal/generator/templates/atlas_schema.hcl.tmpl"
      provides: "created_by/updated_by columns when Auditable; audit_logs static table"
      contains: "audit_logs"
    - path: "internal/generator/templates/actions.go.tmpl"
      provides: "recordAudit helper, computeJSONDiff, audit calls in Create/Update"
      contains: "recordAudit"
    - path: "internal/generator/templates/api_register.go.tmpl"
      provides: "GET audit log endpoint for Auditable resources"
      contains: "audit"
  key_links:
    - from: "internal/generator/templates/actions.go.tmpl"
      to: "internal/auth/context.go"
      via: "recordAudit reads UserFromContext for created_by column"
      pattern: "UserFromContext"
    - from: "internal/generator/templates/atlas_schema.hcl.tmpl"
      to: "hasAuditableResource funcmap"
      via: "audit_logs table only emitted when hasAuditableResource is true"
      pattern: "hasAuditableResource"
---

<objective>
Implement audit logging (JSONB diffs, created_by/updated_by auto-population, no-op detection), the audit_logs table, and audit API endpoint.

Purpose: AUDIT-01 through AUDIT-03 require complete change tracking for Auditable resources. Note: DATA-12 (eager loading with soft-delete awareness) is deferred to a future phase, blocked by Bob query execution integration. The Eager IR flag is already set (Plan 01) but batch loading cannot be implemented until Bob queries are wired.

Output: Updated model, atlas, actions, and api_register templates with audit logging logic.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-RESEARCH.md
@.planning/phases/07-advanced-data-features/07-01-SUMMARY.md
@.planning/phases/07-advanced-data-features/07-03-SUMMARY.md
@.planning/phases/07-advanced-data-features/07-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add audit columns to model/atlas and audit_logs static table</name>
  <files>
    internal/generator/templates/model.go.tmpl
    internal/generator/templates/atlas_schema.hcl.tmpl
  </files>
  <action>
    1. In `model.go.tmpl`, add CreatedBy and UpdatedBy fields to the main model struct when Auditable. Place these AFTER the timestamp fields and SoftDelete field:

       ```
       {{- if .Options.Auditable}}
       CreatedBy *uuid.UUID `json:"created_by,omitempty" db:"created_by"`
       UpdatedBy *uuid.UUID `json:"updated_by,omitempty" db:"updated_by"`
       {{- end}}
       ```

       Use pointer types since they can be null (user might not be authenticated when creating via system operations).

    2. In `atlas_schema.hcl.tmpl`, add created_by and updated_by columns inside the table block when Auditable. Place AFTER the SoftDelete column block (and after TenantScoped column if present):

       ```
       {{if .Options.Auditable}}
       column "created_by" {
         type = uuid
         null = true
       }
       column "updated_by" {
         type = uuid
         null = true
       }
       {{end}}
       ```

    3. In `atlas_schema.hcl.tmpl`, add the audit_logs static table OUTSIDE the `{{range .Resources}}` loop, AFTER the sessions table block. Guard with `hasAuditableResource`:

       ```
       {{if hasAuditableResource .Resources}}
       # Audit log table for tracking all changes to Auditable resources.
       # Single shared table — resource_type and resource_id identify the target.
       # Per design: full before/after JSONB diff for every changed field.
       table "audit_logs" {
         schema = schema.public

         column "id" {
           type    = uuid
           default = sql("gen_random_uuid()")
           null    = false
         }
         column "resource_type" {
           type = varchar(255)
           null = false
         }
         column "resource_id" {
           type = uuid
           null = false
         }
         column "operation" {
           type = varchar(50)
           null = false
         }
         column "changed_fields" {
           type = jsonb
           null = true
         }
         column "created_by" {
           type = uuid
           null = true
         }
         column "created_at" {
           type    = timestamptz
           default = sql("now()")
           null    = false
         }

         primary_key {
           columns = [column.id]
         }

         index "audit_logs_resource_idx" {
           columns = [column.resource_type, column.resource_id]
         }
         index "audit_logs_created_at_idx" {
           columns = [column.created_at]
         }
       }
       {{end}}
       ```

       This follows the pattern of the sessions table (static block outside the resource range loop). The `hasAuditableResource` funcmap helper (from Plan 01) ensures it's only emitted when at least one resource has Auditable enabled.

    4. The template data for the atlas template uses `.Resources` (the full slice). The `hasAuditableResource` funcmap takes `[]parser.ResourceIR` and returns true if any has `.Options.Auditable`. Verify the atlas generator passes the resources slice — check the existing `GenerateAtlasSchema` function signature. It should already pass resources since the template uses `{{range .Resources}}`.
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Review atlas_schema.hcl.tmpl to confirm audit_logs table is OUTSIDE the range loop and AFTER sessions table.
  </verify>
  <done>
    model.go.tmpl has CreatedBy and UpdatedBy pointer UUID fields when Auditable. atlas_schema.hcl.tmpl has created_by/updated_by columns in resource tables when Auditable. audit_logs static table is generated once (not per-resource) with resource_type, resource_id, operation, changed_fields JSONB, created_by, created_at columns, and proper indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add audit recording to actions and audit API endpoint</name>
  <files>
    internal/generator/templates/actions.go.tmpl
    internal/generator/templates/api_register.go.tmpl
  </files>
  <action>
    1. In `actions.go.tmpl`, add audit helper functions AFTER the permission check function, guarded by `{{- if .Options.Auditable}}`:

       a. `computeJSONDiff` function:
       ```
       {{- if .Options.Auditable}}
       // computeJSONDiff compares two map representations and returns only changed fields.
       // Each changed field has "before" and "after" values. Returns nil if no changes.
       func computeJSONDiff(before, after map[string]any) map[string]any {
           diff := make(map[string]any)
           for k, afterVal := range after {
               beforeVal, exists := before[k]
               if !exists {
                   diff[k] = map[string]any{"before": nil, "after": afterVal}
               } else if !reflect.DeepEqual(beforeVal, afterVal) {
                   diff[k] = map[string]any{"before": beforeVal, "after": afterVal}
               }
           }
           // Check for deleted keys (in before but not in after)
           for k, beforeVal := range before {
               if _, exists := after[k]; !exists {
                   diff[k] = map[string]any{"before": beforeVal, "after": nil}
               }
           }
           if len(diff) == 0 {
               return nil
           }
           return diff
       }
       {{- end}}
       ```

       b. `recordAudit` method on Default{{.Name}}Actions:
       ```
       {{- if .Options.Auditable}}
       // recordAudit records a change to the audit_logs table.
       // before is nil for creates (all fields recorded as new values).
       // If before and after are identical, no entry is recorded (AUDIT-03: no-op updates).
       func (a *Default{{.Name}}Actions) recordAudit(ctx context.Context, op string, resourceID uuid.UUID, before, after any) error {
           var beforeMap, afterMap map[string]any

           if before != nil {
               b, _ := json.Marshal(before)
               json.Unmarshal(b, &beforeMap)
           }
           a2, _ := json.Marshal(after)
           json.Unmarshal(a2, &afterMap)

           diff := computeJSONDiff(beforeMap, afterMap)
           if diff == nil && op != "create" {
               return nil // No changes — skip audit entry (AUDIT-03)
           }

           // For creates, record all fields as the diff
           if op == "create" && diff == nil {
               diff = afterMap
           }

           userID := forgeauth.UserFromContext(ctx)
           diffJSON, _ := json.Marshal(diff)

           var userIDPtr *uuid.UUID
           if userID != (uuid.UUID{}) {
               userIDPtr = &userID
           }

           _, err := a.DB.Exec(ctx,
               `INSERT INTO audit_logs (resource_type, resource_id, operation, changed_fields, created_by)
                VALUES ($1, $2, $3, $4, $5)`,
               "{{snake .Name}}", resourceID, op, diffJSON, userIDPtr,
           )
           return err
       }
       {{- end}}
       ```

       Add needed imports conditionally:
       ```
       {{- if .Options.Auditable}}
       "encoding/json"
       "reflect"
       {{- end}}
       ```

    2. Wire audit recording into Create and Update methods:

       In Create, AFTER the successful create operation (after the new record is returned), add:
       ```
       {{- if .Options.Auditable}}
       // Record creation in audit log — all initial field values (AUDIT-02)
       if err := a.recordAudit(ctx, "create", item.ID, nil, item); err != nil {
           // Log audit error but don't fail the create operation
           _ = err
       }
       {{- end}}
       ```

       ALSO in Create, set CreatedBy from context:
       ```
       {{- if .Options.Auditable}}
       // Auto-populate created_by from authenticated user (AUDIT-01)
       userID := forgeauth.UserFromContext(ctx)
       if userID != (uuid.UUID{}) {
           // Set created_by in the insert query
       }
       {{- end}}
       ```
       Since the Create method currently has a TODO placeholder for Bob execution, add a comment indicating created_by should be set from context when the query is implemented.

       In Update, BEFORE the update query, fetch the before-state. AFTER the update, compute diff and record:
       ```
       {{- if .Options.Auditable}}
       // Fetch before-state for audit diff (must happen before UPDATE)
       beforeItem, _ := a.Get(ctx, id)
       {{- end}}
       ```
       After update:
       ```
       {{- if .Options.Auditable}}
       // Record update in audit log with JSONB diff (AUDIT-02)
       // No-op updates produce empty diff — no audit entry (AUDIT-03)
       if beforeItem != nil {
           if err := a.recordAudit(ctx, "update", id, beforeItem, item); err != nil {
               _ = err // Log but don't fail the update
           }
       }
       {{- end}}
       ```

       In Delete (soft delete path), record the delete operation:
       ```
       {{- if .Options.Auditable}}
       // Record soft-delete in audit log
       a.recordAudit(ctx, "delete", id, nil, map[string]any{"deleted_at": "now"})
       {{- end}}
       ```

    3. In `api_register.go.tmpl`, add GET audit endpoint for Auditable resources. Add AFTER the Delete route registration, inside a `{{- if .Options.Auditable}}` guard:

       ```
       {{- if .Options.Auditable}}
       // List audit log entries for a {{.Name}}
       huma.Register(api, huma.Operation{
           OperationID: "list{{.Name}}AuditLog",
           Method:      http.MethodGet,
           Path:        "/api/v1/{{kebab (plural .Name)}}/{id}/audit",
           Summary:     "List audit log for a {{.Name}}",
           Tags:        []string{"{{kebab .Name}}"},
       }, func(ctx context.Context, input *Get{{.Name}}Input) (*struct {
           Body struct {
               Data []map[string]any `json:"data"`
           }
       }, error) {
           id, err := uuid.Parse(input.ID)
           if err != nil {
               return nil, huma.Error400BadRequest("invalid {{.Name}} ID format")
           }

           // Query audit_logs for this resource
           rows, err := act.(interface{ GetDB() actions.DB }).GetDB().Query(ctx,
               `SELECT id, operation, changed_fields, created_by, created_at
                FROM audit_logs
                WHERE resource_type = $1 AND resource_id = $2
                ORDER BY created_at DESC`,
               "{{snake .Name}}", id,
           )
           if err != nil {
               return nil, toHumaError(err)
           }
           defer rows.Close()

           var entries []map[string]any
           for rows.Next() {
               var entryID uuid.UUID
               var operation string
               var changedFields json.RawMessage
               var createdBy *uuid.UUID
               var createdAt time.Time
               if err := rows.Scan(&entryID, &operation, &changedFields, &createdBy, &createdAt); err != nil {
                   continue
               }
               entries = append(entries, map[string]any{
                   "id":             entryID,
                   "operation":      operation,
                   "changed_fields": json.RawMessage(changedFields),
                   "created_by":     createdBy,
                   "created_at":     createdAt,
               })
           }

           out := &struct {
               Body struct {
                   Data []map[string]any `json:"data"`
               }
           }{}
           out.Body.Data = entries
           return out, nil
       })
       {{- end}}
       ```

       Add conditional imports at top of api_register.go.tmpl:
       ```
       {{- if .Options.Auditable}}
       "encoding/json"
       "time"
       {{- end}}
       ```

       Note: The audit endpoint accesses the DB directly since audit_logs is a static shared table, not a per-resource action. The `act.(interface{ GetDB() actions.DB }).GetDB()` type assertion assumes DefaultActions exposes a GetDB method. Add a `GetDB` method to DefaultActions in actions.go.tmpl:
       ```
       // GetDB returns the database connection for direct queries (e.g., audit log).
       func (a *Default{{.Name}}Actions) GetDB() DB {
           return a.DB
       }
       ```

    Note: DATA-12 (eager loading with soft-delete awareness) is NOT addressed in this plan. It is blocked by Bob query execution integration. The Eager IR flag exists (Plan 01), but actual batch loading implementation is deferred to a future phase when Bob queries are fully wired.
  </action>
  <verify>
    Run `cd /Users/nathananderson-tennant/Development/forge-go && go build ./internal/generator/...` — compiles. Review actions.go.tmpl for recordAudit, computeJSONDiff, audit calls in Create/Update/Delete. Review api_register.go.tmpl for audit endpoint.
  </verify>
  <done>
    recordAudit method records JSONB diffs to audit_logs table. computeJSONDiff computes field-level before/after changes. Create records all initial values as first audit entry. Update fetches before-state and records diff; no-op updates produce no audit entry (AUDIT-03). Delete records soft-delete in audit log. API endpoint GET /api/v1/{resource}/:id/audit returns audit entries. GetDB method exposed on DefaultActions for audit queries.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/generator/...` compiles
2. model.go.tmpl has CreatedBy/UpdatedBy when Auditable
3. atlas_schema.hcl.tmpl has audit_logs static table with hasAuditableResource guard
4. actions.go.tmpl has recordAudit with JSONB diff computation
5. Create method calls recordAudit("create", ...) after successful create
6. Update method fetches before-state, computes diff, skips audit on no-op (AUDIT-03)
7. api_register.go.tmpl has GET .../audit endpoint inside Auditable guard
</verification>

<success_criteria>
Audit logging is fully wired: created_by/updated_by auto-populated, JSONB diffs recorded for all changes, no-op updates skipped, audit_logs table generated once, and API endpoint exposes audit history. Note: DATA-12 (eager loading with soft-delete awareness) is deferred to a future phase, blocked by Bob query execution integration. All other Phase 7 requirements (SCHEMA-07, SCHEMA-08, DATA-05 through DATA-09, AUTH-05, AUTH-06, TENANT-01 through TENANT-04, AUDIT-01 through AUDIT-03) are addressed across Plans 01-05.
</success_criteria>

<output>
After completion, create `.planning/phases/07-advanced-data-features/07-05-SUMMARY.md`
</output>
