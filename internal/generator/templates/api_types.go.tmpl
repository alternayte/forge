// Code generated by forge generate. DO NOT EDIT.

package api

import (
	"fmt"
	"net/http"

	"github.com/danielgtaylor/huma/v2"
	"{{.ProjectModule}}/gen/errors"
)

// PaginationMeta contains cursor-based pagination metadata returned with list responses.
type PaginationMeta struct {
	// NextCursor is the opaque cursor for fetching the next page.
	NextCursor string `json:"next_cursor,omitempty" doc:"Cursor for next page"`
	// HasMore indicates whether additional results exist beyond the current page.
	HasMore bool `json:"has_more" doc:"Whether more results exist"`
}

// toHumaError converts a forge error to a Huma API error.
// It maps forge.Error status codes to appropriate Huma HTTP error responses,
// including per-field validation details for 422 responses.
func toHumaError(err error) huma.StatusError {
	if err == nil {
		return nil
	}

	var forgeErr *errors.Error
	if fe, ok := err.(*errors.Error); ok {
		forgeErr = fe
	} else {
		// Unknown error type — treat as internal server error
		return huma.Error500InternalServerError("internal server error")
	}

	switch forgeErr.Status {
	case http.StatusNotFound:
		return huma.Error404NotFound(forgeErr.Message)
	case http.StatusConflict:
		return huma.Error409Conflict(forgeErr.Message)
	case http.StatusUnprocessableEntity:
		// Validation error — include detail as error context
		detail := &huma.ErrorDetail{
			Message: forgeErr.Detail,
		}
		return huma.Error422UnprocessableEntity(forgeErr.Message, detail)
	case http.StatusBadRequest:
		return huma.Error400BadRequest(forgeErr.Message)
	case http.StatusUnauthorized:
		return huma.Error401Unauthorized(forgeErr.Message)
	case http.StatusForbidden:
		return huma.Error403Forbidden(forgeErr.Message)
	default:
		return huma.Error500InternalServerError(forgeErr.Message)
	}
}

// buildAPILinkHeader builds an RFC 8288 Link header value for cursor pagination.
// Returns the header string in the format: <{path}?cursor={cursor}&limit={limit}>; rel="next"
func buildAPILinkHeader(basePath string, cursor string, limit int) string {
	return fmt.Sprintf(`<%s?cursor=%s&limit=%d>; rel="next"`, basePath, cursor, limit)
}
