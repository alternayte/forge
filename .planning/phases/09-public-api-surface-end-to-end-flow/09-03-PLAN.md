---
phase: 09-public-api-surface-end-to-end-flow
plan: 03
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - forge/forge.go
  - forge/errors.go
  - forge/transaction.go
  - forge/config.go
autonomous: true
requirements: []

must_haves:
  truths:
    - "forge.New(cfg) creates an App instance"
    - "forge.App has RegisterAPIRoutes(func(huma.API)) and RegisterHTMLRoutes(func(chi.Router)) methods"
    - "forge.App.Listen(addr) starts the HTTP server and blocks until shutdown"
    - "forge.LoadConfig(path) loads forge.toml and returns a Config"
    - "forge.Error struct is defined with Status, Code, Message, Detail, Err fields"
    - "forge.Transaction wraps pgx transactions"
    - "go build ./... compiles with the new forge package"
  artifacts:
    - path: "forge/forge.go"
      provides: "App builder type"
      contains: "func New"
    - path: "forge/errors.go"
      provides: "forge.Error type"
      contains: "type Error struct"
    - path: "forge/transaction.go"
      provides: "Transaction wrapper"
      contains: "type Transaction struct"
    - path: "forge/config.go"
      provides: "Config and LoadConfig"
      contains: "func LoadConfig"
  key_links:
    - from: "forge/forge.go"
      to: "internal/api/server.go"
      via: "import internal/api for SetupAPI and SetupHTML"
      pattern: "api\\.SetupAPI"
    - from: "forge/config.go"
      to: "internal/config/config.go"
      via: "wraps internal config loading"
      pattern: "config\\.Load"
    - from: "forge/forge.go"
      to: "forge/auth/"
      via: "session manager setup"
      pattern: "auth\\.NewSessionManager"
---

<objective>
Create the public forge package at the repo root with runtime types: App builder, Error, Transaction, and Config loader.

Purpose: This is the "what you call" half of the two-package mental model (schema is what you write, forge is what you call). forge.App manages the application lifecycle — DB pool, session manager, HTTP server, graceful shutdown. Generated main.go calls forge.New(cfg).RegisterAPIRoutes(...).Listen(":8080").

Output: Four new files in forge/ providing the complete runtime API for generated applications.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-RESEARCH.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-01-SUMMARY.md
@internal/api/server.go
@internal/api/html_server.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forge.App builder and Config loader</name>
  <files>
    forge/forge.go
    forge/config.go
  </files>
  <action>
Create the core App builder and Config types in the public forge package.

**forge/config.go** — Config loader that wraps internal/config:

```go
package forge

import (
    "github.com/alternayte/forge/internal/config"
)

// Config is the runtime configuration for a forge application.
// Load from forge.toml with LoadConfig, or construct programmatically for testing.
type Config struct {
    cfg *config.Config
}

// LoadConfig reads forge.toml from the given path and returns a Config.
// Environment variable overrides (FORGE_*) are applied automatically.
func LoadConfig(path string) (Config, error) {
    cfg, err := config.Load(path)
    if err != nil {
        return Config{}, err
    }
    return Config{cfg: cfg}, nil
}

// DatabaseURL returns the configured database connection string.
func (c Config) DatabaseURL() string {
    return c.cfg.Database.URL
}

// ServerAddr returns the configured host:port for the HTTP server.
func (c Config) ServerAddr() string {
    return fmt.Sprintf("%s:%d", c.cfg.Server.Host, c.cfg.Server.Port)
}
```

**forge/forge.go** — App builder pattern:

```go
package forge

import (
    "context"
    "fmt"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "syscall"

    "github.com/alexedwards/scs/pgxstore"
    "github.com/danielgtaylor/huma/v2"
    "github.com/go-chi/chi/v5"
    "github.com/jackc/pgx/v5/pgxpool"

    "github.com/alternayte/forge/forge/auth"
    internalapi "github.com/alternayte/forge/internal/api"
    "github.com/alternayte/forge/internal/config"
)

// App is the forge application lifecycle manager.
// Create with New(), configure with builder methods, start with Listen().
type App struct {
    cfg            *config.Config
    router         chi.Router
    pool           *pgxpool.Pool
    apiRoutesFn    func(huma.API)
    htmlRoutesFn   func(chi.Router)
    recoveryMw     func(http.Handler) http.Handler
    tokenStore     auth.TokenStore
    apiKeyStore    auth.APIKeyStore
}

// New creates a new App from configuration loaded via LoadConfig.
func New(cfg Config) *App {
    return &App{
        cfg:    cfg.cfg,
        router: chi.NewRouter(),
    }
}

// RegisterAPIRoutes sets the function that registers all API routes on the Huma API.
// The function receives a huma.API and should call genapi.RegisterAllRoutes(api, registry).
func (a *App) RegisterAPIRoutes(fn func(huma.API)) *App {
    a.apiRoutesFn = fn
    return a
}

// RegisterHTMLRoutes sets the function that registers all HTML routes on a chi.Router.
// The function receives a session-protected chi.Router group.
func (a *App) RegisterHTMLRoutes(fn func(chi.Router)) *App {
    a.htmlRoutesFn = fn
    return a
}

// UseRecovery sets a custom panic recovery middleware. If not called,
// a default recovery middleware is used.
func (a *App) UseRecovery(mw func(http.Handler) http.Handler) *App {
    a.recoveryMw = mw
    return a
}

// UseTokenStore sets the bearer token store for API authentication.
func (a *App) UseTokenStore(ts auth.TokenStore) *App {
    a.tokenStore = ts
    return a
}

// UseAPIKeyStore sets the API key store for API authentication.
func (a *App) UseAPIKeyStore(ks auth.APIKeyStore) *App {
    a.apiKeyStore = ks
    return a
}

// Listen starts the HTTP server and blocks until SIGTERM/SIGINT.
// On shutdown: stops accepting connections, drains in-flight requests,
// closes the DB pool.
func (a *App) Listen(addr string) error {
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    // Connect to database
    pool, err := pgxpool.New(ctx, a.cfg.Database.URL)
    if err != nil {
        return fmt.Errorf("forge: connect to database: %w", err)
    }
    defer pool.Close()
    a.pool = pool

    // Set up session manager
    sm := auth.NewSessionManager(pool, a.cfg.Server.Host == "localhost")
    store := pgxstore.New(pool)
    sm.Store = store

    // Recovery middleware fallback
    recoveryMw := a.recoveryMw
    if recoveryMw == nil {
        recoveryMw = func(next http.Handler) http.Handler { return next }
    }

    // Wire API routes
    if a.apiRoutesFn != nil {
        _, err := internalapi.SetupAPI(
            a.router,
            a.cfg.API,
            a.tokenStore,
            a.apiKeyStore,
            recoveryMw,
            a.apiRoutesFn,
        )
        if err != nil {
            return fmt.Errorf("forge: setup API: %w", err)
        }
    }

    // Wire HTML routes
    if a.htmlRoutesFn != nil {
        err := internalapi.SetupHTML(a.router, internalapi.HTMLServerConfig{
            SessionManager: sm,
            RegisterRoutes: a.htmlRoutesFn,
        })
        if err != nil {
            return fmt.Errorf("forge: setup HTML: %w", err)
        }
    }

    // Start HTTP server
    srv := &http.Server{
        Addr:    addr,
        Handler: a.router,
    }

    // Graceful shutdown goroutine
    go func() {
        <-ctx.Done()
        slog.Info("forge: shutting down...")
        shutdownCtx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()
        srv.Shutdown(shutdownCtx)
    }()

    slog.Info("forge: listening", "addr", addr)
    if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
        return fmt.Errorf("forge: server error: %w", err)
    }

    return nil
}

// Pool returns the database connection pool.
// Only valid after Listen() has been called (for test infrastructure, use forge/forgetest).
func (a *App) Pool() *pgxpool.Pool {
    return a.pool
}
```

IMPORTANT: The exact API above is a starting point. Adjust based on what internal/api.SetupAPI and internal/config actually expose. Key design rules:
- The `forge` package CAN import `internal/api` and `internal/config` (they're in the same module)
- The `forge` package MUST NOT expose internal types in its public API
- Use callback functions (func(huma.API), func(chi.Router)) for route registration — do not import generated types
- Check `internal/config` for the `APIConfig` type — the `config.Config` struct may have an `API` field; if not, construct the APIConfig from available fields

Note on config.APIConfig: Check what `internal/config/api.go` contains. If there's an `APIConfig` struct separate from `Config`, wire it correctly. If `cfg.API` doesn't exist on `config.Config`, look at how internal/api/server.go constructs its dependencies and bridge accordingly.
  </action>
  <verify>
    - `go build ./forge/...` compiles
    - `grep "func New" forge/forge.go` finds the constructor
    - `grep "func LoadConfig" forge/config.go` finds the loader
    - `grep "func.*Listen" forge/forge.go` finds the listener
  </verify>
  <done>forge.App builder exists with New(), RegisterAPIRoutes(), RegisterHTMLRoutes(), and Listen(). forge.LoadConfig() loads forge.toml.</done>
</task>

<task type="auto">
  <name>Task 2: Create forge.Error and forge.Transaction types</name>
  <files>
    forge/errors.go
    forge/transaction.go
  </files>
  <action>
Create the public error and transaction types. These are currently generated into gen/ directories per-project. The public `forge` package provides the canonical type definitions that generated code can reference.

**forge/errors.go** — Error type matching the generated errors pattern:

```go
package forge

import "fmt"

// Error represents a structured application error with HTTP status code mapping.
// Both API (JSON) and HTML (SSE) handlers use this type for consistent error responses.
type Error struct {
    // Status is the HTTP status code (e.g. 400, 404, 500).
    Status int

    // Code is a machine-readable error code (e.g. "not_found", "validation_error").
    Code string

    // Message is a human-readable error summary.
    Message string

    // Detail provides additional context for debugging (may be empty).
    Detail string

    // Err is the underlying error, if any.
    Err error
}

// Error implements the error interface.
func (e *Error) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %s: %v", e.Code, e.Message, e.Err)
    }
    return fmt.Sprintf("%s: %s", e.Code, e.Message)
}

// Unwrap returns the underlying error for errors.Is/As support.
func (e *Error) Unwrap() error {
    return e.Err
}

// RenderError writes a forge.Error as an appropriate HTTP response.
// For API requests (Accept: application/json), writes RFC 9457 JSON.
// For HTML requests, writes an SSE fragment with a toast notification.
type RenderError func(w http.ResponseWriter, r *http.Request, err *Error)

// TenantFromContext extracts the tenant ID from the request context.
// Returns the tenant UUID and a boolean indicating whether a tenant was found.
func TenantFromContext(ctx context.Context) (uuid.UUID, bool) {
    // Delegate to forge/auth package
    return auth.TenantFromContext(ctx)
}
```

NOTE: The actual forge.Error type should match what the existing generated `gen/errors/errors.go` template produces. Read `internal/generator/templates/errors.go.tmpl` to see the exact struct definition and replicate it here. If the generated type has different fields, match those fields exactly so generated code can use `forge.Error` directly.

**forge/transaction.go** — Transaction wrapper:

```go
package forge

import (
    "context"

    "github.com/jackc/pgx/v5"
    "github.com/jackc/pgx/v5/pgxpool"
)

// Transaction wraps a database transaction with convenience methods.
type Transaction struct {
    tx   pgx.Tx
    pool *pgxpool.Pool
}

// RunInTransaction executes fn within a database transaction.
// If fn returns an error, the transaction is rolled back.
// If fn succeeds, the transaction is committed.
func RunInTransaction(ctx context.Context, pool *pgxpool.Pool, fn func(tx pgx.Tx) error) error {
    tx, err := pool.Begin(ctx)
    if err != nil {
        return err
    }
    defer tx.Rollback(ctx)

    if err := fn(tx); err != nil {
        return err
    }

    return tx.Commit(ctx)
}
```

NOTE: Check `internal/generator/templates/transaction.go.tmpl` for the exact API shape. Replicate the same patterns so generated code can reference `forge.Transaction` or `forge.RunInTransaction`.

IMPORTANT: Only include imports that are actually used. If uuid or auth or http are needed, import them; if not, omit. Compile with `go build ./forge/...` to verify.
  </action>
  <verify>
    - `go build ./forge/...` compiles
    - `grep "type Error struct" forge/errors.go` finds the type
    - `grep "RunInTransaction\|type Transaction" forge/transaction.go` finds the transaction API
    - `go vet ./forge/...` passes
  </verify>
  <done>forge.Error and forge.Transaction are defined as public types. The forge package compiles cleanly.</done>
</task>

</tasks>

<verification>
1. `go build ./forge/...` passes
2. `go vet ./forge/...` passes
3. `grep "func New" forge/forge.go` — constructor exists
4. `grep "func.*Listen" forge/forge.go` — server startup exists
5. `grep "type Error struct" forge/errors.go` — error type exists
6. `grep "type Config struct\|func LoadConfig" forge/config.go` — config exists
</verification>

<success_criteria>
- forge.New(cfg) creates an App
- forge.App has RegisterAPIRoutes, RegisterHTMLRoutes, UseRecovery, and Listen methods
- forge.LoadConfig loads forge.toml
- forge.Error struct matches the pattern used by generated code
- forge.RunInTransaction or Transaction type exists
- All code compiles
</success_criteria>

<output>
After completion, create `.planning/phases/09-public-api-surface-end-to-end-flow/09-03-SUMMARY.md`
</output>
