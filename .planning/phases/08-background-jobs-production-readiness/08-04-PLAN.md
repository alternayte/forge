---
phase: 08-background-jobs-production-readiness
plan: 04
type: execute
wave: 2
depends_on: ["08-01", "08-02"]
files_modified:
  - internal/jobs/client.go
  - internal/generator/templates/actions.go.tmpl
  - internal/generator/templates/scaffold_jobs.go.tmpl
  - internal/generator/scaffold.go
  - internal/generator/funcmap.go
autonomous: true
requirements:
  - JOBS-01
  - JOBS-02
  - JOBS-03
  - JOBS-04

must_haves:
  truths:
    - "NewRiverClient creates a *river.Client[pgx.Tx] with queues from forge.toml config and otelriver middleware"
    - "actions.go.tmpl wraps Create in pgx.BeginFunc transaction and calls river.InsertTx for each AfterCreate hook when Hooks present"
    - "actions.go.tmpl wraps Update in pgx.BeginFunc transaction and calls river.InsertTx for each AfterUpdate hook when Hooks present"
    - "InsertTx args include TenantID from forgeauth.TenantFromContext(ctx) for tenant-scoped job processing"
    - "scaffold_jobs.go.tmpl generates per-hook worker struct with Kind() method and Work() stub for resources with Hooks"
    - "ScaffoldResource includes jobs.go in scaffold-once file list when resource has Hooks"
  artifacts:
    - path: "internal/jobs/client.go"
      provides: "River client setup, RunRiverMigrations, and riverErrorHandler"
      contains: "func NewRiverClient"
    - path: "internal/generator/templates/actions.go.tmpl"
      provides: "Transactional InsertTx calls for AfterCreate and AfterUpdate hooks"
      contains: "InsertTx"
    - path: "internal/generator/templates/scaffold_jobs.go.tmpl"
      provides: "Scaffold-once job worker template with Args and Worker types per hook"
      contains: "func.*Kind.*string"
    - path: "internal/generator/scaffold.go"
      provides: "Updated scaffoldFiles including jobs.go for Hooks resources"
      contains: "scaffold_jobs"
  key_links:
    - from: "internal/generator/templates/actions.go.tmpl"
      to: "internal/jobs/client.go"
      via: "Generated actions import river and call a.River.InsertTx"
      pattern: "InsertTx"
    - from: "internal/generator/templates/scaffold_jobs.go.tmpl"
      to: "internal/generator/templates/actions.go.tmpl"
      via: "Scaffolded Args types match the Kind strings referenced in generated InsertTx calls"
      pattern: "Kind.*string"
---

<objective>
Integrate River background job client, generate transactional job enqueueing in the actions template, and scaffold job worker files for resources with Hooks.

Purpose: Delivers the core River integration — schema-defined hooks automatically enqueue jobs in the same DB transaction as the record mutation, with tenant-scoped args and configurable queues.
Output: internal/jobs/ package with River client, updated actions.go.tmpl with InsertTx, scaffold_jobs.go.tmpl for worker stubs.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-background-jobs-production-readiness/08-RESEARCH.md
@.planning/phases/08-background-jobs-production-readiness/08-01-SUMMARY.md

# Key files
@internal/generator/templates/actions.go.tmpl
@internal/generator/scaffold.go
@internal/generator/funcmap.go
@internal/config/config.go
@internal/parser/ir.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create River client package and job worker scaffold template</name>
  <files>
    internal/jobs/client.go
    internal/generator/templates/scaffold_jobs.go.tmpl
  </files>
  <action>
1. Create `internal/jobs/client.go` with package `jobs`:

   - `func NewRiverClient(pool *pgxpool.Pool, cfg config.JobsConfig, workers *river.Workers) (*river.Client[pgx.Tx], error)`:
     a. Build queue config map from `cfg.Queues` (map[string]int -> map[string]river.QueueConfig)
     b. Ensure `river.QueueDefault` exists with MaxWorkers=100 if not specified in config
     c. Create client: `river.NewClient(riverpgxv5.New(pool), &river.Config{Queues: queues, Workers: workers, ErrorHandler: &riverErrorHandler{}, Middleware: []rivertype.Middleware{otelriver.NewMiddleware(nil)}})`
     d. Return client

   - `type riverErrorHandler struct{}` implementing `river.ErrorHandler` interface:
     a. `HandleError(ctx, job, err)` — log with slog.WarnContext
     b. `HandlePanic(ctx, job, panicVal, trace)` — log with slog.ErrorContext

   - `func RunRiverMigrations(ctx context.Context, pool *pgxpool.Pool) error`:
     a. Create migrator: `rivermigrate.New(riverpgxv5.New(pool), nil)`
     b. Run: `migrator.Migrate(ctx, rivermigrate.DirectionUp, nil)`
     c. Return error

   Run `go get`:
   ```
   go get github.com/riverqueue/river
   go get github.com/riverqueue/river/riverpgxv5
   go get github.com/riverqueue/river/rivermigrate
   go get github.com/riverqueue/rivercontrib/otelriver
   ```

2. Create `internal/generator/templates/scaffold_jobs.go.tmpl`:
   - Package: `{{snake .Resource.Name}}`
   - This is a scaffold-once template (like scaffold_handlers.go.tmpl)
   - For each hook in `.Resource.Options.Hooks.AfterCreate` and `.Resource.Options.Hooks.AfterUpdate`, generate:
     a. Args struct: `type {{pascal .Kind}}Args struct { ResourceID uuid.UUID \`json:"resource_id"\`; TenantID uuid.UUID \`json:"tenant_id"\` }`
     b. Kind method: `func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }`
     c. Worker struct: `type {{pascal .Kind}}Worker struct { river.WorkerDefaults[{{pascal .Kind}}Args] }` with TODO comment for adding dependencies
     d. Work method: `func (w *{{pascal .Kind}}Worker) Work(ctx context.Context, job *river.Job[{{pascal .Kind}}Args]) error` with:
        - `ctx = forgeauth.WithTenant(ctx, job.Args.TenantID)` for tenant context restoration (JOBS-03)
        - TODO placeholder for job logic
        - `return nil`
   - Imports: context, github.com/google/uuid, github.com/riverqueue/river, project auth package
   - Use `pascal` funcmap helper (already exists) for converting Kind strings like "notify_new_product" to "NotifyNewProduct"
   - **Note:** If `pascal` does not handle snake_case->PascalCase correctly, use a combination approach. Check funcmap.go for the existing pascal helper behavior. The template may need `{{.Kind | snakeToPascal}}` or a new helper if needed.
  </action>
  <verify>
Run `go build ./internal/jobs/...` — compiles.

Run `go build ./internal/generator/...` — compiles (template is embedded, not compiled).
  </verify>
  <done>
River client wires queues from config with otelriver middleware. RunRiverMigrations handles River's own schema setup. riverErrorHandler logs exhausted/panicked jobs via slog. scaffold_jobs.go.tmpl generates per-hook Args struct with Kind() and Worker with Work() stub.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update actions template for transactional InsertTx and scaffold integration</name>
  <files>
    internal/generator/templates/actions.go.tmpl
    internal/generator/scaffold.go
    internal/generator/funcmap.go
  </files>
  <action>
1. In `internal/generator/funcmap.go`:
   - Verify `hasHooks` helper exists (should be added in Plan 01 Task 2). If not, add it:
     `"hasHooks": func(opts parser.ResourceOptionsIR) bool { return len(opts.Hooks.AfterCreate) > 0 || len(opts.Hooks.AfterUpdate) > 0 }`
   - Add `pascal` helper for snake_case to PascalCase if it doesn't handle underscored strings (e.g., "notify_new_product" -> "NotifyNewProduct"). Check existing behavior first. May need a `snakeToPascal` variant.

2. In `internal/generator/templates/actions.go.tmpl`:
   - Add conditional import for river when hasHooks:
     ```
     {{- if hasHooks .Options}}
     "github.com/jackc/pgx/v5"
     "github.com/riverqueue/river"
     {{- end}}
     ```
   - Add `River *river.Client[pgx.Tx]` field to `Default{{.Name}}Actions` struct when hasHooks:
     ```
     {{- if hasHooks .Options}}
     River *river.Client[pgx.Tx]
     {{- end}}
     ```
   - Modify the `Create` method body when `hasHooks .Options` AND `len(.Options.Hooks.AfterCreate) > 0`:
     After the validation block, instead of the current TODO placeholder, generate a transactional block:
     ```
     {{- if .Options.Hooks.AfterCreate}}
     // Transactional create with AfterCreate job hooks (JOBS-02)
     var result *models.{{.Name}}
     err := pgx.BeginFunc(ctx, a.DB, func(tx pgx.Tx) error {
         // TODO: Execute Bob insert via tx (replace when Bob is wired)
         _ = tx
         return errors.InternalError("Create not yet implemented")

         {{range .Options.Hooks.AfterCreate}}
         // Enqueue {{.Kind}} job in same transaction
         _, enqErr := a.River.InsertTx(ctx, tx, {{pascal .Kind}}Args{
             ResourceID: result.ID,
             TenantID:   forgeauth.TenantFromContext(ctx),
         }, &river.InsertOpts{ {{- if .Queue}}Queue: "{{.Queue}}",{{end}} })
         if enqErr != nil {
             return enqErr
         }
         {{end}}
         return nil
     })
     return result, err
     {{- else}}
     // (existing non-hook Create code)
     {{- end}}
     ```
     **Important:** The InsertTx calls are structurally present but unreachable until Bob queries replace the TODO. This matches the existing pattern where Create returns an error placeholder. The job hook code shows the CORRECT pattern for when Bob is wired.

   - Apply the same pattern to `Update` for `.Options.Hooks.AfterUpdate`: wrap the existing update logic in a pgx.BeginFunc, add InsertTx calls after the Bob update.

   - For the Args type references in the template (e.g., `{{pascal .Kind}}Args`), these must match the types scaffolded in `scaffold_jobs.go.tmpl`. The import for the resource package (where jobs.go lives) would be in the user's code, not in gen/actions — the generated actions package imports the scaffolded resource package. Add a note in the generated code: `// Import the job args types from resources/{{snake .Name}}/jobs.go`.

   **Alternative approach (simpler):** Since the generated actions package cannot import user-scaffolded resource packages (import cycle), define a simpler pattern: the generated InsertTx calls use a generic `map[string]any` as the River args type, OR define the Args structs inline in the generated actions file alongside the action methods. Per research, the Args types need `Kind() string` method. The inline approach is cleaner — generate the Args types at the top of the generated actions file for each hook, guarded by `{{if hasHooks .Options}}`.

   Choose the inline approach: generate minimal Args structs (just ResourceID + TenantID + Kind() method) directly in the actions.go output, right after the DB interface. This avoids import cycles and keeps generated code self-contained.

3. In `internal/generator/scaffold.go`:
   - Update `scaffoldFiles()` to conditionally include `scaffold_jobs.go.tmpl` when the resource has hooks. Since `scaffoldFiles()` currently returns a static list, you have two options:
     a. Make `scaffoldFiles` accept a `parser.ResourceIR` parameter and conditionally append the jobs entry
     b. Add a separate function `scaffoldJobsFile()` that returns the jobs scaffold entry
   - Option (a) is cleaner. Update the function signature to `scaffoldFiles(resource parser.ResourceIR) []scaffoldFile` and conditionally append `{Template: "templates/scaffold_jobs.go.tmpl", OutputPath: "jobs.go", IsTempl: false}` when `len(resource.Options.Hooks.AfterCreate) > 0 || len(resource.Options.Hooks.AfterUpdate) > 0`.
   - Update all callers of `scaffoldFiles()` in ScaffoldResource, renderScaffoldToMap, and DiffResource to pass the resource parameter.
  </action>
  <verify>
Run `go build ./internal/generator/...` — compiles.

Run `go test ./internal/generator/... -count=1` — all existing tests pass (no regressions from template changes).

Run `go vet ./internal/generator/...` — no issues.
  </verify>
  <done>
actions.go.tmpl generates River InsertTx calls inside pgx.BeginFunc transactions for resources with Hooks. AfterCreate hooks enqueue in Create method transaction; AfterUpdate hooks enqueue in Update method transaction. InsertTx args include TenantID from context (JOBS-03). scaffold_jobs.go.tmpl scaffolds worker stubs with Kind() and Work(). scaffoldFiles() conditionally includes jobs.go for Hooks resources.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/jobs/...` — compiles
2. `go build ./internal/generator/...` — compiles
3. `go test ./internal/generator/... -count=1` — all tests pass
4. `go vet ./...` — no issues
5. Template content: actions.go.tmpl contains InsertTx, pgx.BeginFunc, river.InsertOpts references
6. scaffold_jobs.go.tmpl contains worker Kind() method and Work() stub
</verification>

<success_criteria>
- River client created with configurable queues and otelriver middleware (JOBS-01, JOBS-04)
- Generated actions use transactional InsertTx inside pgx.BeginFunc for hook jobs (JOBS-02)
- Job args include TenantID from context (JOBS-03)
- Worker scaffold generates per-hook Args/Worker types (scaffold-once pattern)
- scaffoldFiles conditionally includes jobs.go for Hooks resources
- No regressions in existing generator tests
</success_criteria>

<output>
After completion, create `.planning/phases/08-background-jobs-production-readiness/08-04-SUMMARY.md`
</output>
