// Code generated by forge generate. DO NOT EDIT.

package actions

import (
	"context"
{{- if .Options.Auditable}}
	"encoding/json"
	"reflect"
{{- end}}
	"fmt"
	"strings"
{{- if .HasTimestamps}}
	"time"
{{- end}}

{{- if or (hasAnyPermission .Options) (hasAnyVisibility .Fields) (.Options.Auditable) (hasHooks .Options) (.Options.TenantScoped)}}
	forgeauth "github.com/alternayte/forge/forge/auth"
{{- end}}
	"github.com/google/uuid"
	"github.com/jackc/pgx/v5"
{{- if hasHooks .Options}}
	"github.com/riverqueue/river"
{{- end}}
	"github.com/stephenafamo/bob"
	"github.com/stephenafamo/bob/dialect/psql"
	"github.com/stephenafamo/bob/dialect/psql/dialect"
	"github.com/stephenafamo/bob/dialect/psql/sm"

	"{{.ProjectModule}}/gen/errors"
	"{{.ProjectModule}}/gen/models"
	"{{.ProjectModule}}/gen/queries"
	"{{.ProjectModule}}/gen/validation"
)
{{- if hasHooks .Options}}

// Job args types (generated inline to avoid import cycles with resources/)
{{- range .Options.Hooks.AfterCreate}}
type {{pascal .Kind}}Args struct {
	ResourceID uuid.UUID `json:"resource_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
}

func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }
{{- end}}
{{- range .Options.Hooks.AfterUpdate}}
type {{pascal .Kind}}Args struct {
	ResourceID uuid.UUID `json:"resource_id"`
	TenantID   uuid.UUID `json:"tenant_id"`
}

func ({{pascal .Kind}}Args) Kind() string { return "{{.Kind}}" }
{{- end}}
{{- end}}

// {{.Name}}Actions defines the business logic interface for {{.Name}} operations.
// Both HTML and API handlers call this interface to prevent logic duplication.
type {{.Name}}Actions interface {
	// List retrieves {{plural .Name | lower}} with filtering, sorting, and pagination.
	List(ctx context.Context, filter models.{{.Name}}Filter, sort models.{{.Name}}Sort, page int, pageSize int) ([]models.{{.Name}}, int64, error)

	// Get retrieves a single {{.Name}} by ID.
	Get(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error)

	// Create creates a new {{.Name}} after validation.
	Create(ctx context.Context, input models.{{.Name}}Create) (*models.{{.Name}}, error)

	// Update updates an existing {{.Name}} after validation.
	Update(ctx context.Context, id uuid.UUID, input models.{{.Name}}Update) (*models.{{.Name}}, error)

	// Delete removes a {{.Name}} by ID.
	Delete(ctx context.Context, id uuid.UUID) error
{{- if .Options.SoftDelete}}

	// Restore restores a soft-deleted {{.Name}} by clearing its deleted_at timestamp.
	Restore(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error)
{{- end}}
{{- if hasAnyVisibility .Fields}}

	// RoleFilterList strips invisible fields from a list of items based on user role.
	RoleFilterList(role string, items []models.{{.Name}}) []map[string]any
{{- end}}
}

// Default{{.Name}}Actions is the default implementation of {{.Name}}Actions.
// Developers can embed this struct and override specific methods for custom behavior.
type Default{{.Name}}Actions struct {
	DB DB
{{- if hasHooks .Options}}
	River *river.Client[pgx.Tx]
{{- end}}
}

// List retrieves {{plural .Name | lower}} with filtering, sorting, and pagination.
func (a *Default{{.Name}}Actions) List(ctx context.Context, filter models.{{.Name}}Filter, sort models.{{.Name}}Sort, page int, pageSize int) ([]models.{{.Name}}, int64, error) {
{{- if hasPermission .Options "list"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "list"}}); err != nil {
		return nil, 0, err
	}
{{- end}}
	// Build query mods from filter
	filterMods := queries.{{.Name}}FilterMods(filter)
{{- if .Options.SoftDelete}}
	// Exclude soft-deleted records by default (DATA-06)
	filterMods = append(filterMods, queries.{{.Name}}Filters{}.ActiveMod())
{{- end}}
{{- if .Options.TenantScoped}}
	filterMods = append(filterMods, queries.{{.Name}}Filters{}.TenantMod(ctx))
{{- end}}

	// Build sort mod
	sortMod := queries.{{.Name}}SortMod(sort)

	// Count query — same filters, no sort/pagination
	countMods := []bob.Mod[*dialect.SelectQuery]{
		sm.Columns(psql.Raw("COUNT(*)")),
		sm.From(psql.Quote("{{plural (snake .Name)}}")),
	}
	countMods = append(countMods, filterMods...)
	countQuery := psql.Select(countMods...)
	countSQL, countArgs, err := countQuery.Build(ctx)
	if err != nil {
		return nil, 0, errors.InternalError(err)
	}

	var total int64
	if err := a.DB.QueryRow(ctx, countSQL, countArgs...).Scan(&total); err != nil {
		return nil, 0, errors.MapDBError(err)
	}

	if total == 0 {
		return []models.{{.Name}}{}, 0, nil
	}

	// Data query with sort and pagination
	dataMods := []bob.Mod[*dialect.SelectQuery]{
		sm.From(psql.Quote("{{plural (snake .Name)}}")),
	}
	dataMods = append(dataMods, filterMods...)
	dataMods = append(dataMods, sortMod)
	dataMods = append(dataMods, queries.OffsetPaginationMods(page, pageSize)...)

	dataQuery := psql.Select(dataMods...)
	dataSQL, dataArgs, err := dataQuery.Build(ctx)
	if err != nil {
		return nil, 0, errors.InternalError(err)
	}

	rows, err := a.DB.Query(ctx, dataSQL, dataArgs...)
	if err != nil {
		return nil, 0, errors.MapDBError(err)
	}
	items, err := pgx.CollectRows(rows, pgx.RowToStructByName[models.{{.Name}}])
	if err != nil {
		return nil, 0, errors.MapDBError(err)
	}

	return items, total, nil
}

// Get retrieves a single {{.Name}} by ID.
func (a *Default{{.Name}}Actions) Get(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "read"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "read"}}); err != nil {
		return nil, err
	}
{{- end}}
{{- if .Options.TenantScoped}}
	tenantID, _ := forgeauth.TenantFromContext(ctx)
	rows, err := a.DB.Query(ctx,
		`SELECT * FROM {{plural (snake .Name)}} WHERE id = $1{{if .Options.SoftDelete}} AND deleted_at IS NULL{{end}} AND tenant_id = $2`,
		id, tenantID,
	)
{{- else}}
	rows, err := a.DB.Query(ctx,
		`SELECT * FROM {{plural (snake .Name)}} WHERE id = $1{{if .Options.SoftDelete}} AND deleted_at IS NULL{{end}}`,
		id,
	)
{{- end}}
	if err != nil {
		return nil, errors.MapDBError(err)
	}
	item, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[models.{{.Name}}])
	if err != nil {
		if errors.IsNotFound(err) {
			return nil, errors.NotFound("{{.Name}}", id.String())
		}
		return nil, errors.MapDBError(err)
	}
	return &item, nil
}

// Create creates a new {{.Name}} after validation.
func (a *Default{{.Name}}Actions) Create(ctx context.Context, input models.{{.Name}}Create) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "create"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "create"}}); err != nil {
		return nil, err
	}
{{- end}}
	// Validate input using generated validation
	valErrs := validation.Validate{{.Name}}Create(input)
	if valErrs.HasErrors() {
		return nil, errors.NewValidationError(valErrs)
	}

	// Build INSERT columns and args
	newID := uuid.New()
	cols := []string{"id"}
	args := []any{newID}
{{- if .Options.TenantScoped}}
	tenantID, _ := forgeauth.TenantFromContext(ctx)
	cols = append(cols, "tenant_id")
	args = append(args, tenantID)
{{- end}}
{{- range .Fields}}
{{- if not (isIDField .)}}
	cols = append(cols, "{{snake .Name}}")
	args = append(args, input.{{.Name}})
{{- end}}
{{- end}}
{{- if .HasTimestamps}}
	now := time.Now()
	cols = append(cols, "created_at", "updated_at")
	args = append(args, now, now)
{{- end}}
{{- if .Options.Auditable}}
	userID := forgeauth.UserFromContext(ctx)
	var userIDPtr *uuid.UUID
	if userID != (uuid.UUID{}) {
		userIDPtr = &userID
	}
	cols = append(cols, "created_by", "updated_by")
	args = append(args, userIDPtr, userIDPtr)
{{- end}}

	placeholders := make([]string, len(args))
	for i := range placeholders {
		placeholders[i] = fmt.Sprintf("$%d", i+1)
	}
	insertSQL := fmt.Sprintf(
		`INSERT INTO {{plural (snake .Name)}} (%s) VALUES (%s) RETURNING *`,
		strings.Join(cols, ", "),
		strings.Join(placeholders, ", "),
	)

{{- if .Options.Hooks.AfterCreate}}
	// Transactional create with AfterCreate job hooks (JOBS-02)
	var result *models.{{.Name}}
	err := pgx.BeginFunc(ctx, a.DB, func(tx pgx.Tx) error {
		txRows, qErr := tx.Query(ctx, insertSQL, args...)
		if qErr != nil {
			return errors.MapDBError(qErr)
		}
		item, qErr := pgx.CollectOneRow(txRows, pgx.RowToStructByName[models.{{.Name}}])
		if qErr != nil {
			return errors.MapDBError(qErr)
		}
		result = &item
		{{- range .Options.Hooks.AfterCreate}}
		// Enqueue {{.Kind}} job in same transaction (JOBS-02)
		hookTenantID, _ := forgeauth.TenantFromContext(ctx)
		if _, enqErr := a.River.InsertTx(ctx, tx, {{pascal .Kind}}Args{
			ResourceID: result.ID,
			TenantID:   hookTenantID,
		}, &river.InsertOpts{ {{- if .Queue}}Queue: "{{.Queue}}",{{end}} }); enqErr != nil {
			return enqErr
		}
		{{- end}}
		return nil
	})
	return result, err
{{- else}}
	rows, err := a.DB.Query(ctx, insertSQL, args...)
	if err != nil {
		return nil, errors.MapDBError(err)
	}
	item, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[models.{{.Name}}])
	if err != nil {
		return nil, errors.MapDBError(err)
	}
	return &item, nil
{{- end}}
}

// Update updates an existing {{.Name}} after validation.
func (a *Default{{.Name}}Actions) Update(ctx context.Context, id uuid.UUID, input models.{{.Name}}Update) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "update"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "update"}}); err != nil {
		return nil, err
	}
{{- end}}
	// Validate input using generated validation
	valErrs := validation.Validate{{.Name}}Update(input)
	if valErrs.HasErrors() {
		return nil, errors.NewValidationError(valErrs)
	}

{{- if .Options.Auditable}}
	// Fetch before-state for audit diff (must happen before UPDATE) (AUDIT-02)
	beforeItem, _ := a.Get(ctx, id)
{{- end}}

	// Build dynamic SET clause from non-nil fields
	setClauses := []string{}
	updateArgs := []any{}
	argN := 1
{{- range .Fields}}
{{- if not (isIDField .)}}
	if input.{{.Name}} != nil {
		setClauses = append(setClauses, fmt.Sprintf("{{snake .Name}} = $%d", argN))
		updateArgs = append(updateArgs, *input.{{.Name}})
		argN++
	}
{{- end}}
{{- end}}
{{- if .HasTimestamps}}
	setClauses = append(setClauses, fmt.Sprintf("updated_at = $%d", argN))
	updateArgs = append(updateArgs, time.Now())
	argN++
{{- end}}
{{- if .Options.Auditable}}
	auditUserID := forgeauth.UserFromContext(ctx)
	if auditUserID != (uuid.UUID{}) {
		setClauses = append(setClauses, fmt.Sprintf("updated_by = $%d", argN))
		updateArgs = append(updateArgs, auditUserID)
		argN++
	}
{{- end}}

	// No fields to update — return current state
	if len(setClauses) == 0 {
		return a.Get(ctx, id)
	}

	// Build WHERE clause
	updateArgs = append(updateArgs, id)
	whereClause := fmt.Sprintf("id = $%d", argN)
	argN++
{{- if .Options.SoftDelete}}
	whereClause += " AND deleted_at IS NULL"
{{- end}}
{{- if .Options.TenantScoped}}
	updateTenantID, _ := forgeauth.TenantFromContext(ctx)
	updateArgs = append(updateArgs, updateTenantID)
	whereClause += fmt.Sprintf(" AND tenant_id = $%d", argN)
	argN++
{{- end}}

	updateSQL := fmt.Sprintf(
		`UPDATE {{plural (snake .Name)}} SET %s WHERE %s RETURNING *`,
		strings.Join(setClauses, ", "),
		whereClause,
	)

{{- if .Options.Hooks.AfterUpdate}}
	// Transactional update with AfterUpdate job hooks (JOBS-02)
	var item *models.{{.Name}}
	err := pgx.BeginFunc(ctx, a.DB, func(tx pgx.Tx) error {
		txRows, qErr := tx.Query(ctx, updateSQL, updateArgs...)
		if qErr != nil {
			return errors.MapDBError(qErr)
		}
		updated, qErr := pgx.CollectOneRow(txRows, pgx.RowToStructByName[models.{{.Name}}])
		if qErr != nil {
			if errors.IsNotFound(qErr) {
				return errors.NotFound("{{.Name}}", id.String())
			}
			return errors.MapDBError(qErr)
		}
		item = &updated
		{{- range .Options.Hooks.AfterUpdate}}
		// Enqueue {{.Kind}} job in same transaction (JOBS-02)
		hookTenantID, _ := forgeauth.TenantFromContext(ctx)
		if _, enqErr := a.River.InsertTx(ctx, tx, {{pascal .Kind}}Args{
			ResourceID: item.ID,
			TenantID:   hookTenantID,
		}, &river.InsertOpts{ {{- if .Queue}}Queue: "{{.Queue}}",{{end}} }); enqErr != nil {
			return enqErr
		}
		{{- end}}
		return nil
	})
{{- if .Options.Auditable}}
	// Record update in audit log with JSONB diff (AUDIT-02)
	// No-op updates produce empty diff — no audit entry (AUDIT-03)
	if beforeItem != nil && item != nil {
		if auditErr := a.recordAudit(ctx, "update", id, beforeItem, item); auditErr != nil {
			_ = auditErr // Log but don't fail the update
		}
	}
{{- end}}
	return item, err
{{- else}}
	rows, err := a.DB.Query(ctx, updateSQL, updateArgs...)
	if err != nil {
		return nil, errors.MapDBError(err)
	}
	item, err := pgx.CollectOneRow(rows, pgx.RowToStructByName[models.{{.Name}}])
	if err != nil {
		if errors.IsNotFound(err) {
			return nil, errors.NotFound("{{.Name}}", id.String())
		}
		return nil, errors.MapDBError(err)
	}
{{- if .Options.Auditable}}
	// Record update in audit log with JSONB diff (AUDIT-02)
	// No-op updates produce empty diff — no audit entry (AUDIT-03)
	if beforeItem != nil {
		if auditErr := a.recordAudit(ctx, "update", id, beforeItem, &item); auditErr != nil {
			_ = auditErr // Log but don't fail the update
		}
	}
{{- end}}
	return &item, nil
{{- end}}
}

// Delete removes a {{.Name}} by ID.
func (a *Default{{.Name}}Actions) Delete(ctx context.Context, id uuid.UUID) error {
{{- if hasPermission .Options "delete"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "delete"}}); err != nil {
		return err
	}
{{- end}}
{{- if .Options.SoftDelete}}
	// Soft delete: set deleted_at timestamp instead of removing the record.
	// Per design: no hard delete — soft delete is final state. Developer uses raw SQL if needed.
	_, err := a.DB.Exec(ctx,
		`UPDATE {{plural (snake .Name)}} SET deleted_at = NOW() WHERE id = $1 AND deleted_at IS NULL`,
		id,
	)
	if err != nil {
		return errors.InternalError(fmt.Errorf("failed to soft-delete {{.Name}}"))
	}
{{- if .Options.Auditable}}
	// Record soft-delete in audit log (AUDIT-02)
	a.recordAudit(ctx, "delete", id, nil, map[string]any{"deleted_at": "now"}) //nolint:errcheck
{{- end}}
	return nil
{{- else}}
	// Hard delete
{{- if .Options.TenantScoped}}
	delTenantID, _ := forgeauth.TenantFromContext(ctx)
	result, err := a.DB.Exec(ctx,
		`DELETE FROM {{plural (snake .Name)}} WHERE id = $1 AND tenant_id = $2`,
		id, delTenantID,
	)
{{- else}}
	result, err := a.DB.Exec(ctx,
		`DELETE FROM {{plural (snake .Name)}} WHERE id = $1`,
		id,
	)
{{- end}}
	if err != nil {
		return errors.MapDBError(err)
	}
	if result.RowsAffected() == 0 {
		return errors.NotFound("{{.Name}}", id.String())
	}
	return nil
{{- end}}
}
{{- if .Options.SoftDelete}}

// Restore restores a soft-deleted {{.Name}} by clearing deleted_at.
func (a *Default{{.Name}}Actions) Restore(ctx context.Context, id uuid.UUID) (*models.{{.Name}}, error) {
{{- if hasPermission .Options "delete"}}
	if err := checkPermission(ctx, {{permissionRoles .Options "delete"}}); err != nil {
		return nil, err
	}
{{- end}}
	result, err := a.DB.Exec(ctx,
		`UPDATE {{plural (snake .Name)}} SET deleted_at = NULL WHERE id = $1 AND deleted_at IS NOT NULL`,
		id,
	)
	if err != nil {
		return nil, errors.InternalError(fmt.Errorf("failed to restore {{.Name}}"))
	}
	if result.RowsAffected() == 0 {
		return nil, errors.NotFound("{{.Name}}", id.String())
	}
	return a.Get(ctx, id)
}
{{- end}}
{{- if hasAnyPermission .Options}}

// checkPermission verifies the current user's role is in the allowed roles list.
// Returns a Forbidden error if the role is not permitted.
func checkPermission(ctx context.Context, allowedRoles ...string) error {
	role := forgeauth.RoleFromContext(ctx)
	for _, r := range allowedRoles {
		if r == role {
			return nil
		}
	}
	return errors.Forbidden("insufficient permissions")
}
{{- end}}
{{- if .Options.Auditable}}

// computeJSONDiff compares two map representations and returns only changed fields.
// Each changed field has "before" and "after" values. Returns nil if no changes.
func computeJSONDiff(before, after map[string]any) map[string]any {
	diff := make(map[string]any)
	for k, afterVal := range after {
		beforeVal, exists := before[k]
		if !exists {
			diff[k] = map[string]any{"before": nil, "after": afterVal}
		} else if !reflect.DeepEqual(beforeVal, afterVal) {
			diff[k] = map[string]any{"before": beforeVal, "after": afterVal}
		}
	}
	// Check for deleted keys (in before but not in after)
	for k, beforeVal := range before {
		if _, exists := after[k]; !exists {
			diff[k] = map[string]any{"before": beforeVal, "after": nil}
		}
	}
	if len(diff) == 0 {
		return nil
	}
	return diff
}

// recordAudit records a change to the audit_logs table.
// before is nil for creates (all fields recorded as new values).
// If before and after are identical, no entry is recorded (AUDIT-03: no-op updates).
func (a *Default{{.Name}}Actions) recordAudit(ctx context.Context, op string, resourceID uuid.UUID, before, after any) error {
	var beforeMap, afterMap map[string]any

	if before != nil {
		b, _ := json.Marshal(before)
		json.Unmarshal(b, &beforeMap) //nolint:errcheck
	}
	a2, _ := json.Marshal(after)
	json.Unmarshal(a2, &afterMap) //nolint:errcheck

	diff := computeJSONDiff(beforeMap, afterMap)
	if diff == nil && op != "create" {
		return nil // No changes — skip audit entry (AUDIT-03)
	}

	// For creates, record all fields as the diff
	if op == "create" && diff == nil {
		diff = afterMap
	}

	userID := forgeauth.UserFromContext(ctx)
	diffJSON, _ := json.Marshal(diff)

	var userIDPtr *uuid.UUID
	if userID != (uuid.UUID{}) {
		userIDPtr = &userID
	}

	_, err := a.DB.Exec(ctx,
		`INSERT INTO audit_logs (resource_type, resource_id, operation, changed_fields, created_by)
		 VALUES ($1, $2, $3, $4, $5)`,
		"{{snake .Name}}", resourceID, op, diffJSON, userIDPtr,
	)
	return err
}

// GetDB returns the database connection for direct queries (e.g., audit log).
func (a *Default{{.Name}}Actions) GetDB() DB {
	return a.DB
}
{{- end}}
{{- if hasAnyVisibility .Fields}}

// roleFilter returns a map representation of the model with invisible fields omitted
// based on the current user's role. Fields with Visibility("role") are only included
// when the user's role matches. Fields without Visibility are always included.
// Per user decision: invisible fields omitted entirely (key doesn't appear in JSON).
func (a *Default{{.Name}}Actions) roleFilter(role string, item models.{{.Name}}) map[string]any {
	result := map[string]any{
		"id": item.ID,
		{{- range .Fields}}
		{{- if not (isIDField .)}}
		{{- if not (hasModifier .Modifiers "Visibility")}}
		"{{snake .Name}}": item.{{.Name}},
		{{- end}}
		{{- end}}
		{{- end}}
		{{- if .HasTimestamps}}
		"created_at": item.CreatedAt,
		"updated_at": item.UpdatedAt,
		{{- end}}
		{{- if .Options.SoftDelete}}
		"deleted_at": item.DeletedAt,
		{{- end}}
	}
	{{- range .Fields}}
	{{- if and (not (isIDField .)) (hasModifier .Modifiers "Visibility")}}
	// Field {{.Name}} visible only for role "{{getModifierValue .Modifiers "Visibility"}}"
	if role == "" || role == "{{getModifierValue .Modifiers "Visibility"}}" {
		result["{{snake .Name}}"] = item.{{.Name}}
	}
	{{- end}}
	{{- end}}
	return result
}

// RoleFilterList applies roleFilter to a slice of items, stripping invisible fields
// based on the current user's role.
func (a *Default{{.Name}}Actions) RoleFilterList(role string, items []models.{{.Name}}) []map[string]any {
	result := make([]map[string]any, len(items))
	for i, item := range items {
		result[i] = a.roleFilter(role, item)
	}
	return result
}
{{- end}}
