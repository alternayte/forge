---
phase: 09-public-api-surface-end-to-end-flow
plan: 05
type: execute
wave: 5
depends_on: ["09-04"]
files_modified:
  - internal/generator/templates/main.go.tmpl
  - internal/generator/generate_main.go
  - internal/generator/generator.go
  - internal/watcher/dev.go
  - internal/cli/generate.go
autonomous: true
requirements: []

must_haves:
  truths:
    - "forge generate scaffolds a main.go into the project root (scaffold-once: skip if exists)"
    - "Generated main.go uses forge.New(cfg).RegisterAPIRoutes(...).RegisterHTMLRoutes(...).Listen()"
    - "forge dev detects schema changes and auto-runs migrate diff + migrate up"
    - "forge dev auto-creates the database if it does not exist (dev-mode only)"
    - "go build ./... compiles the forge CLI with all changes"
  artifacts:
    - path: "internal/generator/templates/main.go.tmpl"
      provides: "Generated main.go template for user projects"
      contains: "forge.New"
    - path: "internal/generator/generate_main.go"
      provides: "Main.go scaffold-once generation logic"
      contains: "func GenerateMain"
    - path: "internal/watcher/dev.go"
      provides: "Enhanced dev server with auto-migrate"
      contains: "ensureDatabase"
  key_links:
    - from: "internal/generator/generator.go"
      to: "internal/generator/generate_main.go"
      via: "GenerateMain called from Generate orchestrator"
      pattern: "GenerateMain"
    - from: "internal/generator/templates/main.go.tmpl"
      to: "forge/forge.go"
      via: "generated main.go imports forge package"
      pattern: "alternayte/forge/forge"
    - from: "internal/watcher/dev.go"
      to: "internal/migrate/"
      via: "auto-migrate on schema change"
      pattern: "migrate\\.Diff\\|migrate\\.Up"
---

<objective>
Add forge generate main.go scaffolding (scaffold-once) and enhance forge dev with auto-DB-create and auto-migrate behavior.

Purpose: This completes the golden path: forge init myapp -> forge generate -> forge dev. forge generate produces a working main.go that wires the generated API and HTML routes via forge.App. forge dev auto-creates the database and auto-runs migrations on schema changes, making the development loop seamless.

Output: Generator template for main.go, scaffold-once logic in generator, enhanced dev server with auto-migrate.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-RESEARCH.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-01-SUMMARY.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-02-SUMMARY.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-03-SUMMARY.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-04-SUMMARY.md
@internal/generator/generator.go
@internal/watcher/dev.go
@internal/cli/generate.go
@internal/migrate/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add forge generate main.go scaffolding</name>
  <files>
    internal/generator/templates/main.go.tmpl
    internal/generator/generate_main.go
    internal/generator/generator.go
  </files>
  <action>
Create a main.go template in the generator and add scaffold-once logic.

**1. Create internal/generator/templates/main.go.tmpl** — this is the GENERATOR main.go template (distinct from the scaffold main.go.tmpl in internal/scaffold/templates/). It produces a fully working main.go.

**CRITICAL: RegisterAllRoutes signature.** The generated `api_register_all.go.tmpl` produces `RegisterAllRoutes(api huma.API, registry *actions.Registry)` which takes TWO arguments. The main.go template must construct the actions.Registry and pass it. The closure passed to `RegisterAPIRoutes(func(api huma.API) { ... })` captures the registry:

The template file should follow the same pattern as other generator templates (e.g., `api_register_all.go.tmpl`) using `{{.ProjectModule}}` for imports:

```
package main

import (
	"log"

	"github.com/alternayte/forge/forge"
	"github.com/danielgtaylor/huma/v2"
	"github.com/go-chi/chi/v5"

	genactions "{{.ProjectModule}}/gen/actions"
	genapi "{{.ProjectModule}}/gen/api"
	genhtml "{{.ProjectModule}}/gen/html"
	genmiddleware "{{.ProjectModule}}/gen/middleware"
)

func main() {
	cfg, err := forge.LoadConfig("forge.toml")
	if err != nil {
		log.Fatal(err)
	}

	// Build the actions registry with default implementations.
	// Override individual resources by calling registry.Register("resource", customActions).
	registry := genactions.NewRegistry(nil) // nil DB pool — App.Listen() will wire it

	app := forge.New(cfg).
		UseRecovery(genmiddleware.Recovery).
		RegisterAPIRoutes(func(api huma.API) {
			genapi.RegisterAllRoutes(api, registry)
		}).
		RegisterHTMLRoutes(func(r chi.Router) {
			genhtml.RegisterAllHTMLRoutes(r)
		})

	log.Fatal(app.Listen(cfg.ServerAddr()))
}
```

**CRITICAL: RegisterAllRoutes takes two args.** The generated `api_register_all.go.tmpl` produces `RegisterAllRoutes(api huma.API, registry *actions.Registry)`. The main.go template MUST construct the registry and pass it as the second argument. The closure passed to forge.App's `RegisterAPIRoutes(func(api huma.API))` captures the registry variable.

NOTE: The `genactions.NewRegistry(nil)` call is a placeholder pattern. The executor MUST read `actions.go.tmpl` and `api_register_all.go.tmpl` to determine the exact Registry constructor signature (it may require a DB pool or pgxpool.Pool). If Registry requires a pool, the main.go.tmpl must either:
- (a) Accept a pool parameter from forge.App (add a `WithPool(func(*pgxpool.Pool))` callback to App), OR
- (b) Defer registry creation until the pool is available inside the RegisterAPIRoutes callback.

The executor should check what `actions.Registry` requires and wire it accordingly.

**2. Create internal/generator/generate_main.go** — scaffold-once logic:

```go
package generator

import (
	"os"
	"path/filepath"
)

// GenerateMain scaffolds a main.go in the project root if one doesn't already exist.
// This follows the scaffold-once pattern: if the user has already edited main.go,
// we don't overwrite it. Use `forge generate --diff` to show what a fresh main.go would look like.
func GenerateMain(projectRoot, projectModule string) error {
	mainPath := filepath.Join(projectRoot, "main.go")

	// Scaffold-once: skip if main.go already exists and has been modified
	// from the original scaffold placeholder
	if _, err := os.Stat(mainPath); err == nil {
		// File exists — check if it's the init placeholder or user-modified
		content, err := os.ReadFile(mainPath)
		if err != nil {
			return err
		}
		// If main.go already imports forge, it's been generated before — skip
		if bytes.Contains(content, []byte("forge.New")) || bytes.Contains(content, []byte("forge.LoadConfig")) {
			return nil
		}
	}

	// Render the main.go template
	data := struct {
		ProjectModule string
	}{
		ProjectModule: projectModule,
	}

	raw, err := renderTemplate("templates/main.go.tmpl", data)
	if err != nil {
		return err
	}

	return writeGoFile(mainPath, raw)
}
```

**Embed directive verification:** The generator's embed in `internal/generator/templates.go` uses `//go:embed templates/*` which is a glob pattern covering ALL files in the `templates/` directory. A new `templates/main.go.tmpl` file will be automatically included in `TemplatesFS` — no embed directive changes are needed. The scaffold templates in `internal/scaffold/templates/` are a separate embed in a different package. No collision.

**3. Update internal/generator/generator.go** — add `GenerateMain` call to the `Generate` orchestrator function. Add it AFTER all gen/ generation, since it writes to project root (not gen/):

```go
// Scaffold main.go if it doesn't exist or is still the placeholder
if err := GenerateMain(cfg.ProjectRoot, cfg.ProjectModule); err != nil {
    return err
}
```

**4. Run `go build ./...`** to verify compilation.
  </action>
  <verify>
    - `ls internal/generator/templates/main.go.tmpl` exists
    - `ls internal/generator/generate_main.go` exists
    - `grep "GenerateMain" internal/generator/generator.go` finds the orchestrator call
    - `grep "forge.New" internal/generator/templates/main.go.tmpl` finds App builder usage
    - `grep "RegisterAllRoutes(api, registry)" internal/generator/templates/main.go.tmpl` confirms two-arg call
    - `grep 'go:embed templates' internal/generator/templates.go` confirms glob embed covers main.go.tmpl
    - `go build ./...` compiles
  </verify>
  <done>forge generate scaffolds a working main.go on first run with correct RegisterAllRoutes(api, registry) call. Subsequent runs skip if main.go already uses forge.App.</done>
</task>

<task type="auto">
  <name>Task 2: Add forge dev auto-DB-create and auto-migrate</name>
  <files>
    internal/watcher/dev.go
  </files>
  <action>
Enhance the DevServer to auto-create the database and auto-run migrations when schema changes are detected.

**1. Add ensureDatabase method to DevServer** — auto-creates the PostgreSQL database if it doesn't exist. Parse the database URL from config to extract host/port/user/dbname, then connect to the `postgres` maintenance database and run `CREATE DATABASE IF NOT EXISTS`:

```go
// ensureDatabase creates the application database if it doesn't exist.
// This is a dev-mode convenience — production apps use explicit database management.
func (d *DevServer) ensureDatabase() error {
    dbURL := d.Config.Database.URL
    if dbURL == "" {
        return nil // No database configured
    }

    // Parse the URL to extract the database name
    u, err := url.Parse(dbURL)
    if err != nil {
        return fmt.Errorf("parse database URL: %w", err)
    }

    dbName := strings.TrimPrefix(u.Path, "/")
    if dbName == "" {
        return nil
    }

    // Connect to the maintenance database (postgres) to create the app database
    maintURL := *u
    maintURL.Path = "/postgres"

    conn, err := pgx.Connect(context.Background(), maintURL.String())
    if err != nil {
        return fmt.Errorf("connect to maintenance DB: %w", err)
    }
    defer conn.Close(context.Background())

    // Check if database exists
    var exists bool
    err = conn.QueryRow(context.Background(),
        "SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname = $1)", dbName).Scan(&exists)
    if err != nil {
        return err
    }

    if !exists {
        // CREATE DATABASE doesn't support parameters, use string formatting
        // (dbName comes from the user's own forge.toml, not external input)
        _, err = conn.Exec(context.Background(), fmt.Sprintf("CREATE DATABASE %q", dbName))
        if err != nil {
            return err
        }
        fmt.Println(ui.Success(fmt.Sprintf("Created database %s", dbName)))
    }

    return nil
}
```

NOTE: Check `internal/cli/db.go` for existing database creation logic — there may be a `createDatabase` function already implemented that can be reused or referenced. If so, refactor to share the logic rather than duplicating.

**2. Add auto-migrate after generation** — modify `runGeneration` (or create a new `runGenerationAndMigrate` method) to:

a. Hash `gen/atlas/schema.hcl` BEFORE generation
b. Run generation as today
c. Hash `gen/atlas/schema.hcl` AFTER generation
d. If hash changed: auto-run `migrate.Diff` + `migrate.Up`

```go
func (d *DevServer) runGenerationAndMigrate() error {
    // 1. Hash schema before generation
    beforeHash := d.hashSchemaFile()

    // 2. Run generation
    if err := d.runGeneration(); err != nil {
        return err
    }

    // 3. Hash schema after generation
    afterHash := d.hashSchemaFile()
    if beforeHash == afterHash {
        return nil // No schema changes
    }

    // 4. Auto-create DB if needed
    if err := d.ensureDatabase(); err != nil {
        fmt.Println(ui.Warn(fmt.Sprintf("Could not auto-create database: %v", err)))
        // Non-fatal: continue anyway
    }

    // 5. Auto-migrate
    fmt.Println(ui.Info("Schema changed, running migration..."))
    // Use the existing migrate package to diff and apply
    // migrate.Diff(cfg, "auto_dev", true) — force=true in dev
    // migrate.Up(cfg)
    // Print the applied SQL

    return nil
}
```

**3. Update onFileChange and Start** to call `runGenerationAndMigrate` instead of `runGeneration`.

**4. Add hashSchemaFile helper**:

```go
func (d *DevServer) hashSchemaFile() string {
    path := filepath.Join(d.ProjectRoot, "gen", "atlas", "schema.hcl")
    data, err := os.ReadFile(path)
    if err != nil {
        return ""
    }
    h := sha256.Sum256(data)
    return hex.EncodeToString(h[:])
}
```

**Chosen approach: Use the `internal/migrate` package API (NOT exec.Command).** The migrate package already wraps atlas CLI calls internally via exec.Command. Its exported API is:

- `migrate.Diff(cfg migrate.Config, name string, force bool) (string, error)` — generates a migration file
- `migrate.Up(cfg migrate.Config) (string, error)` — applies pending migrations

The `migrate.Config` struct requires:
```go
type Config struct {
    AtlasBin     string // Path to atlas binary
    MigrationDir string // Path to migrations/ directory
    SchemaURL    string // Path to gen/atlas/schema.hcl
    DatabaseURL  string // PostgreSQL connection URL
    DevURL       string // Dev database URL for atlas diff
}
```

Construct this from the DevServer's config:
```go
migrateCfg := migrate.Config{
    AtlasBin:     filepath.Join(d.ProjectRoot, ".forge", "bin", "atlas"),
    MigrationDir: filepath.Join(d.ProjectRoot, "migrations"),
    SchemaURL:    filepath.Join(d.ProjectRoot, "gen", "atlas", "schema.hcl"),
    DatabaseURL:  d.Config.Database.URL,
    DevURL:       "docker://postgres/15/dev?search_path=public",
}
```

Then call: `migrate.Diff(migrateCfg, "auto_dev", true)` followed by `migrate.Up(migrateCfg)`. The `force=true` flag skips destructive change warnings in dev mode. The DevURL uses atlas's docker driver for schema diffing.

NOTE: Check `internal/cli/migrate.go` for how the CLI constructs `migrate.Config` — mirror that construction pattern in the dev server. The atlas binary path may use the tool-sync mechanism from `internal/tools/`.

**5. Add required imports** — `crypto/sha256`, `encoding/hex`, `net/url`, `github.com/jackc/pgx/v5` for database creation.

**6. Run `go build ./...`** to verify compilation.
  </action>
  <verify>
    - `grep "ensureDatabase" internal/watcher/dev.go` finds the method
    - `grep "hashSchemaFile" internal/watcher/dev.go` finds the helper
    - `grep "runGenerationAndMigrate\|auto-migrate\|Schema changed" internal/watcher/dev.go` finds the enhanced flow
    - `go build ./...` compiles
  </verify>
  <done>forge dev auto-creates database if missing and auto-runs migrate diff + up on schema changes. The 3-step golden path (init -> generate -> dev) works end-to-end.</done>
</task>

</tasks>

<verification>
1. `go build ./...` — full build passes
2. Generator template for main.go exists and uses forge.App
3. Generator orchestrator calls GenerateMain
4. Dev server has ensureDatabase and auto-migrate logic
5. No references to old module path remain
</verification>

<success_criteria>
- forge generate scaffolds a working main.go (scaffold-once)
- Generated main.go uses forge.New(cfg).RegisterAPIRoutes(...).Listen(...)
- forge dev auto-creates database in dev mode
- forge dev auto-runs migrations when schema.hcl changes
- Complete golden path: forge init -> forge generate -> forge dev produces a running app
</success_criteria>

<output>
After completion, create `.planning/phases/09-public-api-surface-end-to-end-flow/09-05-SUMMARY.md`
</output>
