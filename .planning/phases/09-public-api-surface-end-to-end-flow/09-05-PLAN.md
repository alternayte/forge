---
phase: 09-public-api-surface-end-to-end-flow
plan: 05
type: execute
wave: 4
depends_on: ["09-04"]
files_modified:
  - internal/generator/templates/main.go.tmpl
  - internal/generator/generate_main.go
  - internal/generator/generator.go
  - internal/watcher/dev.go
  - internal/cli/generate.go
autonomous: true
requirements: []

must_haves:
  truths:
    - "forge generate scaffolds a main.go into the project root (scaffold-once: skip if exists)"
    - "Generated main.go uses forge.New(cfg).RegisterAPIRoutes(...).RegisterHTMLRoutes(...).Listen()"
    - "forge dev detects schema changes and auto-runs migrate diff + migrate up"
    - "forge dev auto-creates the database if it does not exist (dev-mode only)"
    - "go build ./... compiles the forge CLI with all changes"
  artifacts:
    - path: "internal/generator/templates/main.go.tmpl"
      provides: "Generated main.go template for user projects"
      contains: "forge.New"
    - path: "internal/generator/generate_main.go"
      provides: "Main.go scaffold-once generation logic"
      contains: "func GenerateMain"
    - path: "internal/watcher/dev.go"
      provides: "Enhanced dev server with auto-migrate"
      contains: "ensureDatabase"
  key_links:
    - from: "internal/generator/generator.go"
      to: "internal/generator/generate_main.go"
      via: "GenerateMain called from Generate orchestrator"
      pattern: "GenerateMain"
    - from: "internal/generator/templates/main.go.tmpl"
      to: "forge/forge.go"
      via: "generated main.go imports forge package"
      pattern: "alternayte/forge/forge"
    - from: "internal/watcher/dev.go"
      to: "internal/migrate/"
      via: "auto-migrate on schema change"
      pattern: "migrate\\.Diff\\|migrate\\.Up"
---

<objective>
Add forge generate main.go scaffolding (scaffold-once) and enhance forge dev with auto-DB-create and auto-migrate behavior.

Purpose: This completes the golden path: forge init myapp -> forge generate -> forge dev. forge generate produces a working main.go that wires the generated API and HTML routes via forge.App. forge dev auto-creates the database and auto-runs migrations on schema changes, making the development loop seamless.

Output: Generator template for main.go, scaffold-once logic in generator, enhanced dev server with auto-migrate.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-RESEARCH.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-01-SUMMARY.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-02-SUMMARY.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-03-SUMMARY.md
@.planning/phases/09-public-api-surface-end-to-end-flow/09-04-SUMMARY.md
@internal/generator/generator.go
@internal/watcher/dev.go
@internal/cli/generate.go
@internal/migrate/
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add forge generate main.go scaffolding</name>
  <files>
    internal/generator/templates/main.go.tmpl
    internal/generator/generate_main.go
    internal/generator/generator.go
  </files>
  <action>
Create a main.go template in the generator and add scaffold-once logic.

**1. Create internal/generator/templates/main.go.tmpl** — this is the GENERATOR main.go template (distinct from the scaffold main.go.tmpl in internal/scaffold/templates/). It produces a fully working main.go:

```go
package main

import (
	"log"

	"github.com/alternayte/forge/forge"
	"github.com/danielgtaylor/huma/v2"
	"github.com/go-chi/chi/v5"

	genapi "{{.ProjectModule}}/gen/api"
	genhtml "{{.ProjectModule}}/gen/html"
	genmiddleware "{{.ProjectModule}}/gen/middleware"
)

func main() {
	cfg, err := forge.LoadConfig("forge.toml")
	if err != nil {
		log.Fatal(err)
	}

	app := forge.New(cfg).
		UseRecovery(genmiddleware.Recovery).
		RegisterAPIRoutes(func(api huma.API) {
			genapi.RegisterAllRoutes(api)
		}).
		RegisterHTMLRoutes(func(r chi.Router) {
			genhtml.RegisterAllHTMLRoutes(r)
		})

	log.Fatal(app.Listen(cfg.ServerAddr()))
}
```

NOTE: The exact imports and wiring depend on what the generated `gen/api`, `gen/html`, and `gen/middleware` packages actually export. Read the existing templates (`api_register_all.go.tmpl`, `html_register_all.go.tmpl`, `middleware_recovery.go.tmpl`) to verify the function signatures (e.g., `RegisterAllRoutes` might take `(api huma.API, registry *actions.Registry)` — in which case the main.go template needs to construct the registry too). Adjust the template accordingly.

The template should use `{{.ProjectModule}}` for the user's module path (same variable used by other generator templates).

**2. Create internal/generator/generate_main.go** — scaffold-once logic:

```go
package generator

import (
	"os"
	"path/filepath"
)

// GenerateMain scaffolds a main.go in the project root if one doesn't already exist.
// This follows the scaffold-once pattern: if the user has already edited main.go,
// we don't overwrite it. Use `forge generate --diff` to show what a fresh main.go would look like.
func GenerateMain(projectRoot, projectModule string) error {
	mainPath := filepath.Join(projectRoot, "main.go")

	// Scaffold-once: skip if main.go already exists and has been modified
	// from the original scaffold placeholder
	if _, err := os.Stat(mainPath); err == nil {
		// File exists — check if it's the init placeholder or user-modified
		content, err := os.ReadFile(mainPath)
		if err != nil {
			return err
		}
		// If main.go already imports forge, it's been generated before — skip
		if bytes.Contains(content, []byte("forge.New")) || bytes.Contains(content, []byte("forge.LoadConfig")) {
			return nil
		}
	}

	// Render the main.go template
	data := struct {
		ProjectModule string
	}{
		ProjectModule: projectModule,
	}

	raw, err := renderTemplate("templates/main.go.tmpl", data)
	if err != nil {
		return err
	}

	return writeGoFile(mainPath, raw)
}
```

IMPORTANT: The generator's templates/ directory already has a `main.go.tmpl` name collision with the template file we're creating. Wait — actually the scaffold templates are in `internal/scaffold/templates/` and generator templates are in `internal/generator/templates/`. They're different directories. However, check the generator's TemplatesFS embed directive to make sure `main.go.tmpl` is included.

**3. Update internal/generator/generator.go** — add `GenerateMain` call to the `Generate` orchestrator function. Add it AFTER all gen/ generation, since it writes to project root (not gen/):

```go
// Scaffold main.go if it doesn't exist or is still the placeholder
if err := GenerateMain(cfg.ProjectRoot, cfg.ProjectModule); err != nil {
    return err
}
```

**4. Run `go build ./...`** to verify compilation.
  </action>
  <verify>
    - `ls internal/generator/templates/main.go.tmpl` exists
    - `ls internal/generator/generate_main.go` exists
    - `grep "GenerateMain" internal/generator/generator.go` finds the orchestrator call
    - `grep "forge.New" internal/generator/templates/main.go.tmpl` finds App builder usage
    - `go build ./...` compiles
  </verify>
  <done>forge generate scaffolds a working main.go on first run. Subsequent runs skip if main.go already uses forge.App.</done>
</task>

<task type="auto">
  <name>Task 2: Add forge dev auto-DB-create and auto-migrate</name>
  <files>
    internal/watcher/dev.go
  </files>
  <action>
Enhance the DevServer to auto-create the database and auto-run migrations when schema changes are detected.

**1. Add ensureDatabase method to DevServer** — auto-creates the PostgreSQL database if it doesn't exist. Parse the database URL from config to extract host/port/user/dbname, then connect to the `postgres` maintenance database and run `CREATE DATABASE IF NOT EXISTS`:

```go
// ensureDatabase creates the application database if it doesn't exist.
// This is a dev-mode convenience — production apps use explicit database management.
func (d *DevServer) ensureDatabase() error {
    dbURL := d.Config.Database.URL
    if dbURL == "" {
        return nil // No database configured
    }

    // Parse the URL to extract the database name
    u, err := url.Parse(dbURL)
    if err != nil {
        return fmt.Errorf("parse database URL: %w", err)
    }

    dbName := strings.TrimPrefix(u.Path, "/")
    if dbName == "" {
        return nil
    }

    // Connect to the maintenance database (postgres) to create the app database
    maintURL := *u
    maintURL.Path = "/postgres"

    conn, err := pgx.Connect(context.Background(), maintURL.String())
    if err != nil {
        return fmt.Errorf("connect to maintenance DB: %w", err)
    }
    defer conn.Close(context.Background())

    // Check if database exists
    var exists bool
    err = conn.QueryRow(context.Background(),
        "SELECT EXISTS(SELECT 1 FROM pg_database WHERE datname = $1)", dbName).Scan(&exists)
    if err != nil {
        return err
    }

    if !exists {
        // CREATE DATABASE doesn't support parameters, use string formatting
        // (dbName comes from the user's own forge.toml, not external input)
        _, err = conn.Exec(context.Background(), fmt.Sprintf("CREATE DATABASE %q", dbName))
        if err != nil {
            return err
        }
        fmt.Println(ui.Success(fmt.Sprintf("Created database %s", dbName)))
    }

    return nil
}
```

NOTE: Check `internal/cli/db.go` for existing database creation logic — there may be a `createDatabase` function already implemented that can be reused or referenced. If so, refactor to share the logic rather than duplicating.

**2. Add auto-migrate after generation** — modify `runGeneration` (or create a new `runGenerationAndMigrate` method) to:

a. Hash `gen/atlas/schema.hcl` BEFORE generation
b. Run generation as today
c. Hash `gen/atlas/schema.hcl` AFTER generation
d. If hash changed: auto-run `migrate.Diff` + `migrate.Up`

```go
func (d *DevServer) runGenerationAndMigrate() error {
    // 1. Hash schema before generation
    beforeHash := d.hashSchemaFile()

    // 2. Run generation
    if err := d.runGeneration(); err != nil {
        return err
    }

    // 3. Hash schema after generation
    afterHash := d.hashSchemaFile()
    if beforeHash == afterHash {
        return nil // No schema changes
    }

    // 4. Auto-create DB if needed
    if err := d.ensureDatabase(); err != nil {
        fmt.Println(ui.Warn(fmt.Sprintf("Could not auto-create database: %v", err)))
        // Non-fatal: continue anyway
    }

    // 5. Auto-migrate
    fmt.Println(ui.Info("Schema changed, running migration..."))
    // Use the existing migrate package to diff and apply
    // migrate.Diff(cfg, "auto_dev", true) — force=true in dev
    // migrate.Up(cfg)
    // Print the applied SQL

    return nil
}
```

**3. Update onFileChange and Start** to call `runGenerationAndMigrate` instead of `runGeneration`.

**4. Add hashSchemaFile helper**:

```go
func (d *DevServer) hashSchemaFile() string {
    path := filepath.Join(d.ProjectRoot, "gen", "atlas", "schema.hcl")
    data, err := os.ReadFile(path)
    if err != nil {
        return ""
    }
    h := sha256.Sum256(data)
    return hex.EncodeToString(h[:])
}
```

IMPORTANT: Check what `internal/migrate/` exports. The migrate package likely has `Diff()` and `Up()` functions — read the package to understand the exact signatures and adapt. If the migrate functions require a config that needs an atlas binary path, use `d.Config` to provide it.

If the migrate package integration proves too complex for the dev server (requires too many config dependencies), implement a simpler version that just shells out to `atlas migrate diff` and `atlas migrate apply` using exec.Command, similar to how the CLI does it.

**5. Add required imports** — `crypto/sha256`, `encoding/hex`, `net/url`, `github.com/jackc/pgx/v5` for database creation.

**6. Run `go build ./...`** to verify compilation.
  </action>
  <verify>
    - `grep "ensureDatabase" internal/watcher/dev.go` finds the method
    - `grep "hashSchemaFile" internal/watcher/dev.go` finds the helper
    - `grep "runGenerationAndMigrate\|auto-migrate\|Schema changed" internal/watcher/dev.go` finds the enhanced flow
    - `go build ./...` compiles
  </verify>
  <done>forge dev auto-creates database if missing and auto-runs migrate diff + up on schema changes. The 3-step golden path (init -> generate -> dev) works end-to-end.</done>
</task>

</tasks>

<verification>
1. `go build ./...` — full build passes
2. Generator template for main.go exists and uses forge.App
3. Generator orchestrator calls GenerateMain
4. Dev server has ensureDatabase and auto-migrate logic
5. No references to old module path remain
</verification>

<success_criteria>
- forge generate scaffolds a working main.go (scaffold-once)
- Generated main.go uses forge.New(cfg).RegisterAPIRoutes(...).Listen(...)
- forge dev auto-creates database in dev mode
- forge dev auto-runs migrations when schema.hcl changes
- Complete golden path: forge init -> forge generate -> forge dev produces a running app
</success_criteria>

<output>
After completion, create `.planning/phases/09-public-api-surface-end-to-end-flow/09-05-SUMMARY.md`
</output>
