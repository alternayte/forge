---
phase: 08-background-jobs-production-readiness
plan: 05
type: execute
wave: 2
depends_on: ["08-02"]
files_modified:
  - internal/cli/build.go
  - internal/cli/deploy.go
  - internal/cli/root.go
  - internal/generator/templates/embed.go.tmpl
autonomous: true
requirements:
  - CLI-03
  - CLI-07
  - DEPLOY-02
  - DEPLOY-03

must_haves:
  truths:
    - "forge build runs generate -> templ generate -> tailwind build -> go build with -trimpath -ldflags producing a single binary"
    - "forge build injects Version, Commit, and Date via ldflags -X flags"
    - "forge deploy generates a multi-stage Dockerfile in the project root"
    - "Generated Dockerfile uses alpine base with HEALTHCHECK on admin port"
    - "forge build and forge deploy commands are registered in root.go"
  artifacts:
    - path: "internal/cli/build.go"
      provides: "forge build command running full production build pipeline"
      contains: "func newBuildCmd"
    - path: "internal/cli/deploy.go"
      provides: "forge deploy command generating Dockerfile"
      contains: "func newDeployCmd"
    - path: "internal/cli/root.go"
      provides: "build and deploy commands registered"
      contains: "newBuildCmd"
    - path: "internal/generator/templates/embed.go.tmpl"
      provides: "Template for generating embed.go with //go:embed directives"
      contains: "go:embed"
  key_links:
    - from: "internal/cli/build.go"
      to: "internal/cli/version.go"
      via: "Build uses ldflags to set cli.Version, cli.Commit, cli.Date"
      pattern: "ldflags.*Version"
    - from: "internal/cli/build.go"
      to: "internal/cli/generate.go"
      via: "Build pipeline calls forge generate as first step"
      pattern: "generate"
    - from: "internal/cli/root.go"
      to: "internal/cli/build.go"
      via: "rootCmd.AddCommand(newBuildCmd())"
      pattern: "newBuildCmd"
---

<objective>
Add forge build and forge deploy CLI commands for producing a single production binary with embedded assets and generating a Dockerfile for container deployment.

Purpose: Delivers the production packaging pipeline — one command from clean state to deployable binary, and one command to generate a universal Dockerfile.
Output: forge build command (full pipeline + go build with ldflags), forge deploy command (Dockerfile generation), embed.go template for static assets.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-background-jobs-production-readiness/08-RESEARCH.md
@.planning/phases/08-background-jobs-production-readiness/08-02-SUMMARY.md

# Key files
@internal/cli/root.go
@internal/cli/version.go
@internal/cli/generate.go
@internal/cli/dev.go
@internal/config/config.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create forge build command with full pipeline and ldflags</name>
  <files>
    internal/cli/build.go
    internal/generator/templates/embed.go.tmpl
  </files>
  <action>
1. Create `internal/cli/build.go`:
   - `func newBuildCmd() *cobra.Command` returning a build command:
     - Use: "build"
     - Short: "Build production binary"
     - Long: "Runs the full build pipeline: generate -> templ generate -> tailwind build -> go build with production optimizations."
     - Flags: `--output` / `-o` (string, default `./bin/<project-name>` derived from forge.toml project.name)

   - `func runBuild(cmd *cobra.Command, args []string) error`:
     a. Find project root (same pattern as other CLI commands — `findProjectRoot()` or search for forge.toml)
     b. Load config from forge.toml
     c. Run pipeline steps sequentially, each printing a status line:
        - Step 1: Run `forge generate` (call the internal generate function or shell out to `forge generate`)
          Prefer calling the internal function directly if accessible, otherwise use `exec.Command("forge", "generate")`.
          Actually, use the existing internal functions: call the same logic as `runGenerate` from generate.go.
          **Simpler approach:** Shell out to sub-processes since `forge build` is a pipeline orchestrator:
          ```go
          steps := []struct{ name, cmd string; args []string }{
              {"Generating code", "forge", {"generate"}},
              {"Compiling templates", templBin, {"generate", "./..."}},
              {"Building CSS", tailwindBin, {"--input", "static/css/input.css", "--output", "static/css/app.css", "--minify"}},
          }
          ```
          For templ and tailwind, check `.forge/bin/` first then PATH (same pattern as dev.go).

        - Step 2: Run `templ generate ./...` (use templ binary from .forge/bin/ or PATH)
        - Step 3: Run tailwind build with `--minify` flag (use tailwind binary from .forge/bin/ or PATH)
        - Step 4: Run `go build` with production flags:
          ```
          go build -trimpath \
            -ldflags="-s -w \
              -X github.com/forge-framework/forge/internal/cli.Version=$(git describe --tags --always 2>/dev/null || echo dev) \
              -X github.com/forge-framework/forge/internal/cli.Commit=$(git rev-parse --short HEAD 2>/dev/null || echo none) \
              -X github.com/forge-framework/forge/internal/cli.Date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            -o <output-path> .
          ```
          Build the ldflags string programmatically in Go:
          - Get git tag via `exec.Command("git", "describe", "--tags", "--always")`
          - Get commit via `exec.Command("git", "rev-parse", "--short", "HEAD")`
          - Get date via `time.Now().UTC().Format(time.RFC3339)`
          - Construct ldflags string with `-X` flags referencing `github.com/forge-framework/forge/internal/cli.Version` etc.

     d. Print success message with binary path and size (os.Stat the output file)

2. Create `internal/generator/templates/embed.go.tmpl`:
   - This template generates an `embed.go` file in the user's project root that embeds migrations and static assets:
     ```go
     package main

     import "embed"

     //go:embed migrations/*.sql
     var MigrationsFS embed.FS

     //go:embed static
     var StaticFS embed.FS
     ```
   - This file should be generated by `forge generate` (or `forge build`) into the project root, NOT into gen/.
   - **Note:** The embed directives require the directories to exist. `forge build` should ensure `migrations/` and `static/` directories exist (create empty dirs if needed) before running `go build`.

   - Add a `GenerateEmbed` function call in the generator orchestrator OR have `forge build` handle this as a pre-build step. Since embed.go belongs in the user's project root (not gen/), handling it in `forge build` as a pre-step is cleaner. Write the embed.go file before running `go build` if it doesn't exist.
  </action>
  <verify>
Run `go build ./internal/cli/...` — compiles.

Run `go vet ./internal/cli/...` — no issues.
  </verify>
  <done>
forge build runs the full pipeline (generate -> templ -> tailwind -> go build). Build injects Version/Commit/Date via ldflags. Output is a single binary with -trimpath -ldflags="-s -w" for size reduction (DEPLOY-02). embed.go template generates //go:embed directives for migrations and static assets.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create forge deploy command and register build/deploy in root</name>
  <files>
    internal/cli/deploy.go
    internal/cli/root.go
  </files>
  <action>
1. Create `internal/cli/deploy.go`:
   - `func newDeployCmd() *cobra.Command`:
     - Use: "deploy"
     - Short: "Generate Dockerfile for deployment"
     - Long: "Generates a production Dockerfile in the project root. The Dockerfile uses a multi-stage build to produce a minimal container image."

   - `func runDeploy(cmd *cobra.Command, args []string) error`:
     a. Find project root
     b. Load config from forge.toml
     c. Check if Dockerfile already exists — if so, prompt or warn (print "Dockerfile already exists, overwriting" to stderr)
     d. Generate Dockerfile content using a Go template or string builder. Per research (Pattern 13):

     ```dockerfile
     # Build stage
     FROM golang:1.23-alpine AS builder
     RUN apk add --no-cache git ca-certificates
     WORKDIR /app
     COPY go.mod go.sum ./
     RUN go mod download
     COPY . .
     RUN go build -trimpath -ldflags="-s -w \
         -X main.Version=$(git describe --tags --always) \
         -X main.Commit=$(git rev-parse --short HEAD) \
         -X main.Date=$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
         -o /app/bin/server .

     # Runtime stage
     FROM alpine:3.21
     RUN apk add --no-cache ca-certificates tzdata
     COPY --from=builder /app/bin/server /usr/local/bin/server
     EXPOSE 8080 9090
     HEALTHCHECK --interval=30s --timeout=5s CMD wget -qO- http://localhost:9090/healthz || exit 1
     CMD ["server", "serve"]
     ```

     Use the project name from config for the binary name. Expose both the app port (from config, default 8080 in Dockerfile since production may differ) and admin port 9090.

     e. Write Dockerfile to project root
     f. Print success message: "Dockerfile generated at <path>"
     g. Print helpful next steps: "Build with: docker build -t <project-name> ."

2. Update `internal/cli/root.go`:
   - Add `rootCmd.AddCommand(newBuildCmd())` in the init() function
   - Add `rootCmd.AddCommand(newDeployCmd())` in the init() function
   - Place them after the existing command registrations

**Size target (DEPLOY-02):** The binary size < 30MB is achieved by `-trimpath -ldflags="-s -w"` which strips debug info and symbol table. Typical Go binaries with embedded assets (migrations ~200KB + static ~500KB) are well under 30MB. No additional work needed beyond the build flags.

**Startup time (DEPLOY-03):** Go binaries start natively — no JIT, no reflection-heavy init. pgxpool lazy-connects by default. River client starts goroutines asynchronously. The < 100ms cold start is inherently satisfied by the Go runtime. No special optimization needed.
  </action>
  <verify>
Run `go build ./internal/cli/...` — compiles.

Run `go vet ./internal/cli/...` — no issues.

Verify `forge build --help` and `forge deploy --help` show expected descriptions.
  </verify>
  <done>
forge build command runs full production pipeline with ldflags version injection. forge deploy generates a multi-stage Dockerfile with health check. Both commands registered in root.go. Binary size target met by -trimpath -ldflags="-s -w". Cold start target met by Go's native startup characteristics.
  </done>
</task>

</tasks>

<verification>
1. `go build ./internal/cli/...` — compiles
2. `go vet ./internal/cli/...` — no issues
3. `forge build --help` shows build command
4. `forge deploy --help` shows deploy command
5. Build command constructs correct ldflags string with -X flags
6. Deploy command generates valid multi-stage Dockerfile
</verification>

<success_criteria>
- forge build runs generate -> templ -> tailwind -> go build pipeline (CLI-03)
- Binary built with -trimpath -ldflags="-s -w" for minimal size (DEPLOY-02)
- Version/Commit/Date injected via ldflags for forge version and /healthz
- forge deploy generates a Dockerfile with multi-stage build and health check (CLI-07)
- Both commands accessible from CLI
- embed.go template provides //go:embed directives for migrations and static assets
- Cold start < 100ms inherent from Go runtime (DEPLOY-03)
</success_criteria>

<output>
After completion, create `.planning/phases/08-background-jobs-production-readiness/08-05-SUMMARY.md`
</output>
