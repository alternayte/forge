---
phase: 08-background-jobs-production-readiness
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/generator/factories.go
  - internal/generator/templates/atlas_schema.hcl.tmpl
  - internal/schema/hooks.go
  - internal/parser/ir.go
  - internal/parser/extractor.go
  - internal/generator/funcmap.go
autonomous: true
requirements:
  - SCHEMA-09

must_haves:
  truths:
    - "Generator tests that failed in Phase 7 verification now pass (FactoryTemplateData and AtlasTemplateData struct fixes)"
    - "schema.WithHooks(schema.Hooks{AfterCreate: []schema.JobRef{{Kind: 'x', Queue: 'y'}}}) is a valid SchemaItem in a Define() call"
    - "Parser extracts Hooks with AfterCreate and AfterUpdate JobRef slices into ResourceOptionsIR.Hooks"
    - "JobRefIR has Kind and Queue string fields accessible in templates"
  artifacts:
    - path: "internal/schema/hooks.go"
      provides: "JobRef type, Hooks type, HooksItem SchemaItem, WithHooks constructor"
      contains: "func WithHooks"
    - path: "internal/parser/ir.go"
      provides: "JobRefIR and HooksIR types on ResourceOptionsIR"
      contains: "HooksIR"
    - path: "internal/parser/extractor.go"
      provides: "extractHooks function and isHooksType detection"
      contains: "extractHooks"
  key_links:
    - from: "internal/schema/hooks.go"
      to: "internal/schema/definition.go"
      via: "HooksItem implements SchemaItem interface (schemaItem() method)"
      pattern: "func.*HooksItem.*schemaItem"
    - from: "internal/parser/extractor.go"
      to: "internal/parser/ir.go"
      via: "extractHooks populates ResourceOptionsIR.Hooks with HooksIR"
      pattern: "Hooks.*HooksIR"
---

<objective>
Fix Phase 7 generator regressions and extend the schema DSL, parser IR, and AST extractor to support lifecycle Hooks with JobRef references for River job enqueueing.

Purpose: Establishes clean test baseline (regressions) and provides the schema/parser foundation that Plan 04 (River integration) depends on for generating transactional job enqueue code.
Output: Fixed generator tests, new schema.Hooks DSL type, HooksIR/JobRefIR in parser IR, AST extraction of WithHooks calls.
</objective>

<execution_context>
@/Users/nathananderson-tennant/.claude/get-shit-done/workflows/execute-plan.md
@/Users/nathananderson-tennant/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-advanced-data-features/07-VERIFICATION.md
@.planning/phases/08-background-jobs-production-readiness/08-RESEARCH.md

# Key files for this plan
@internal/generator/factories.go
@internal/generator/atlas.go
@internal/generator/templates/atlas_schema.hcl.tmpl
@internal/schema/permission.go
@internal/schema/option.go
@internal/schema/definition.go
@internal/parser/ir.go
@internal/parser/extractor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix Phase 7 generator regressions and add Hooks schema DSL type</name>
  <files>
    internal/generator/factories.go
    internal/generator/templates/atlas_schema.hcl.tmpl
    internal/schema/hooks.go
  </files>
  <action>
**Part A — Fix Phase 7 regressions (from 07-VERIFICATION.md):**

1. In `internal/generator/factories.go`: Add `Options parser.ResourceOptionsIR` and `HasTimestamps bool` fields to `FactoryTemplateData` struct. In `GenerateFactories`, populate from `resource.Options` and `resource.HasTimestamps` in the loop.

2. In `internal/generator/templates/atlas_schema.hcl.tmpl`: Find line ~70 where `$.Options.SoftDelete` is used inside a `{{range .Resources}}` loop. Change `$.Options.SoftDelete` to `.Options.SoftDelete` — inside the range loop, `.` is the current `ResourceIR` which has the `Options` field. The `$` refers to `AtlasTemplateData` which does NOT have `Options`.

**Part B — Create schema Hooks DSL type:**

3. Create `internal/schema/hooks.go` with:
   - `JobRef` struct with `Kind string` and `Queue string` fields (per PRD Section 14.2)
   - `Hooks` struct with `AfterCreate []JobRef` and `AfterUpdate []JobRef`
   - `HooksItem` struct wrapping Hooks, implementing the `SchemaItem` interface via `schemaItem()` method
   - `WithHooks(h Hooks) *HooksItem` constructor function

Follow the exact pattern from `internal/schema/permission.go` (PermissionItem) for SchemaItem implementation. The types use only string literals (no Go functions) so they remain AST-parseable.

Example usage shape (from research):
```go
schema.WithHooks(schema.Hooks{
    AfterCreate: []schema.JobRef{
        {Kind: "notify_new_product", Queue: "notifications"},
    },
})
```
  </action>
  <verify>
Run `go test ./internal/generator/... -count=1 -run "TestGenerateAtlasSchema_ProductTable|TestAtlasUniqueIndex|TestGenerateFactories_ProductSchema|TestGenerateFactories_MultipleResources"` — all 4 previously-failing tests must pass.

Run `go build ./internal/schema/...` — compiles without errors.
  </verify>
  <done>
The 4 Phase 7 regression tests pass. `HooksItem` satisfies `SchemaItem` interface. `WithHooks()` constructor exists. `JobRef` and `Hooks` types are defined with the correct field shapes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend parser IR and AST extractor for Hooks</name>
  <files>
    internal/parser/ir.go
    internal/parser/extractor.go
  </files>
  <action>
1. In `internal/parser/ir.go`:
   - Add `JobRefIR` struct with `Kind string` and `Queue string` fields
   - Add `HooksIR` struct with `AfterCreate []JobRefIR` and `AfterUpdate []JobRefIR`
   - Add `Hooks HooksIR` field to `ResourceOptionsIR` struct

2. In `internal/parser/extractor.go`:
   - Add `isHooksType(name string) bool` function that returns true for `"WithHooks"` (matching the schema.WithHooks constructor name). Follow the same pattern as `isPermissionType()`.
   - Add `extractHooks(callExpr *ast.CallExpr) (HooksIR, error)` function. This must:
     a. Navigate the AST of `schema.WithHooks(schema.Hooks{...})` — the argument is a composite literal of type `schema.Hooks`
     b. For each field in the composite literal (AfterCreate, AfterUpdate), extract the slice of `schema.JobRef` composite literals
     c. For each JobRef, extract the `Kind` and `Queue` string literal values
     d. Return a populated `HooksIR`
   - In `extractSchemaDefinition()`, add a branch for `isHooksType` that calls `extractHooks` and assigns the result to `resource.Options.Hooks`. Place it alongside the existing `isPermissionType` branch.

**AST structure reference:** `schema.WithHooks(schema.Hooks{AfterCreate: []schema.JobRef{{Kind: "x", Queue: "y"}}})` parses as:
- CallExpr with Fun=SelectorExpr(schema.WithHooks)
- Args[0] = CompositeLit (type schema.Hooks)
  - Elts: KeyValueExpr (Key="AfterCreate", Value=CompositeLit of []schema.JobRef)
    - Elts: CompositeLit (type schema.JobRef) with KeyValueExpr entries for Kind and Queue

Follow the existing extraction patterns for Permission (composite literals with string values). Use `basicLit.Value` after unquoting for string extraction.

3. Add two funcmap helpers in `internal/generator/funcmap.go` and register both in `BuildFuncMap()`:

   a. `hasHooks` — returns true when either AfterCreate or AfterUpdate is non-empty. Needed by the actions template in Plan 04.
      ```go
      "hasHooks": func(opts parser.ResourceOptionsIR) bool {
          return len(opts.Hooks.AfterCreate) > 0 || len(opts.Hooks.AfterUpdate) > 0
      },
      ```

   b. `pascal` — converts snake_case strings to PascalCase by splitting on underscores and title-casing each segment. Needed by scaffold_jobs.go.tmpl and actions.go.tmpl in Plan 04 for converting Kind strings like `"notify_new_product"` to `"NotifyNewProduct"`. The existing `camel` function only uppercases the first letter and does NOT handle underscores — this is a different function.
      ```go
      // pascal converts snake_case to PascalCase (e.g., "notify_new_product" -> "NotifyNewProduct").
      func pascal(s string) string {
          parts := strings.Split(s, "_")
          for i, p := range parts {
              if len(p) > 0 {
                  parts[i] = strings.ToUpper(p[:1]) + p[1:]
              }
          }
          return strings.Join(parts, "")
      }
      ```
      Register as `"pascal": pascal` in BuildFuncMap(). This must be added unconditionally — Plan 04 templates depend on it.
  </action>
  <verify>
Run `go test ./internal/parser/... -count=1` — all existing parser tests pass (no regressions).

Run `go build ./internal/parser/...` and `go build ./internal/generator/...` — both compile.

Run `go vet ./internal/parser/...` — no issues.
  </verify>
  <done>
`JobRefIR` and `HooksIR` types exist in ir.go. `ResourceOptionsIR.Hooks` field exists. Parser extracts `WithHooks` calls from schema files into `HooksIR` with correct Kind/Queue values. `hasHooks` and `pascal` funcmap helpers registered in BuildFuncMap. `pascal("notify_new_product")` returns `"NotifyNewProduct"`. All existing parser tests pass without regression.
  </done>
</task>

</tasks>

<verification>
1. `go test ./internal/generator/... -count=1` — all tests pass (including previously-failing 4)
2. `go test ./internal/parser/... -count=1` — all tests pass
3. `go build ./...` — entire project compiles
4. `go vet ./...` — no issues
</verification>

<success_criteria>
- Phase 7 generator regressions resolved (4 tests green)
- schema.Hooks DSL type with JobRef available for schema definitions
- Parser extracts WithHooks into HooksIR on ResourceOptionsIR
- hasHooks funcmap helper available for template conditionals
- pascal funcmap helper converts snake_case to PascalCase (e.g., "notify_new_product" -> "NotifyNewProduct")
- All existing tests pass (no new regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-background-jobs-production-readiness/08-01-SUMMARY.md`
</output>
